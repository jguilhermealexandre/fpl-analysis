<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPL Live Analysis Dashboard</title>
    <link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@300;400;500&family=Space+Mono:wght@700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-dark: #0a0e14;
            --bg-darker: #050810;
            --surface: #151920;
            --surface-light: #1d242e;
            --accent-green: #00ff88;
            --accent-red: #ff3366;
            --accent-yellow: #ffcc00;
            --accent-blue: #00ccff;
            --text: #e0e5ed;
            --text-dim: #8b95a5;
            --border: #2a3340;
        }

        body {
            background: var(--bg-dark);
            color: var(--text);
            font-family: 'DM Mono', monospace;
            font-size: 11px;
            line-height: 1.4;
            overflow-x: hidden;
        }

        .header {
            background: linear-gradient(135deg, var(--bg-darker) 0%, var(--surface) 100%);
            border-bottom: 2px solid var(--accent-green);
            padding: 20px 30px;
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0, 255, 136, 0.1);
        }

        .header h1 {
            font-family: 'Space Mono', monospace;
            font-size: 28px;
            color: var(--accent-green);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        .header p {
            color: var(--text-dim);
            font-size: 11px;
            letter-spacing: 1px;
        }

        .controls {
            background: var(--surface);
            padding: 15px 30px;
            border-bottom: 1px solid var(--border);
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .btn {
            background: linear-gradient(135deg, var(--accent-green) 0%, #00cc70 100%);
            color: var(--bg-dark);
            border: none;
            padding: 10px 20px;
            font-family: 'DM Mono', monospace;
            font-weight: 500;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .status {
            color: var(--text-dim);
            font-size: 10px;
            padding: 8px 15px;
            background: var(--surface-light);
            border-radius: 3px;
            border-left: 3px solid var(--accent-blue);
        }

        .status.loading {
            border-left-color: var(--accent-yellow);
            animation: pulse 1.5s ease-in-out infinite;
        }

        .status.success {
            border-left-color: var(--accent-green);
        }

        .status.error {
            border-left-color: var(--accent-red);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .tabs {
            display: flex;
            gap: 0;
            background: var(--surface);
            padding: 0 30px;
            border-bottom: 2px solid var(--border);
            overflow-x: auto;
        }

        .tab {
            padding: 12px 24px;
            background: transparent;
            border: none;
            color: var(--text-dim);
            font-family: 'DM Mono', monospace;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.2s ease;
            border-bottom: 3px solid transparent;
            position: relative;
        }

        .tab:hover {
            color: var(--text);
            background: var(--surface-light);
        }

        .tab.active {
            color: var(--accent-green);
            border-bottom-color: var(--accent-green);
            background: var(--surface-light);
        }

        .content {
            padding: 30px;
        }

        .position-section {
            display: none;
        }

        .position-section.active {
            display: block;
        }

        .table-container {
            background: var(--surface);
            border: 1px solid var(--border);
            overflow-x: auto;
            margin-bottom: 30px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 10px;
        }

        thead {
            background: var(--surface-light);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        th {
            padding: 8px 6px;
            text-align: left;
            font-weight: 500;
            color: var(--accent-green);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 2px solid var(--accent-green);
            border-right: 1px solid var(--border);
            font-size: 9px;
            white-space: nowrap;
            cursor: pointer;
            user-select: none;
            position: relative;
        }

        th:hover {
            background: var(--surface);
        }

        th:first-child {
            position: sticky;
            left: 0;
            background: var(--surface-light);
            z-index: 101;
        }

        th:first-child:hover {
            background: var(--surface);
        }

        .sort-icon {
            display: inline-block;
            margin-left: 4px;
            font-size: 8px;
            opacity: 0.5;
        }

        .sort-icon.active {
            opacity: 1;
            color: var(--accent-green);
        }

        .filter-row {
            background: var(--surface-light);
        }

        .filter-row th {
            padding: 4px 3px;
            border-bottom: 1px solid var(--border);
        }

        .filter-row th:first-child {
            position: sticky;
            left: 0;
            background: var(--surface-light);
            z-index: 101;
        }

        .filter-input {
            width: 100%;
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text);
            font-family: 'DM Mono', monospace;
            font-size: 9px;
            padding: 3px 4px;
            outline: none;
        }

        .filter-input:focus {
            border-color: var(--accent-green);
            box-shadow: 0 0 5px rgba(0, 255, 136, 0.2);
        }

        .filter-input::placeholder {
            color: var(--text-dim);
            opacity: 0.5;
        }

        td {
            padding: 6px 6px;
            border-bottom: 1px solid var(--border);
            border-right: 1px solid var(--border);
            white-space: nowrap;
        }

        td:first-child {
            position: sticky;
            left: 0;
            background: var(--surface);
            z-index: 99;
            font-weight: 500;
            color: var(--text);
        }

        tr:hover td {
            background: var(--surface-light);
        }

        tr:hover td:first-child {
            background: var(--surface-light);
        }

        .trend-positive {
            background: rgba(0, 255, 136, 0.15);
            color: var(--accent-green);
        }

        .trend-negative {
            background: rgba(255, 51, 102, 0.15);
            color: var(--accent-red);
        }

        .trend-neutral {
            background: rgba(255, 204, 0, 0.15);
            color: var(--accent-yellow);
        }

        .stat-high {
            color: var(--accent-green);
            font-weight: 500;
        }

        .stat-low {
            color: var(--accent-red);
        }

        .stat-medium {
            color: var(--text-dim);
        }

        .player-cell {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .team-badge {
            font-size: 8px;
            padding: 2px 4px;
            background: var(--surface-light);
            border-radius: 2px;
            color: var(--accent-blue);
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 14, 20, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .loading-overlay.show {
            opacity: 1;
            pointer-events: all;
        }

        .loader {
            text-align: center;
        }

        .loader-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid var(--border);
            border-top-color: var(--accent-green);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loader-text {
            color: var(--accent-green);
            font-size: 12px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .legend {
            display: flex;
            gap: 20px;
            padding: 15px 30px;
            background: var(--surface);
            border-top: 1px solid var(--border);
            font-size: 9px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-box {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .no-data {
            text-align: center;
            padding: 60px;
            color: var(--text-dim);
            font-size: 12px;
        }

        .recommendations-container {
            display: flex;
            flex-direction: column;
            gap: 40px;
        }

        .position-recommendations {
            background: var(--surface);
            border: 1px solid var(--border);
            padding: 25px;
        }

        .position-recommendations h2 {
            font-family: 'Space Mono', monospace;
            font-size: 18px;
            color: var(--accent-green);
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 2px solid var(--accent-green);
            padding-bottom: 10px;
        }

        .recommendations-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .rec-category {
            background: var(--surface-light);
            padding: 20px;
            border: 1px solid var(--border);
        }

        .rec-category h3 {
            font-size: 13px;
            color: var(--accent-blue);
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .rec-category.budget h3 {
            color: var(--accent-green);
        }

        .rec-category.premium h3 {
            color: var(--accent-yellow);
        }

        .player-rec-card {
            background: var(--bg-dark);
            padding: 12px;
            margin-bottom: 10px;
            border-left: 3px solid var(--accent-green);
            transition: all 0.2s ease;
        }

        .player-rec-card:hover {
            background: var(--surface);
            transform: translateX(5px);
        }

        .player-rec-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .player-rec-name {
            font-weight: 500;
            font-size: 12px;
            color: var(--text);
        }

        .player-rec-price {
            font-size: 11px;
            color: var(--accent-yellow);
            font-weight: 500;
        }

        .player-rec-team {
            font-size: 9px;
            color: var(--text-dim);
            margin-bottom: 8px;
        }

        .player-rec-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            font-size: 9px;
        }

        .player-rec-stat {
            display: flex;
            flex-direction: column;
        }

        .player-rec-stat-label {
            color: var(--text-dim);
            font-size: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .player-rec-stat-value {
            color: var(--accent-green);
            font-weight: 500;
            margin-top: 2px;
        }

        .player-rec-stat-value.trend-up {
            color: var(--accent-green);
        }

        .player-rec-stat-value.trend-down {
            color: var(--accent-red);
        }

        .rec-reason {
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px solid var(--border);
            font-size: 9px;
            color: var(--text-dim);
            font-style: italic;
        }

        /* Guide Section Styles */
        .guide-section {
            background: var(--surface);
            border-bottom: 2px solid var(--border);
        }

        .guide-header {
            padding: 20px 30px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
            border-bottom: 1px solid transparent;
        }

        .guide-header:hover {
            background: var(--surface-light);
            border-bottom-color: var(--accent-green);
        }

        .guide-title {
            font-size: 14px;
            color: var(--accent-green);
            font-weight: 500;
            display: block;
            margin-bottom: 3px;
        }

        .guide-subtitle {
            font-size: 9px;
            color: var(--text-dim);
            display: block;
        }

        .guide-toggle {
            font-size: 20px;
            color: var(--accent-green);
            transition: transform 0.3s ease;
        }

        .guide-toggle.open {
            transform: rotate(180deg);
        }

        .guide-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease;
        }

        .guide-content.open {
            max-height: 15000px;
        }

        .guide-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            padding: 30px;
        }

        .guide-card {
            background: var(--bg-darker);
            border: 1px solid var(--border);
            padding: 20px;
            border-left: 3px solid var(--accent-green);
        }

        .guide-card h3 {
            color: var(--accent-green);
            font-size: 13px;
            margin-bottom: 15px;
            font-family: 'Space Mono', monospace;
        }

        .guide-text {
            font-size: 10px;
            line-height: 1.6;
            color: var(--text);
        }

        .guide-text p {
            margin-bottom: 12px;
        }

        .guide-text strong {
            color: var(--accent-green);
            font-weight: 500;
        }

        .guide-text ul {
            margin: 10px 0 10px 20px;
            list-style-type: none;
        }

        .guide-text ul li {
            margin-bottom: 8px;
            position: relative;
            padding-left: 15px;
        }

        .guide-text ul li::before {
            content: "‚ñ∏";
            position: absolute;
            left: 0;
            color: var(--accent-green);
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 20px;
            }
            
            .content {
                padding: 15px;
            }
            
            th, td {
                padding: 4px 3px;
                font-size: 9px;
            }

            .recommendations-grid {
                grid-template-columns: 1fr;
            }
        }

        .back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(21, 25, 32, 0.95);
            border: 2px solid var(--border);
            color: var(--text);
            padding: 10px 20px;
            font-family: 'DM Mono', monospace;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10000;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .back-button:hover {
            border-color: var(--accent-green);
            color: var(--accent-green);
            transform: translateX(-3px);
        }

        /* Preset Filters & Global Search */
        .preset-filters {
            background: var(--surface);
            padding: 12px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .preset-btn {
            background: var(--surface-light);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 6px 12px;
            font-family: 'DM Mono', monospace;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .preset-btn:hover {
            border-color: var(--accent-green);
            background: var(--surface);
            color: var(--accent-green);
        }

        .preset-btn.active {
            border-color: var(--accent-green);
            background: linear-gradient(135deg, var(--accent-green) 0%, #00cc70 100%);
            color: var(--bg-dark);
        }

        .global-search {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .global-search input {
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text);
            font-family: 'DM Mono', monospace;
            font-size: 10px;
            padding: 6px 12px;
            min-width: 200px;
            outline: none;
        }

        .global-search input:focus {
            border-color: var(--accent-green);
            box-shadow: 0 0 5px rgba(0, 255, 136, 0.2);
        }

        .export-btn {
            background: linear-gradient(135deg, var(--accent-blue) 0%, #0099cc 100%);
            color: var(--bg-dark);
            border: none;
            padding: 6px 12px;
            font-family: 'DM Mono', monospace;
            font-size: 10px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        .export-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 10px rgba(0, 204, 255, 0.3);
        }

        /* Advanced Filters Row */
        .advanced-filters {
            background: var(--surface-light);
            padding: 12px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .filter-chip {
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 4px 10px;
            font-family: 'DM Mono', monospace;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 12px;
        }

        .filter-chip:hover {
            border-color: var(--accent-green);
            background: var(--surface-light);
            transform: translateY(-1px);
        }

        .filter-chip.active {
            border-color: var(--accent-green);
            background: var(--accent-green);
            color: var(--bg-dark);
            font-weight: 500;
        }

        .filter-apply-btn {
            background: var(--accent-green);
            border: none;
            color: var(--bg-dark);
            padding: 4px 12px;
            font-family: 'DM Mono', monospace;
            font-size: 9px;
            cursor: pointer;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.2s ease;
        }

        .filter-apply-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(0, 255, 136, 0.3);
        }

        #priceMin, #priceMax, #ownershipMin, #ownershipMax {
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text);
            font-family: 'DM Mono', monospace;
            font-size: 9px;
            padding: 4px 6px;
            outline: none;
            text-align: center;
        }

        #priceMin:focus, #priceMax:focus, #ownershipMin:focus, #ownershipMax:focus {
            border-color: var(--accent-green);
        }

        /* Column Group Toggles */
        .column-toggles {
            background: var(--surface-light);
            padding: 8px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            gap: 15px;
            align-items: center;
            font-size: 10px;
        }

        .column-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            user-select: none;
        }

        .column-toggle input[type="checkbox"] {
            cursor: pointer;
        }

        .column-toggle label {
            cursor: pointer;
            color: var(--text);
        }

        /* Sparkline Canvas */
        .sparkline-cell {
            padding: 2px !important;
            width: 60px;
            min-width: 60px;
            max-width: 60px;
        }

        .sparkline-canvas {
            width: 55px;
            height: 20px;
            display: block;
        }

        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            th, td {
                font-size: 8px;
                padding: 4px 3px;
            }

            .table-container {
                font-size: 8px;
            }

            .preset-filters {
                padding: 8px 10px;
            }

            .preset-btn {
                font-size: 8px;
                padding: 4px 8px;
            }

            .global-search input {
                min-width: 120px;
                font-size: 9px;
            }

            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .btn {
                width: 100%;
                justify-content: center;
            }
        }

        /* Column group classes for show/hide */
        .col-basic { }
        .col-attacking { }
        .col-defensive { }
        .col-advanced { }

        .col-attacking.hidden,
        .col-defensive.hidden,
        .col-advanced.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-button">
        <span>‚Üê</span> Back to Home
    </a>

    <div class="loading-overlay" id="loadingOverlay">
        <div class="loader">
            <div class="loader-spinner"></div>
            <div class="loader-text">Fetching Live FPL Data...</div>
        </div>
    </div>

    <div class="header">
        <h1>‚ö° FPL Live Analysis</h1>
        <p>Real-time player performance metrics from Fantasy Premier League API</p>
    </div>

    <div class="guide-section" id="guideSection">
        <div class="guide-header" onclick="toggleGuide()">
            <div>
                <span class="guide-title">üìö How to Use This Tool & Make Smart Player Decisions</span>
                <span class="guide-subtitle">Click to expand comprehensive guide on player selection strategy</span>
            </div>
            <span class="guide-toggle" id="guideToggle">‚ñº</span>
        </div>
        <div class="guide-content" id="guideContent">
            <div class="guide-grid">
                <div class="guide-card">
                    <h3>‚≠ê Using the Recommendations Tab</h3>
                    <div class="guide-text">
                        <p><strong>What it does:</strong> Automatically identifies the best value players in each position based on research-backed FPL metrics.</p>
                        
                        <p><strong>How players are scored:</strong></p>
                        <ul>
                            <li><strong>Points per Million (30% weight):</strong> The #1 factor. Shows true value - a ¬£5m player averaging 5pts/game (1.0 pts/¬£m) beats an ¬£8m player averaging 6pts/game (0.75 pts/¬£m)</li>
                            <li><strong>xGI - Expected Goal Involvements (25%):</strong> More predictive than actual goals. High xGI with low returns = player is DUE</li>
                            <li><strong>Minutes Consistency (15%):</strong> Must average 75+ mins in last 5 games. "Nailed on" starters only</li>
                            <li><strong>Form Direction (10%):</strong> Is xGI improving? Bonus for rising trend</li>
                        </ul>
                        
                        <p><strong>Budget vs Premium split:</strong></p>
                        <ul>
                            <li><strong>Budget:</strong> GK ‚â§¬£5.0m, DEF ‚â§¬£5.5m, MID ‚â§¬£7.0m, FWD ‚â§¬£7.5m</li>
                            <li><strong>Premium:</strong> Above these thresholds - your captaincy candidates and consistent performers</li>
                        </ul>
                        
                        <p><strong>Key indicators:</strong></p>
                        <ul>
                            <li>"Excellent value at 1.52 pts/¬£m" = Strong pick</li>
                            <li>"Nailed on starter" = 75+ mins consistently</li>
                            <li>"Underperforming xGI - due returns" = HIGH PRIORITY! Player creating chances but not converting yet</li>
                            <li>"Strong xGI of 0.68/game" = Attacking threat</li>
                        </ul>
                    </div>
                </div>

                <div class="guide-card">
                    <h3>üìä Understanding xG, xA, and xGI</h3>
                    <div class="guide-text">
                        <p><strong>Why these matter more than goals/assists:</strong> They predict FUTURE performance, not just past results. A player with high xG but few goals is due for a scoring run.</p>
                        
                        <p><strong>xG (Expected Goals):</strong></p>
                        <ul>
                            <li>Measures quality of scoring chances from 0.0 to 1.0</li>
                            <li>0.05 = 25-yard shot (5% chance to score)</li>
                            <li>0.95 = open goal 6 yards out (95% chance)</li>
                            <li><strong>How to use:</strong> Compare xG to actual goals. If actual goals < xG = unlucky, due for returns. If actual > xG = overperforming, may regress</li>
                        </ul>
                        
                        <p><strong>xA (Expected Assists):</strong></p>
                        <ul>
                            <li>Probability that a pass leads to a goal</li>
                            <li>Measures creativity and chance creation</li>
                            <li><strong>How to use:</strong> High xA players are creating chances. If teammates start finishing, assists will come</li>
                        </ul>
                        
                        <p><strong>xGI (Expected Goal Involvement = xG + xA):</strong></p>
                        <ul>
                            <li>Total attacking threat per game</li>
                            <li><strong>Excellent:</strong> 0.6+ per game</li>
                            <li><strong>Good:</strong> 0.4-0.6 per game</li>
                            <li><strong>Average:</strong> 0.2-0.4 per game</li>
                        </ul>
                        
                        <p><strong>Pro tip:</strong> Sort by xGI (L5) to find in-form players. Look for discrepancies - players with high xGI but low actual returns are your differentials!</p>
                    </div>
                </div>

                <div class="guide-card">
                    <h3>üìà Season vs Last 5 Games (L5)</h3>
                    <div class="guide-text">
                        <p><strong>The Core Concept:</strong> Recent form (L5) predicts immediate performance better than season averages. But you need BOTH.</p>
                        
                        <p><strong>How to interpret trends (Œî%):</strong></p>
                        <ul>
                            <li><strong>Green (>10%):</strong> Player improving! L5 stats significantly better than season average. Prime target if sustained</li>
                            <li><strong>Yellow (-10% to +10%):</strong> Consistent. What you see is what you get</li>
                            <li><strong>Red (<-10%):</strong> Declining. Recent form worse than season average. Sell or avoid unless fixtures are about to turn</li>
                        </ul>
                        
                        <p><strong>Key metrics to compare:</strong></p>
                        <ul>
                            <li><strong>Minutes:</strong> Trending up = nailed on. Trending down = rotation risk</li>
                            <li><strong>xGI:</strong> Trending up = improving underlying stats, returns coming</li>
                            <li><strong>Points:</strong> Trending up + high xGI = hold. Trending up + low xGI = may regress (got lucky)</li>
                        </ul>
                        
                        <p><strong>Example:</strong> Player has 0.3 xGI season average but 0.6 xGI in L5 (green +100%). Even if points are still low, this player's chances have DOUBLED. Returns are coming.</p>
                    </div>
                </div>

                <div class="guide-card">
                    <h3>üí∞ Points Per Million: The Value Game</h3>
                    <div class="guide-text">
                        <p><strong>Why it matters:</strong> FPL is about maximizing points with limited budget. A ¬£5m player scoring 5pts/week (1.0 pts/¬£m) is better value than a ¬£10m player scoring 8pts/week (0.8 pts/¬£m).</p>
                        
                        <p><strong>Value benchmarks by position:</strong></p>
                        <ul>
                            <li><strong>Goalkeepers:</strong> 0.8+ pts/¬£m is good, 1.0+ is excellent</li>
                            <li><strong>Defenders:</strong> 0.9+ pts/¬£m is good, 1.2+ is excellent</li>
                            <li><strong>Midfielders:</strong> 0.8+ pts/¬£m is good, 1.1+ is excellent</li>
                            <li><strong>Forwards:</strong> 0.7+ pts/¬£m is good, 1.0+ is excellent</li>
                        </ul>
                        
                        <p><strong>Strategy:</strong></p>
                        <ul>
                            <li><strong>3 Premium + 8 Value:</strong> Spend on 2-3 premiums (Salah, Haaland) who score regardless of value. Fill rest with high pts/¬£m picks</li>
                            <li><strong>Budget enablers:</strong> ¬£4.5m-¬£5.5m players with good pts/¬£m who free up budget for premiums</li>
                            <li><strong>Sweet spot:</strong> ¬£6.5m-¬£8.0m midfielders with 1.0+ pts/¬£m often outperform ¬£9m+ options</li>
                        </ul>
                        
                        <p><strong>Use filtering:</strong> Filter by price range, then sort by pts/¬£m (L5) to find budget gems</p>
                    </div>
                </div>

                <div class="guide-card">
                    <h3>üéØ Position-Specific Strategies</h3>
                    <div class="guide-text">
                        <p><strong>Goalkeepers:</strong></p>
                        <ul>
                            <li><strong>Key stats:</strong> Clean sheets (most points), saves (bonus points)</li>
                            <li><strong>Strategy:</strong> Pick from top 6 teams with good fixtures. Rotate two ¬£4.5m options based on fixtures OR go premium (¬£5.5m+) and set-and-forget</li>
                            <li><strong>Red flag:</strong> Team conceding 2+ goals/game = fewer clean sheets</li>
                        </ul>
                        
                        <p><strong>Defenders:</strong></p>
                        <ul>
                            <li><strong>Key stats:</strong> Clean sheets > attacking returns. xGI is bonus, not requirement</li>
                            <li><strong>Strategy:</strong> 3-4 defenders from teams with good defensive stats (low goals conceded) AND easy fixtures. ¬£4.5m-¬£5.5m sweet spot</li>
                            <li><strong>Premium pick:</strong> Only if they combine clean sheets + high xGI (TAA, Cancelo types)</li>
                        </ul>
                        
                        <p><strong>Midfielders:</strong></p>
                        <ul>
                            <li><strong>Key stats:</strong> xGI, key passes, BCC (big chances created). Goals = 5pts, assists = 3pts</li>
                            <li><strong>Strategy:</strong> 1-2 premium captaincy options (Salah, Son). 2-3 value picks (¬£6.5m-¬£8.0m with high xGI)</li>
                            <li><strong>Look for:</strong> Set piece takers (corners, free kicks) = bonus xA</li>
                        </ul>
                        
                        <p><strong>Forwards:</strong></p>
                        <ul>
                            <li><strong>Key stats:</strong> xG, big chances missed (high BCM + high xG = player getting chances). Goals = 4pts only</li>
                            <li><strong>Strategy:</strong> 1-2 forwards max. Either premium (Haaland) or budget enabler (¬£6.5m-¬£7.5m with high xG)</li>
                            <li><strong>Avoid:</strong> Mid-price (¬£8m-¬£9.5m) forwards - usually worse value than midfielders at same price</li>
                        </ul>
                    </div>
                </div>

                <div class="guide-card">
                    <h3>üîç Using Filters & Sorting Effectively</h3>
                    <div class="guide-text">
                        <p><strong>Filter operators:</strong></p>
                        <ul>
                            <li><strong>Default (numbers):</strong> >= (greater than or equal)</li>
                            <li><strong>Type >= to find:</strong> "80" in minutes = all players with 80+ average minutes</li>
                            <li><strong>Other operators:</strong> > (greater), < (less), <= (less than or equal)</li>
                            <li><strong>Text:</strong> Partial matching. "Liv" finds Liverpool players</li>
                        </ul>
                        
                        <p><strong>Power user workflows:</strong></p>
                        <ul>
                            <li><strong>Find nailed budget defenders:</strong> Filter price <5.5, minutes (L5) >=75, sort by pts/¬£m</li>
                            <li><strong>Find value midfielders:</strong> Filter price 6.5-8.0, xGI (L5) >=0.4, sort by pts/¬£m</li>
                            <li><strong>Find due-for-returns players:</strong> Sort by xGI (L5), look for high xGI with low goals/assists</li>
                            <li><strong>Check rotation risk:</strong> Filter minutes (L5) <75 to see who's being rotated</li>
                        </ul>
                        
                        <p><strong>Click any header to sort:</strong> Click again to reverse. ‚Üë = ascending, ‚Üì = descending</p>
                    </div>
                </div>

                <div class="guide-card">
                    <h3>üí° Common Stat Abbreviations Explained</h3>
                    <div class="guide-text">
                        <ul>
                            <li><strong>GP:</strong> Games Played</li>
                            <li><strong>Mins:</strong> Average minutes per game</li>
                            <li><strong>Pts:</strong> Total FPL points</li>
                            <li><strong>G:</strong> Goals scored</li>
                            <li><strong>A:</strong> Assists</li>
                            <li><strong>xG:</strong> Expected Goals (quality of chances)</li>
                            <li><strong>xA:</strong> Expected Assists (quality of passes)</li>
                            <li><strong>xGI:</strong> Expected Goal Involvement (xG + xA)</li>
                            <li><strong>CS:</strong> Clean Sheets (defenders/GK)</li>
                            <li><strong>GC:</strong> Goals Conceded (defenders/GK)</li>
                            <li><strong>xGC:</strong> Expected Goals Conceded</li>
                            <li><strong>BCC:</strong> Big Chances Created (pass that should result in a goal)</li>
                            <li><strong>BCM:</strong> Big Chances Missed (should have scored but didn't)</li>
                            <li><strong>KP:</strong> Key Passes (pass that leads to a shot)</li>
                            <li><strong>Bonus:</strong> Bonus points earned (best 3 performers get 3/2/1 pts)</li>
                            <li><strong>BPS:</strong> Bonus Points System score (determines who gets bonus)</li>
                            <li><strong>ICT:</strong> Index combining Influence, Creativity, Threat</li>
                            <li><strong>Œî%:</strong> Percent change (L5 vs Season average)</li>
                        </ul>
                    </div>
                </div>

                <div class="guide-card">
                    <h3>‚ö†Ô∏è Common Mistakes to Avoid</h3>
                    <div class="guide-text">
                        <ul>
                            <li><strong>‚ùå Chasing last week's points:</strong> Player scored 15 pts? Everyone sees it. Price rises, ownership spikes. You're late. Use xGI to find NEXT week's haul</li>
                            <li><strong>‚ùå Ignoring minutes:</strong> 60 min average in L5 = rotation risk. You need 75+ for confidence. One benching ruins your gameweek</li>
                            <li><strong>‚ùå Only looking at goals/assists:</strong> Actual returns fluctuate wildly. xGI is more stable and predictive. High xGI player blank 3 games = buy. Low xGI player scores twice = sell</li>
                            <li><strong>‚ùå Overvaluing expensive players:</strong> An ¬£11m player needs 8+ pts/week to match a ¬£6m player scoring 4.5pts/week. Many don't deliver the value</li>
                            <li><strong>‚ùå Ignoring fixtures:</strong> Even premiums struggle with 4 consecutive red fixtures. Always check team analysis alongside player stats</li>
                            <li><strong>‚ùå Not using the Recommendations tab:</strong> It does the math for you! Budget + Premium picks based on all the metrics discussed here</li>
                        </ul>
                        
                        <p><strong>‚úÖ What to do instead:</strong></p>
                        <ul>
                            <li>Start with Recommendations tab for ideas</li>
                            <li>Verify with position tabs - check full stats</li>
                            <li>Look at xGI trends (green = buy signal)</li>
                            <li>Filter by minutes to ensure they're nailed</li>
                            <li>Check pts/¬£m for value confirmation</li>
                            <li>Cross-reference with team fixtures (use teams analysis tool)</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="controls">
        <button class="btn" id="refreshBtn" onclick="loadData(true)">
            üîÑ Force Refresh
        </button>
        <button class="btn" onclick="clearCache()" style="background: linear-gradient(135deg, var(--accent-red) 0%, #cc2952 100%);">
            üóëÔ∏è Clear Cache
        </button>
        <div class="status" id="status">
            Ready to load data (will auto-load from cache if available)
        </div>
        <div id="cacheInfo" style="font-size: 10px; color: var(--text-dim); margin-left: 10px;"></div>
    </div>

    <div class="tabs" id="tabs">
        <button class="tab" data-position="RECOMMENDATIONS">‚≠ê Recommendations</button>
        <button class="tab" data-position="FORM">üî• Form Players</button>
        <button class="tab" data-position="CHARTS">üìä Charts</button>
        <button class="tab" data-position="FIXTURES">üìÖ Fixtures</button>
        <button class="tab" data-position="GK">üß§ Goalkeepers</button>
        <button class="tab" data-position="DEF">üõ°Ô∏è Defenders</button>
        <button class="tab" data-position="MID">‚ö° Midfielders</button>
        <button class="tab" data-position="FWD">üéØ Forwards</button>
    </div>

    <!-- Preset Filters & Global Search -->
    <div class="preset-filters" id="presetFilters" style="display: none;">
        <button class="preset-btn" onclick="applyPreset('budget-enablers')">üí∞ Budget Enablers</button>
        <button class="preset-btn" onclick="applyPreset('form-players')">üî• Form Players</button>
        <button class="preset-btn" onclick="applyPreset('nailed-starters')">üîí Nailed Starters</button>
        <button class="preset-btn" onclick="applyPreset('value-picks')">üíé Value Picks</button>
        <button class="preset-btn" onclick="applyPreset('easy-fixtures')">üü¢ Easy Fixtures</button>
        <button class="preset-btn" onclick="applyPreset('clear')">‚úñÔ∏è Clear</button>
        <div class="global-search">
            <span style="color: var(--text-dim); font-size: 10px;">üîç SEARCH:</span>
            <input type="text" id="globalSearch" placeholder="Search all players..." oninput="globalSearch()">
            <button class="export-btn" onclick="exportToCSV()">üìä Export CSV</button>
        </div>
    </div>

    <!-- Advanced Filters Row -->
    <div class="advanced-filters" id="advancedFilters" style="display: none;">
        <div class="filter-group">
            <span style="color: var(--text-dim); font-size: 10px; margin-right: 8px;">üéØ FIXTURES:</span>
            <button class="filter-chip" onclick="applyAdvancedFilter('fdr', 'easy')">üü¢üü¢ Easy (<2.6)</button>
            <button class="filter-chip" onclick="applyAdvancedFilter('fdr', 'favorable')">üü¢ Favorable (<2.9)</button>
            <button class="filter-chip" onclick="applyAdvancedFilter('fdr', 'neutral')">üü° Neutral (2.9-3.1)</button>
            <button class="filter-chip" onclick="applyAdvancedFilter('fdr', 'tough')">üî¥ Tough (>3.4)</button>
        </div>
        
        <div class="filter-group">
            <span style="color: var(--text-dim); font-size: 10px; margin-right: 8px;">üí∞ PRICE:</span>
            <button class="filter-chip" onclick="applyAdvancedFilter('price', 'budget')">Budget (<¬£5.5)</button>
            <button class="filter-chip" onclick="applyAdvancedFilter('price', 'mid')">Mid (¬£5.5-¬£8.0)</button>
            <button class="filter-chip" onclick="applyAdvancedFilter('price', 'premium')">Premium (>¬£8.0)</button>
            <span style="color: var(--text-dim); font-size: 10px; margin: 0 8px;">or</span>
            <input type="number" id="priceMin" placeholder="Min" step="0.1" min="4" max="15" style="width: 60px;">
            <span style="color: var(--text-dim); margin: 0 4px;">-</span>
            <input type="number" id="priceMax" placeholder="Max" step="0.1" min="4" max="15" style="width: 60px;">
            <button class="filter-apply-btn" onclick="applyCustomPriceFilter()">Apply</button>
        </div>
        
        <div class="filter-group">
            <span style="color: var(--text-dim); font-size: 10px; margin-right: 8px;">üë• OWNERSHIP:</span>
            <button class="filter-chip" onclick="applyAdvancedFilter('ownership', 'template')">Template (>20%)</button>
            <button class="filter-chip" onclick="applyAdvancedFilter('ownership', 'popular')">Popular (10-20%)</button>
            <button class="filter-chip" onclick="applyAdvancedFilter('ownership', 'differential')">Differential (<10%)</button>
            <button class="filter-chip" onclick="applyAdvancedFilter('ownership', 'unique')">Unique (<5%)</button>
            <span style="color: var(--text-dim); font-size: 10px; margin: 0 8px;">or</span>
            <input type="number" id="ownershipMin" placeholder="Min %" step="1" min="0" max="100" style="width: 60px;">
            <span style="color: var(--text-dim); margin: 0 4px;">-</span>
            <input type="number" id="ownershipMax" placeholder="Max %" step="1" min="0" max="100" style="width: 60px;">
            <button class="filter-apply-btn" onclick="applyCustomOwnershipFilter()">Apply</button>
            <span style="margin-left: 20px;"></span>
            <button class="filter-apply-btn" onclick="clearAdvancedFilters()" style="background: var(--accent-red);">‚úñ Clear All Filters</button>
        </div>
    </div>

    <div class="content">
        <div class="position-section" id="section-RECOMMENDATIONS"></div>
        <div class="position-section" id="section-FORM"></div>
        <div class="position-section" id="section-CHARTS"></div>
        <div class="position-section" id="section-FIXTURES"></div>
        <div class="position-section" id="section-GK"></div>
        <div class="position-section" id="section-DEF"></div>
        <div class="position-section" id="section-MID"></div>
        <div class="position-section" id="section-FWD"></div>
    </div>

    <div class="legend">
        <div class="legend-item">
            <div class="legend-box trend-positive"></div>
            <span>Improving (>10%)</span>
        </div>
        <div class="legend-item">
            <div class="legend-box trend-neutral"></div>
            <span>Stable (-10% to 10%)</span>
        </div>
        <div class="legend-item">
            <div class="legend-box trend-negative"></div>
            <span>Declining (<-10%)</span>
        </div>
        <div class="legend-item" style="margin-left: 30px; border-left: 2px solid var(--border); padding-left: 20px;">
            <span>üìä <strong>Filter Tips:</strong> Use >= (greater/equal), <= (less/equal), > (greater), < (less). Default: >= for numbers</span>
        </div>
        <div class="legend-item" style="margin-left: 30px; border-left: 2px solid var(--border); padding-left: 20px;">
            <span>‚≠ê <strong>Recommendations based on:</strong> Value (pts/¬£m), xGI, minutes consistency, position-specific metrics. "Budget" uses FPL meta thresholds.</span>
        </div>
    </div>

    <!-- Floating Compare Button -->
    <div id="compareBtn" style="display: none; position: fixed; bottom: 30px; right: 30px; background: linear-gradient(135deg, var(--accent-green) 0%, #00aa88 100%); color: var(--bg-dark); padding: 14px 24px; border-radius: 30px; cursor: pointer; font-family: 'Space Mono', monospace; font-weight: 600; font-size: 13px; box-shadow: 0 4px 20px rgba(0, 255, 136, 0.4); z-index: 1000; align-items: center; gap: 10px;" onclick="openComparisonModal()">
        <span>‚öñÔ∏è Compare</span>
        <span id="compareCount" style="background: var(--bg-dark); color: var(--accent-green); padding: 2px 8px; border-radius: 12px; font-size: 11px;">0</span>
        <span onclick="event.stopPropagation(); clearComparisonSelection();" style="margin-left: 8px; padding: 4px 8px; background: rgba(0,0,0,0.2); border-radius: 8px; font-size: 10px;">‚úï Clear</span>
    </div>

    <!-- Comparison Modal -->
    <div id="comparisonModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 2000; justify-content: center; align-items: flex-start; padding: 40px; overflow-y: auto;">
        <div id="comparisonContent" style="background: var(--bg-dark); border: 1px solid var(--border); border-radius: 8px; max-width: 1200px; width: 100%; padding: 25px; max-height: 90vh; overflow-y: auto;">
            <!-- Content will be injected by JavaScript -->
        </div>
    </div>

    <script>
        const CORS_PROXY = 'https://corsproxy.io/?';

        let bootstrapData = null;
        let playerAnalyses = {};
        let teamFixtures = {}; // Store fixtures by team ID
        let teams = {}; // Store team data by ID
        let currentGameweek = null; // Current gameweek (detected from data)
        let currentPhase = 'mid'; // Current season phase: 'early', 'mid', 'late'
        let allAnalyses = []; // Store all player analyses for comparison feature
        
        // ============================================
        // PLAYER COMPARISON MODE
        // ============================================
        let selectedForComparison = []; // Array of player IDs selected for comparison
        const MAX_COMPARISON = 4; // Maximum players to compare
        
        // Toggle player selection for comparison
        function togglePlayerComparison(playerId, checkbox) {
            const player = allAnalyses.find(p => p.id === playerId);
            if (!player) return;
            
            if (checkbox.checked) {
                if (selectedForComparison.length >= MAX_COMPARISON) {
                    checkbox.checked = false;
                    alert(`Maximum ${MAX_COMPARISON} players can be compared at once`);
                    return;
                }
                selectedForComparison.push(playerId);
            } else {
                selectedForComparison = selectedForComparison.filter(id => id !== playerId);
            }
            
            updateCompareButton();
        }
        
        // Update compare button visibility and count
        function updateCompareButton() {
            const btn = document.getElementById('compareBtn');
            const count = document.getElementById('compareCount');
            
            if (selectedForComparison.length >= 2) {
                btn.style.display = 'flex';
                count.textContent = selectedForComparison.length;
            } else {
                btn.style.display = 'none';
            }
        }
        
        // Clear all selections
        function clearComparisonSelection() {
            selectedForComparison = [];
            document.querySelectorAll('.compare-checkbox').forEach(cb => cb.checked = false);
            updateCompareButton();
        }
        
        // Open comparison modal
        function openComparisonModal() {
            if (selectedForComparison.length < 2) return;
            
            const players = selectedForComparison.map(id => allAnalyses.find(p => p.id === id)).filter(Boolean);
            const positionMap = { 1: 'GK', 2: 'DEF', 3: 'MID', 4: 'FWD' };
            
            const modal = document.getElementById('comparisonModal');
            const content = document.getElementById('comparisonContent');
            
            // Build comparison table
            let html = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 style="color: var(--accent-green); font-family: 'Space Mono', monospace;">‚öñÔ∏è Player Comparison</h2>
                    <button onclick="closeComparisonModal()" style="background: var(--accent-red); border: none; color: white; padding: 8px 16px; cursor: pointer; font-family: 'DM Mono', monospace;">‚úï Close</button>
                </div>
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse;">
            `;
            
            // Header row with player names
            html += '<thead><tr style="background: var(--surface-light);">';
            html += '<th style="padding: 12px; text-align: left; color: var(--accent-green); border-bottom: 2px solid var(--accent-green);">Stat</th>';
            players.forEach(p => {
                html += `<th style="padding: 12px; text-align: center; color: var(--text); border-bottom: 2px solid var(--accent-green); min-width: 140px;">
                    <div style="font-size: 14px; font-weight: 600;">${p.name}</div>
                    <div style="font-size: 10px; color: var(--text-dim);">${p.team} ‚Ä¢ ${positionMap[p.position]}</div>
                    <div style="font-size: 12px; color: var(--accent-yellow); margin-top: 4px;">¬£${p.price.toFixed(1)}m</div>
                </th>`;
            });
            html += '</tr></thead><tbody>';
            
            // Define comparison stats
            const comparisonStats = [
                { label: 'üìä Points (Season)', getValue: p => p.season.points, format: v => v.toFixed(0), highlight: 'high' },
                { label: 'üìä Points/Game (L5)', getValue: p => p.l5.points / p.l5.games, format: v => v.toFixed(1), highlight: 'high' },
                { label: '‚ö° xGI/Game (L5)', getValue: p => p.l5.xGI / p.l5.games, format: v => v.toFixed(2), highlight: 'high' },
                { label: '‚öΩ Goals (L5)', getValue: p => p.l5.goals, format: v => v.toFixed(0), highlight: 'high' },
                { label: 'üÖ∞Ô∏è Assists (L5)', getValue: p => p.l5.assists, format: v => v.toFixed(0), highlight: 'high' },
                { label: 'üéØ xG/Game (L5)', getValue: p => p.l5.xG / p.l5.games, format: v => v.toFixed(2), highlight: 'high' },
                { label: 'üéØ xA/Game (L5)', getValue: p => p.l5.xA / p.l5.games, format: v => v.toFixed(2), highlight: 'high' },
                { label: '‚è±Ô∏è Minutes (L5)', getValue: p => p.l5.minutes / p.l5.games, format: v => v.toFixed(0), highlight: 'high' },
                { label: 'üõ°Ô∏è Clean Sheets (L5)', getValue: p => p.l5.cleanSheets, format: v => v.toFixed(0), highlight: 'high' },
                { label: 'üí∞ Value (pts/¬£m)', getValue: p => (p.l5.points / p.l5.games) / p.price, format: v => v.toFixed(2), highlight: 'high' },
                { label: 'üë• Ownership', getValue: p => p.selectedBy || 0, format: v => v.toFixed(1) + '%', highlight: 'none' },
                { label: '‚≠ê Bonus (L5)', getValue: p => p.l5.bonus || 0, format: v => v.toFixed(0), highlight: 'high' },
                { label: 'üìÖ FDR (Next 3)', getValue: p => p.fixtures?.avgFDR3 || 0, format: v => v.toFixed(2), highlight: 'low' },
                { label: 'üìÖ Next Fixtures', getValue: p => p.fixtures?.fixtureString || '-', format: v => v, highlight: 'none' }
            ];
            
            comparisonStats.forEach(stat => {
                html += '<tr>';
                html += `<td style="padding: 10px 12px; border-bottom: 1px solid var(--border); color: var(--text-dim); font-size: 11px;">${stat.label}</td>`;
                
                // Get values and find best
                const values = players.map(p => {
                    try { return stat.getValue(p); } catch { return 0; }
                });
                
                const numericValues = values.filter(v => typeof v === 'number' && !isNaN(v));
                const best = stat.highlight === 'high' ? Math.max(...numericValues) : 
                            stat.highlight === 'low' ? Math.min(...numericValues) : null;
                
                players.forEach((p, i) => {
                    const val = values[i];
                    const formatted = stat.format(val);
                    const isBest = stat.highlight !== 'none' && val === best && numericValues.length > 1;
                    
                    html += `<td style="padding: 10px 12px; border-bottom: 1px solid var(--border); text-align: center; font-size: 12px; font-weight: ${isBest ? '600' : '400'}; color: ${isBest ? 'var(--accent-green)' : 'var(--text)'}; background: ${isBest ? 'rgba(0, 255, 136, 0.1)' : 'transparent'};">
                        ${formatted}
                        ${isBest ? ' ‚úì' : ''}
                    </td>`;
                });
                
                html += '</tr>';
            });
            
            html += '</tbody></table></div>';
            
            // Verdict section
            html += `
                <div style="margin-top: 25px; padding: 20px; background: var(--surface-light); border-left: 4px solid var(--accent-green);">
                    <h3 style="color: var(--accent-green); margin-bottom: 15px; font-size: 14px;">üìù Quick Verdict</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
            `;
            
            players.forEach(p => {
                const l5Pts = p.l5.points / p.l5.games;
                const l5xGI = p.l5.xGI / p.l5.games;
                const value = l5Pts / p.price;
                const fdr = p.fixtures?.avgFDR3 || 3;
                
                let verdict = '';
                let verdictColor = 'var(--text)';
                
                if (l5Pts >= 5 && fdr < 3) {
                    verdict = 'üî• HOT PICK - Form + Fixtures';
                    verdictColor = 'var(--accent-green)';
                } else if (value > 1.0 && l5xGI > 0.3) {
                    verdict = 'üí∞ VALUE PICK - Good underlying';
                    verdictColor = 'var(--accent-green)';
                } else if (l5Pts < 3 && fdr > 3.5) {
                    verdict = '‚ö†Ô∏è AVOID - Poor form + tough fixtures';
                    verdictColor = 'var(--accent-red)';
                } else if (l5xGI > l5Pts * 0.15) {
                    verdict = 'üìà DUE RETURNS - underperforming xGI';
                    verdictColor = 'var(--accent-yellow)';
                } else {
                    verdict = '‚û°Ô∏è HOLD - Monitor form';
                    verdictColor = 'var(--text-dim)';
                }
                
                html += `
                    <div style="background: var(--bg-dark); padding: 12px; border-radius: 4px;">
                        <div style="font-weight: 600; margin-bottom: 6px; color: var(--text);">${p.name}</div>
                        <div style="font-size: 11px; color: ${verdictColor};">${verdict}</div>
                    </div>
                `;
            });
            
            html += '</div></div>';
            
            content.innerHTML = html;
            modal.style.display = 'flex';
        }
        
        // Close comparison modal
        function closeComparisonModal() {
            document.getElementById('comparisonModal').style.display = 'none';
        }

        // ============================================
        // GAMEWEEK & PHASE DETECTION
        // ============================================
        
        // Detect current gameweek from player history data
        function detectCurrentGameweek(analyses) {
            if (!analyses || analyses.length === 0) return 1;
            
            // Find the maximum gameweek from all player season games
            // This assumes season.games roughly equals current gameweek for active players
            let maxGames = 0;
            analyses.forEach(p => {
                if (p.season && p.season.games > maxGames) {
                    maxGames = p.season.games;
                }
            });
            
            // The current gameweek is approximately the max games played + 1
            // (since max games = completed gameweeks for ever-present players)
            return Math.min(maxGames + 1, 38);
        }
        
        // Determine season phase based on gameweek
        function getSeasonPhase(gameweek) {
            const phases = RECOMMENDATION_CONFIG.gameweekPhases;
            
            if (gameweek >= phases.early.start && gameweek <= phases.early.end) {
                return 'early';
            } else if (gameweek >= phases.late.start && gameweek <= phases.late.end) {
                return 'late';
            } else {
                return 'mid';
            }
        }
        
        // Get phase-adjusted weights
        function getPhaseAdjustedWeights() {
            const cfg = RECOMMENDATION_CONFIG;
            const baseWeights = cfg.weights;
            const modifiers = cfg.gameweekPhases.weightModifiers[currentPhase];
            
            return {
                value: baseWeights.value * modifiers.value,
                positionScore: baseWeights.positionScore * modifiers.positionScore,
                minutesConsistency: baseWeights.minutesConsistency * modifiers.minutesConsistency,
                formImprovement: baseWeights.formImprovement * modifiers.formImprovement,
                formDecline: baseWeights.formDecline,
                easyFixtures: baseWeights.easyFixtures * modifiers.easyFixtures,
                favorableFixtures: baseWeights.favorableFixtures * modifiers.favorableFixtures,
                toughFixtures: baseWeights.toughFixtures * modifiers.toughFixtures,
                differentialBonus: modifiers.differentialBonus
            };
        }
        
        // Get phase display info
        function getPhaseInfo() {
            const phaseDetails = {
                early: {
                    name: 'Early Season',
                    emoji: 'üå±',
                    color: 'var(--accent-green)',
                    description: 'Focus on fixtures & nailed starters. Form data is limited.',
                    tips: ['Prioritize easy fixture runs', 'Avoid rotation risks', 'Trust preseason expectations']
                },
                mid: {
                    name: 'Mid Season',
                    emoji: '‚ö°',
                    color: 'var(--accent-blue)',
                    description: 'Balanced approach. Trust form and underlying stats.',
                    tips: ['Follow the form', 'Watch for fixture swings', 'Build for double gameweeks']
                },
                late: {
                    name: 'Late Season',
                    emoji: 'üèÅ',
                    color: 'var(--accent-red)',
                    description: 'Rank push time! Differentials and DGW players are key.',
                    tips: ['Target differentials (<10% owned)', 'Plan for DGW/BGW', 'Take calculated risks']
                }
            };
            return phaseDetails[currentPhase];
        }

        // ============================================
        // RECOMMENDATION CONFIGURATION
        // Tune these values to adjust the algorithm
        // ============================================
        const RECOMMENDATION_CONFIG = {
            // Scoring weights for recommendation algorithm
            weights: {
                value: 30,              // Points per million importance
                positionScore: 1.5,     // Position-specific metrics multiplier
                minutesConsistency: 10, // Nailed-on bonus
                formImprovement: 5,     // xGI improvement bonus
                formDecline: -2,        // xGI decline penalty
                easyFixtures: 15,       // FDR < 2.5 bonus
                favorableFixtures: 8,   // FDR < 3.0 bonus
                toughFixtures: -10      // FDR > 3.5 penalty
            },
            // Thresholds for player eligibility
            thresholds: {
                minL5Games: 4,          // Minimum games in last 5
                minSeasonGames: 8,      // Minimum season games
                minAvgMinutes: 60,      // Minimum average minutes per game
                nailedOnMinutes: 75,    // Minutes threshold for "nailed on"
                minPrice: 3.9,          // Minimum price to consider
                underperformanceXGI: 0.2,  // xGI gap to flag underperformance
                minXGIForUnderperformance: 0.35, // Minimum xGI to consider underperformance (otherwise they're just bad)
                goodValue: 0.9,         // pts/¬£m threshold for "good value"
                excellentValue: 1.2,    // pts/¬£m threshold for "excellent value"
                strongXGI: 0.5,         // xGI/game for attackers
                highMinutesConsistency: 0.95 // % of 90 mins for nailed on
            },
            // Budget thresholds by position (based on FPL meta)
            budgetCaps: {
                GK: 5.0,
                DEF: 5.5,
                MID: 7.0,
                FWD: 7.5
            },
            // FDR thresholds
            fdr: {
                easy: 2.5,      // Below this = easy
                favorable: 3.0, // Below this = favorable
                tough: 3.5      // Above this = tough
            },
            // Form Players scoring
            formSignals: {
                formSurge: { threshold: 50, points: 30 },      // Form improvement %
                formImproving: { threshold: 25, points: 20 },
                hotForm: { threshold: 5, points: 15 },         // L5 avg points
                eliteXGI: { threshold: 0.6, points: 25 },
                strongXGI: { threshold: 0.4, points: 15 },
                goodXGI: { threshold: 0.25, points: 8 },
                nailedOn: { threshold: 85, points: 15 },       // Minutes
                regularStarter: { threshold: 70, points: 10 },
                gettingMinutes: { threshold: 60, points: 5 },
                ultraDifferential: { threshold: 5, points: 10 }, // Ownership %
                lowOwned: { threshold: 10, points: 6 },
                underperforming: { xgiGap: 0.2, minXGI: 0.35, points: 10 },
                greatValue: { threshold: 1.0, points: 10 },
                goodValueForm: { threshold: 0.7, points: 5 },
                easyFixturesForm: { points: 15 },
                goodFixturesForm: { points: 8 },
                toughFixturesForm: { points: -5 },
                minSignal: 45,  // Minimum signal to include player
                highPriority: 70,
                mediumPriority: 55
            },
            // GK-specific clean sheet thresholds
            gkThresholds: {
                excellentCS: 0.6,
                strongCS: 0.4
            },
            // GK scoring weights
            gkScoring: {
                cleanSheet: 15,
                savesPerGame: 0.5,
                penaltySave: 25,      // Huge swing - 5 pts per save
                bonusPerGame: 3,
                assistPerGame: 8,
                xGCPenalty: 2
            },
            // Display settings
            display: {
                maxPlayersPerCategory: 5,
                maxFormPlayers: 20
            },
            // Gameweek phase configuration
            gameweekPhases: {
                // Phase definitions
                early: { start: 1, end: 8 },      // GW1-8: Limited data
                mid: { start: 9, end: 30 },       // GW9-30: Full data available
                late: { start: 31, end: 38 },     // GW31-38: Rank push time
                
                // Weight multipliers by phase (1.0 = normal, >1 = more important, <1 = less important)
                weightModifiers: {
                    early: {
                        // Early season: fixtures and nailed starters are king, form data is unreliable
                        value: 0.8,              // Less reliable early
                        positionScore: 0.7,      // Less reliable early
                        minutesConsistency: 1.5, // Very important - want nailed players
                        formImprovement: 0.5,    // Unreliable with small sample
                        easyFixtures: 1.5,       // Fixtures are crucial early
                        favorableFixtures: 1.3,
                        toughFixtures: 1.3,      // Avoid tough fixtures more
                        differentialBonus: 0     // Don't chase differentials early
                    },
                    mid: {
                        // Mid season: balanced approach, trust the data
                        value: 1.0,
                        positionScore: 1.0,
                        minutesConsistency: 1.0,
                        formImprovement: 1.0,
                        easyFixtures: 1.0,
                        favorableFixtures: 1.0,
                        toughFixtures: 1.0,
                        differentialBonus: 0
                    },
                    late: {
                        // Late season: differentials for rank climbing, DGW targets
                        value: 0.9,
                        positionScore: 1.1,      // Trust underlying stats
                        minutesConsistency: 1.2, // Still want starters
                        formImprovement: 1.2,    // Hot form matters for final push
                        easyFixtures: 1.3,       // DGW teams often have good fixtures
                        favorableFixtures: 1.2,
                        toughFixtures: 0.8,      // Can take more risks
                        differentialBonus: 15    // Big bonus for low ownership
                    }
                },
                // Ownership thresholds for differential bonus in late season
                differentialThreshold: 10  // Below this % = differential
            }
        };

        // Toggle guide section
        function toggleGuide() {
            const content = document.getElementById('guideContent');
            const toggle = document.getElementById('guideToggle');
            
            content.classList.toggle('open');
            toggle.classList.toggle('open');
        }
        
        // Clear cache function
        function clearCache() {
            localStorage.removeItem('fpl_players_cache');
            localStorage.removeItem('fpl_players_cache_time');
            updateStatus('Cache cleared! Click "Force Refresh" to reload data.', 'info');
            showCacheInfo();
            console.log('Cache cleared');
        }
        
        // Show cache info
        function showCacheInfo() {
            const cacheInfo = document.getElementById('cacheInfo');
            const cacheTime = localStorage.getItem('fpl_players_cache_time');
            
            if (cacheTime) {
                const ageHours = (Date.now() - parseInt(cacheTime)) / (1000 * 60 * 60);
                const date = new Date(parseInt(cacheTime));
                if (ageHours < 24) {
                    cacheInfo.textContent = `üì¶ Cached: ${date.toLocaleString()} (${ageHours.toFixed(1)}h ago)`;
                    cacheInfo.style.color = 'var(--accent-green)';
                } else {
                    cacheInfo.textContent = `‚ö†Ô∏è Cache expired (${ageHours.toFixed(1)}h ago)`;
                    cacheInfo.style.color = 'var(--accent-yellow)';
                }
            } else {
                cacheInfo.textContent = 'üíæ No cache - will fetch fresh data';
                cacheInfo.style.color = 'var(--text-dim)';
            }
        }

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.position-section').forEach(s => s.classList.remove('active'));
                
                tab.classList.add('active');
                const position = tab.dataset.position;
                document.getElementById(`section-${position}`).classList.add('active');
            });
        });

        // Set Recommendations as default active tab
        document.addEventListener('DOMContentLoaded', () => {
            const firstTab = document.querySelector('.tab[data-position="RECOMMENDATIONS"]');
            if (firstTab) {
                firstTab.classList.add('active');
                document.getElementById('section-RECOMMENDATIONS').classList.add('active');
            }
        });

        function showLoading(show) {
            const overlay = document.getElementById('loadingOverlay');
            if (show) {
                overlay.classList.add('show');
            } else {
                overlay.classList.remove('show');
            }
        }

        function updateStatus(message, type = 'info') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = 'status ' + type;
        }

        async function fetchBootstrapData() {
            const response = await fetch(CORS_PROXY + encodeURIComponent('https://fantasy.premierleague.com/api/bootstrap-static/'));
            if (!response.ok) throw new Error('Failed to fetch bootstrap data');
            return await response.json();
        }

        async function fetchPlayerDetails(elementId) {
            const response = await fetch(CORS_PROXY + encodeURIComponent(`https://fantasy.premierleague.com/api/element-summary/${elementId}/`));
            if (!response.ok) throw new Error(`Failed to fetch player ${elementId}`);
            return await response.json();
        }

        async function loadFixtures() {
            try {
                console.log('üìÖ Loading fixtures...');
                const fixturesUrl = 'https://fantasy.premierleague.com/api/fixtures/';
                const response = await fetch(CORS_PROXY + encodeURIComponent(fixturesUrl));
                
                if (!response.ok) {
                    throw new Error('Failed to fetch fixtures');
                }
                
                const fixtures = await response.json();
                console.log(`‚úÖ Loaded ${fixtures.length} total fixtures`);
                
                // Filter for upcoming fixtures only (not finished)
                const upcomingFixtures = fixtures.filter(f => !f.finished);
                console.log(`üìä ${upcomingFixtures.length} upcoming fixtures`);
                
                // Group fixtures by team
                teamFixtures = {};
                
                upcomingFixtures.forEach(fixture => {
                    // Home team fixtures
                    if (!teamFixtures[fixture.team_h]) {
                        teamFixtures[fixture.team_h] = [];
                    }
                    teamFixtures[fixture.team_h].push({
                        opponent: fixture.team_a,
                        is_home: true,
                        difficulty: fixture.team_h_difficulty,
                        event: fixture.event,
                        kickoff_time: fixture.kickoff_time
                    });
                    
                    // Away team fixtures
                    if (!teamFixtures[fixture.team_a]) {
                        teamFixtures[fixture.team_a] = [];
                    }
                    teamFixtures[fixture.team_a].push({
                        opponent: fixture.team_h,
                        is_home: false,
                        difficulty: fixture.team_a_difficulty,
                        event: fixture.event,
                        kickoff_time: fixture.kickoff_time
                    });
                });
                
                // Sort each team's fixtures by event (gameweek)
                Object.keys(teamFixtures).forEach(teamId => {
                    teamFixtures[teamId].sort((a, b) => (a.event || 999) - (b.event || 999));
                });
                
                console.log('‚úÖ Fixtures organized by team:', Object.keys(teamFixtures).length, 'teams');
                
            } catch (error) {
                console.error('‚ùå Error loading fixtures:', error);
                throw error;
            }
        }

        function calculateStats(history, last5 = false) {
            const games = last5 ? history.slice(-5) : history;
            const numGames = games.length;
            
            if (numGames === 0) return null;

            const sum = (arr, key) => arr.reduce((acc, g) => acc + (parseFloat(g[key]) || 0), 0);
            
            return {
                games: numGames,  // This is the count of games, not a sum
                minutes: sum(games, 'minutes'),
                points: sum(games, 'total_points'),
                goals: sum(games, 'goals_scored'),
                assists: sum(games, 'assists'),
                cleanSheets: sum(games, 'clean_sheets'),
                goalsConceded: sum(games, 'goals_conceded'),
                ownGoals: sum(games, 'own_goals'),
                penaltiesSaved: sum(games, 'penalties_saved'),
                penaltiesMissed: sum(games, 'penalties_missed'),
                yellowCards: sum(games, 'yellow_cards'),
                redCards: sum(games, 'red_cards'),
                saves: sum(games, 'saves'),
                bonus: sum(games, 'bonus'),
                bps: sum(games, 'bps'),
                xG: sum(games, 'expected_goals'),
                xA: sum(games, 'expected_assists'),
                xGI: sum(games, 'expected_goal_involvements'),
                xGC: sum(games, 'expected_goals_conceded'),
                ict: sum(games, 'ict_index'),
                influence: sum(games, 'influence'),
                creativity: sum(games, 'creativity'),
                threat: sum(games, 'threat'),
                bigChancesCreated: sum(games, 'big_chances_created'),
                bigChancesMissed: sum(games, 'big_chances_missed'),
                keyPasses: sum(games, 'key_passes')
            };
        }

        function calculateTrend(seasonVal, l5Val, seasonGames, l5Games) {
            if (seasonGames === 0 || l5Games === 0) return 0;
            const seasonAvg = seasonVal / seasonGames;
            const l5Avg = l5Val / l5Games;
            if (seasonAvg === 0) return 0;
            return ((l5Avg - seasonAvg) / seasonAvg) * 100;
        }

        function getTrendClass(trend, reverse = false) {
            const threshold = 10;
            if (reverse) {
                if (trend < -threshold) return 'trend-positive';
                if (trend > threshold) return 'trend-negative';
            } else {
                if (trend > threshold) return 'trend-positive';
                if (trend < -threshold) return 'trend-negative';
            }
            return 'trend-neutral';
        }

        async function analyzePlayer(elementId, playerName, position, team, teamId) {
            try {
                // Make the actual API call to get player's detailed history
                const data = await fetchPlayerDetails(elementId);
                const history = data.history || [];
                
                // Skip players with no game history
                if (history.length === 0) {
                    console.log(`Skipping ${playerName} - no history`);
                    return null;
                }

                const seasonStats = calculateStats(history);
                const l5Stats = calculateStats(history, true);

                // Verify we got valid stats
                if (!seasonStats || !l5Stats) {
                    console.log(`Skipping ${playerName} - invalid stats`);
                    return null;
                }

                // Calculate fixture difficulty
                let fixtureData = null;
                const playerFixtures = teamFixtures[teamId] || [];
                
                if (playerFixtures.length > 0) {
                    const next3 = playerFixtures.slice(0, 3);
                    const next5 = playerFixtures.slice(0, 5);
                    
                    const avgFDR3 = next3.reduce((sum, f) => sum + f.difficulty, 0) / next3.length;
                    const avgFDR5 = next5.reduce((sum, f) => sum + f.difficulty, 0) / next5.length;
                    
                    // Build fixture string with opponent names
                    const fixtureString = next3.map(f => {
                        const opponentTeam = teams[f.opponent];
                        const opponentName = opponentTeam ? opponentTeam.short_name : 'UNK';
                        return `${opponentName}(${f.is_home ? 'H' : 'A'})`;
                    }).join(', ');
                    
                    fixtureData = {
                        avgFDR3: avgFDR3,
                        avgFDR5: avgFDR5,
                        next3: next3,
                        next5: next5,
                        fixtureString: fixtureString
                    };
                }

                return {
                    name: playerName,
                    team: team,
                    teamId: teamId,
                    position: position,
                    season: seasonStats,
                    l5: l5Stats,
                    fixtures: fixtureData
                };
            } catch (error) {
                console.error(`Error analyzing ${playerName}:`, error);
                return null;
            }
        }

        function createTable(position, analyses) {
            const positionMap = { 1: 'GK', 2: 'DEF', 3: 'MID', 4: 'FWD' };
            const filteredAnalyses = analyses.filter(a => a && positionMap[a.position] === position);

            if (filteredAnalyses.length === 0) {
                return '<div class="no-data">No data available for this position</div>';
            }

            // Metric descriptions for tooltips
            const tooltips = {
                'GP': 'Games Played - Number of matches the player has appeared in',
                'Mins': 'Minutes - Total minutes played',
                'Pts': 'Points - Total FPL points scored',
                'CS': 'Clean Sheets - Games where the team did not concede a goal',
                'Saves': 'Saves - Total saves made by goalkeeper',
                'GC': 'Goals Conceded - Goals conceded while on the pitch',
                'xGC': 'Expected Goals Conceded - Statistical measure of goals likely to be conceded based on shot quality',
                'Pen S': 'Penalties Saved - Number of penalty kicks saved',
                'G': 'Goals - Goals scored by the player',
                'A': 'Assists - Assists provided by the player',
                'xG': 'Expected Goals - Statistical measure of goals a player should score based on shot quality',
                'xA': 'Expected Assists - Statistical measure of assists a player should have based on chances created',
                'xGI': 'Expected Goal Involvements - Combined xG and xA',
                'BCC': 'Big Chances Created - Clear goal-scoring opportunities created',
                'BCM': 'Big Chances Missed - Clear goal-scoring opportunities missed',
                'KP': 'Key Passes - Passes that lead to a shot on goal',
                'Bonus': 'Bonus Points - Extra FPL points awarded to top performers',
                'BPS': 'Bonus Points System - Score determining bonus point allocation',
                'ICT': 'ICT Index - Combined measure of Influence, Creativity, and Threat',
                'Infl': 'Influence - Impact on match outcome',
                'Creat': 'Creativity - Ability to create scoring chances',
                'Threat': 'Threat - Likelihood to score goals',
                'Player': 'Player Name',
                'Team': 'Team',
                'Œî%': 'Trend Percentage - Percentage change between season average and last 5 games average',
                'FDR': 'Fixture Difficulty Rating - Average difficulty of next 3 fixtures (1=Easy, 5=Hard)',
                'Next 3': 'Next 3 Fixtures - Upcoming opponents with home/away indicator',
                'Price': 'Current Price in ¬£m',
                'Own%': 'Ownership Percentage - How many managers own this player'
            };

            let columns = [];
            
            if (position === 'GK') {
                columns = [
                    { key: 'name', label: 'Player', seasonal: false },
                    { key: 'team', label: 'Team', seasonal: false },
                    { key: 'price', label: 'Price', seasonal: false },
                    { key: 'ownership', label: 'Own%', seasonal: false },
                    { key: 'games', label: 'GP', seasonal: true },
                    { key: 'minutes', label: 'Mins', seasonal: true },
                    { key: 'points', label: 'Pts', seasonal: true },
                    { key: 'cleanSheets', label: 'CS', seasonal: true },
                    { key: 'saves', label: 'Saves', seasonal: true },
                    { key: 'goalsConceded', label: 'GC', seasonal: true },
                    { key: 'xGC', label: 'xGC', seasonal: true },
                    { key: 'penaltiesSaved', label: 'Pen S', seasonal: true },
                    { key: 'bonus', label: 'Bonus', seasonal: true },
                    { key: 'bps', label: 'BPS', seasonal: true },
                    { key: 'fdr', label: 'FDR', seasonal: false },
                    { key: 'fixtures', label: 'Next 3', seasonal: false }
                ];
            } else if (position === 'DEF') {
                columns = [
                    { key: 'name', label: 'Player', seasonal: false },
                    { key: 'team', label: 'Team', seasonal: false },
                    { key: 'price', label: 'Price', seasonal: false },
                    { key: 'ownership', label: 'Own%', seasonal: false },
                    { key: 'games', label: 'GP', seasonal: true },
                    { key: 'minutes', label: 'Mins', seasonal: true },
                    { key: 'points', label: 'Pts', seasonal: true },
                    { key: 'cleanSheets', label: 'CS', seasonal: true },
                    { key: 'goalsConceded', label: 'GC', seasonal: true },
                    { key: 'xGC', label: 'xGC', seasonal: true },
                    { key: 'goals', label: 'G', seasonal: true },
                    { key: 'assists', label: 'A', seasonal: true },
                    { key: 'xG', label: 'xG', seasonal: true },
                    { key: 'xA', label: 'xA', seasonal: true },
                    { key: 'bigChancesCreated', label: 'BCC', seasonal: true },
                    { key: 'keyPasses', label: 'KP', seasonal: true },
                    { key: 'bonus', label: 'Bonus', seasonal: true },
                    { key: 'bps', label: 'BPS', seasonal: true },
                    { key: 'ict', label: 'ICT', seasonal: true },
                    { key: 'fdr', label: 'FDR', seasonal: false },
                    { key: 'fixtures', label: 'Next 3', seasonal: false }
                ];
            } else if (position === 'MID') {
                columns = [
                    { key: 'name', label: 'Player', seasonal: false },
                    { key: 'team', label: 'Team', seasonal: false },
                    { key: 'price', label: 'Price', seasonal: false },
                    { key: 'ownership', label: 'Own%', seasonal: false },
                    { key: 'games', label: 'GP', seasonal: true },
                    { key: 'minutes', label: 'Mins', seasonal: true },
                    { key: 'points', label: 'Pts', seasonal: true },
                    { key: 'goals', label: 'G', seasonal: true },
                    { key: 'assists', label: 'A', seasonal: true },
                    { key: 'xG', label: 'xG', seasonal: true },
                    { key: 'xA', label: 'xA', seasonal: true },
                    { key: 'xGI', label: 'xGI', seasonal: true },
                    { key: 'bigChancesCreated', label: 'BCC', seasonal: true },
                    { key: 'bigChancesMissed', label: 'BCM', seasonal: true },
                    { key: 'keyPasses', label: 'KP', seasonal: true },
                    { key: 'cleanSheets', label: 'CS', seasonal: true },
                    { key: 'bonus', label: 'Bonus', seasonal: true },
                    { key: 'bps', label: 'BPS', seasonal: true },
                    { key: 'ict', label: 'ICT', seasonal: true },
                    { key: 'influence', label: 'Infl', seasonal: true },
                    { key: 'creativity', label: 'Creat', seasonal: true },
                    { key: 'threat', label: 'Threat', seasonal: true },
                    { key: 'fdr', label: 'FDR', seasonal: false },
                    { key: 'fixtures', label: 'Next 3', seasonal: false }
                ];
            } else if (position === 'FWD') {
                columns = [
                    { key: 'name', label: 'Player', seasonal: false },
                    { key: 'team', label: 'Team', seasonal: false },
                    { key: 'price', label: 'Price', seasonal: false },
                    { key: 'ownership', label: 'Own%', seasonal: false },
                    { key: 'games', label: 'GP', seasonal: true },
                    { key: 'minutes', label: 'Mins', seasonal: true },
                    { key: 'points', label: 'Pts', seasonal: true },
                    { key: 'goals', label: 'G', seasonal: true },
                    { key: 'assists', label: 'A', seasonal: true },
                    { key: 'xG', label: 'xG', seasonal: true },
                    { key: 'xA', label: 'xA', seasonal: true },
                    { key: 'xGI', label: 'xGI', seasonal: true },
                    { key: 'bigChancesCreated', label: 'BCC', seasonal: true },
                    { key: 'bigChancesMissed', label: 'BCM', seasonal: true },
                    { key: 'keyPasses', label: 'KP', seasonal: true },
                    { key: 'bonus', label: 'Bonus', seasonal: true },
                    { key: 'bps', label: 'BPS', seasonal: true },
                    { key: 'ict', label: 'ICT', seasonal: true },
                    { key: 'influence', label: 'Infl', seasonal: true },
                    { key: 'creativity', label: 'Creat', seasonal: true },
                    { key: 'threat', label: 'Threat', seasonal: true },
                    { key: 'fdr', label: 'FDR', seasonal: false },
                    { key: 'fixtures', label: 'Next 3', seasonal: false }
                ];
            }

            const tableId = `table-${position}`;
            let html = `<div class="table-container"><table id="${tableId}"><thead>`;
            
            // Header row with sortable columns and tooltips
            html += '<tr>';
            // Add compare checkbox column
            html += '<th style="width: 40px; text-align: center;" title="Select players to compare">‚öñÔ∏è</th>';
            let colIndex = 1; // Start at 1 because of compare column
            columns.forEach(col => {
                const tooltip = tooltips[col.label] || '';
                if (!col.seasonal) {
                    html += `<th onclick="sortTable('${tableId}', ${colIndex}, '${col.key}')" title="${tooltip}">${col.label}<span class="sort-icon">‚áÖ</span></th>`;
                    colIndex++;
                } else {
                    html += `<th onclick="sortTable('${tableId}', ${colIndex}, '${col.key}-season')" title="${tooltip} (Season Average)">${col.label} (S)<span class="sort-icon">‚áÖ</span></th>`;
                    colIndex++;
                    html += `<th onclick="sortTable('${tableId}', ${colIndex}, '${col.key}-l5')" title="${tooltip} (Last 5 Games Average)">${col.label} (L5)<span class="sort-icon">‚áÖ</span></th>`;
                    colIndex++;
                    html += `<th onclick="sortTable('${tableId}', ${colIndex}, '${col.key}-trend')" title="${tooltips['Œî%']}">Œî%<span class="sort-icon">‚áÖ</span></th>`;
                    colIndex++;
                }
            });
            html += '</tr>';

            // Filter row
            html += '<tr class="filter-row">';
            // Empty cell for compare column
            html += '<th></th>';
            colIndex = 1;
            columns.forEach(col => {
                if (!col.seasonal) {
                    const placeholder = (col.key === 'name' || col.key === 'team') ? 'Filter...' : 
                                      (col.key === 'price') ? '¬£' :
                                      (col.key === 'ownership') ? '%' : '>=';
                    html += `<th><input type="text" class="filter-input" placeholder="${placeholder}" onkeyup="filterTable('${tableId}', ${colIndex})"></th>`;
                    colIndex++;
                } else {
                    html += `<th><input type="text" class="filter-input" placeholder=">=" onkeyup="filterTable('${tableId}', ${colIndex})"></th>`;
                    colIndex++;
                    html += `<th><input type="text" class="filter-input" placeholder=">=" onkeyup="filterTable('${tableId}', ${colIndex})"></th>`;
                    colIndex++;
                    html += `<th><input type="text" class="filter-input" placeholder=">=" onkeyup="filterTable('${tableId}', ${colIndex})"></th>`;
                    colIndex++;
                }
            });
            html += '</tr>';
            
            html += '</thead><tbody>';

            filteredAnalyses.forEach(analysis => {
                const isSelected = selectedForComparison.includes(analysis.id);
                html += '<tr>';
                
                // Compare checkbox column
                html += `<td style="text-align: center;">
                    <input type="checkbox" class="compare-checkbox" 
                        ${isSelected ? 'checked' : ''} 
                        onchange="togglePlayerComparison(${analysis.id}, this)"
                        style="cursor: pointer; width: 16px; height: 16px; accent-color: var(--accent-green);">
                </td>`;
                
                columns.forEach(col => {
                    if (col.key === 'name') {
                        html += `<td data-value="${analysis.name}">${analysis.name}</td>`;
                    } else if (col.key === 'team') {
                        html += `<td data-value="${analysis.team}"><span class="team-badge">${analysis.team}</span></td>`;
                    } else if (col.key === 'price') {
                        // Price column
                        const price = analysis.price || 0;
                        html += `<td data-value="${price.toFixed(1)}">¬£${price.toFixed(1)}</td>`;
                    } else if (col.key === 'ownership') {
                        // Ownership column
                        const ownership = analysis.selectedBy || analysis.selectedByPercent || 0;
                        html += `<td data-value="${ownership.toFixed(1)}">${ownership.toFixed(1)}%</td>`;
                    } else if (col.key === 'fdr') {
                        // FDR column with visual indicators
                        if (analysis.fixtures && analysis.fixtures.avgFDR3) {
                            const fdr = analysis.fixtures.avgFDR3;
                            let fdrColor = '#f59e0b'; // default yellow
                            let fdrIcon = 'üü°';
                            
                            if (fdr < 2.6) {
                                fdrColor = '#10b981';
                                fdrIcon = 'üü¢üü¢';
                            } else if (fdr < 2.9) {
                                fdrColor = '#22c55e';
                                fdrIcon = 'üü¢';
                            } else if (fdr < 3.1) {
                                fdrColor = '#f59e0b';
                                fdrIcon = 'üü°';
                            } else if (fdr < 3.4) {
                                fdrColor = '#fb923c';
                                fdrIcon = 'üü†';
                            } else {
                                fdrColor = '#ef4444';
                                fdrIcon = 'üî¥';
                            }
                            
                            html += `<td data-value="${fdr.toFixed(2)}" style="font-weight: 700; color: ${fdrColor};">${fdrIcon} ${fdr.toFixed(1)}</td>`;
                        } else {
                            html += `<td data-value="999">-</td>`;
                        }
                    } else if (col.key === 'fixtures') {
                        // Next 3 fixtures text
                        if (analysis.fixtures && analysis.fixtures.fixtureString) {
                            html += `<td data-value="${analysis.fixtures.fixtureString}" style="font-size: 9px; white-space: nowrap;">${analysis.fixtures.fixtureString}</td>`;
                        } else {
                            html += `<td data-value="zzz">-</td>`;
                        }
                    } else if (col.seasonal) {
                        const seasonVal = analysis.season[col.key];
                        const l5Val = analysis.l5[col.key];
                        const trend = calculateTrend(seasonVal, l5Val, analysis.season.games, analysis.l5.games);
                        
                        // For 'games', show the count directly, not an average
                        if (col.key === 'games') {
                            html += `<td data-value="${seasonVal}">${seasonVal}</td>`;
                            html += `<td data-value="${l5Val}">${l5Val}</td>`;
                            html += `<td class="trend-neutral" data-value="0">-</td>`;
                        } else {
                            const seasonAvg = seasonVal / analysis.season.games;
                            const l5Avg = l5Val / analysis.l5.games;
                            
                            const reverse = ['goalsConceded', 'xGC', 'ownGoals', 'penaltiesMissed', 'yellowCards', 'redCards', 'bigChancesMissed'].includes(col.key);
                            const trendClass = getTrendClass(trend, reverse);
                            
                            html += `<td data-value="${seasonAvg.toFixed(1)}">${seasonAvg.toFixed(1)}</td>`;
                            html += `<td data-value="${l5Avg.toFixed(1)}">${l5Avg.toFixed(1)}</td>`;
                            html += `<td class="${trendClass}" data-value="${trend.toFixed(0)}">${trend > 0 ? '+' : ''}${trend.toFixed(0)}%</td>`;
                        }
                    }
                });
                
                html += '</tr>';
            });

            html += '</tbody></table></div>';
            return html;
        }

        function sortTable(tableId, columnIndex, columnKey) {
            const table = document.getElementById(tableId);
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            // Determine sort direction
            const currentSort = table.dataset.sortColumn;
            const currentDir = table.dataset.sortDirection || 'asc';
            const newDir = (currentSort === columnIndex.toString() && currentDir === 'asc') ? 'desc' : 'asc';
            
            // Update sort indicators
            table.querySelectorAll('.sort-icon').forEach(icon => {
                icon.classList.remove('active');
                icon.textContent = '‚áÖ';
            });
            
            const header = table.querySelectorAll('thead tr:first-child th')[columnIndex];
            const sortIcon = header.querySelector('.sort-icon');
            sortIcon.classList.add('active');
            sortIcon.textContent = newDir === 'asc' ? '‚Üë' : '‚Üì';
            
            // Sort rows
            rows.sort((a, b) => {
                const aCell = a.cells[columnIndex];
                const bCell = b.cells[columnIndex];
                
                const aValue = aCell.dataset.value || aCell.textContent;
                const bValue = bCell.dataset.value || bCell.textContent;
                
                // Try to parse as number
                const aNum = parseFloat(aValue);
                const bNum = parseFloat(bValue);
                
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return newDir === 'asc' ? aNum - bNum : bNum - aNum;
                }
                
                // String comparison
                return newDir === 'asc' 
                    ? aValue.localeCompare(bValue)
                    : bValue.localeCompare(aValue);
            });
            
            // Re-append sorted rows
            rows.forEach(row => tbody.appendChild(row));
            
            // Store sort state
            table.dataset.sortColumn = columnIndex;
            table.dataset.sortDirection = newDir;
        }

        function filterTable(tableId, columnIndex) {
            const table = document.getElementById(tableId);
            const filterInputs = table.querySelectorAll('.filter-row input');
            const tbody = table.querySelector('tbody');
            const rows = tbody.querySelectorAll('tr');
            
            rows.forEach(row => {
                let showRow = true;
                
                filterInputs.forEach((input, idx) => {
                    const filterValue = input.value.trim();
                    if (filterValue) {
                        const cell = row.cells[idx];
                        const cellValue = cell.dataset.value || cell.textContent;
                        const cellText = cellValue.toLowerCase();
                        const filterText = filterValue.toLowerCase();
                        
                        // Try to parse as number for numeric comparisons
                        const cellNum = parseFloat(cellValue);
                        const isNumeric = !isNaN(cellNum);
                        
                        let matches = false;
                        
                        // Check for comparison operators
                        if (isNumeric) {
                            if (filterText.startsWith('>=')) {
                                const threshold = parseFloat(filterText.substring(2));
                                matches = !isNaN(threshold) && cellNum >= threshold;
                            } else if (filterText.startsWith('<=')) {
                                const threshold = parseFloat(filterText.substring(2));
                                matches = !isNaN(threshold) && cellNum <= threshold;
                            } else if (filterText.startsWith('>')) {
                                const threshold = parseFloat(filterText.substring(1));
                                matches = !isNaN(threshold) && cellNum > threshold;
                            } else if (filterText.startsWith('<')) {
                                const threshold = parseFloat(filterText.substring(1));
                                matches = !isNaN(threshold) && cellNum < threshold;
                            } else {
                                // If just a number is entered, treat it as >= for numeric columns
                                const threshold = parseFloat(filterText);
                                if (!isNaN(threshold)) {
                                    matches = cellNum >= threshold;
                                } else {
                                    // Text search fallback
                                    matches = cellText.includes(filterText);
                                }
                            }
                        } else {
                            // Text search for non-numeric columns
                            matches = cellText.includes(filterText);
                        }
                        
                        if (!matches) {
                            showRow = false;
                        }
                    }
                });
                
                row.style.display = showRow ? '' : 'none';
            });
        }

        async function loadData(forceRefresh = false) {
            try {
                showLoading(true);
                
                // PRIORITY 1: Try to load from static file (GitHub Actions generated)
                if (!forceRefresh) {
                    try {
                        updateStatus('Loading from pre-generated data file...', 'loading');
                        const response = await fetch('/data/players-data.json');
                        
                        if (response.ok) {
                            console.log('Loading from static file (GitHub Actions)');
                            const staticData = await response.json();
                            
                            // Process the pre-fetched data
                            bootstrapData = {
                                teams: staticData.teams,
                                element_types: staticData.elementTypes,
                                elements: staticData.players.map(p => ({
                                    id: p.id,
                                    web_name: p.name,
                                    element_type: p.position,
                                    team: p.team,
                                    now_cost: p.price,
                                    form: p.form,
                                    selected_by_percent: p.ownership,
                                    total_points: p.totalPoints,
                                    minutes: p.minutes
                                }))
                            };
                            
                            // Build teams object
                            teams = {};
                            staticData.teams.forEach(team => {
                                teams[team.id] = {
                                    id: team.id,
                                    name: team.name,
                                    short_name: team.short_name,
                                    strength: team.strength
                                };
                            });
                            
                            // Load fixtures
                            updateStatus('Loading fixtures...', 'loading');
                            await loadFixtures();
                            console.log('‚úÖ Fixtures loaded');
                            
                            // Process player analyses from pre-fetched history
                            const analyses = [];
                            for (const player of staticData.players) {
                                if (player.history && player.history.length > 0) {
                                    const season = calculateStats(player.history, false);
                                    const l5 = calculateStats(player.history, true);
                                    
                                    if (season && l5) {
                                        // Calculate fixture difficulty
                                        let fixtureData = null;
                                        const playerFixtures = teamFixtures[player.team] || [];
                                        
                                        if (playerFixtures.length > 0) {
                                            const next3 = playerFixtures.slice(0, 3);
                                            const next5 = playerFixtures.slice(0, 5);
                                            
                                            const avgFDR3 = next3.reduce((sum, f) => sum + f.difficulty, 0) / next3.length;
                                            const avgFDR5 = next5.reduce((sum, f) => sum + f.difficulty, 0) / next5.length;
                                            
                                            const fixtureString = next3.map(f => {
                                                const opponentTeam = teams[f.opponent];
                                                const opponentName = opponentTeam ? opponentTeam.short_name : 'UNK';
                                                return `${opponentName}(${f.is_home ? 'H' : 'A'})`;
                                            }).join(', ');
                                            
                                            fixtureData = {
                                                avgFDR3: avgFDR3,
                                                avgFDR5: avgFDR5,
                                                next3: next3,
                                                next5: next5,
                                                fixtureString: fixtureString
                                            };
                                        }
                                        
                                        analyses.push({
                                            id: player.id,
                                            name: player.name,
                                            fullName: player.fullName || player.name,
                                            position: player.position,
                                            team: teams[player.team].short_name,
                                            teamId: player.team,
                                            price: player.price / 10,
                                            form: parseFloat(player.form),
                                            selectedBy: parseFloat(player.ownership),
                                            totalPoints: player.totalPoints,
                                            season,
                                            l5,
                                            fixtures: fixtureData
                                        });
                                    }
                                }
                            }
                            
                            console.log(`Loaded ${analyses.length} players from static file`);
                            
                            // Store analyses globally for comparison feature
                            allAnalyses = analyses;
                            
                            // Detect current gameweek and phase
                            currentGameweek = detectCurrentGameweek(analyses);
                            currentPhase = getSeasonPhase(currentGameweek);
                            console.log(`üìÖ Detected GW${currentGameweek} (${currentPhase} season phase)`);
                            
                            // Render everything
                            document.getElementById('section-RECOMMENDATIONS').innerHTML = generateRecommendations(analyses);
                            document.getElementById('section-FORM').innerHTML = generateFormPlayers(analyses);
                            document.getElementById('section-CHARTS').innerHTML = generateCharts(analyses);
                            document.getElementById('section-FIXTURES').innerHTML = generateFixtureTicker(analyses);
                            document.getElementById('section-GK').innerHTML = createTable('GK', analyses);
                            document.getElementById('section-DEF').innerHTML = createTable('DEF', analyses);
                            document.getElementById('section-MID').innerHTML = createTable('MID', analyses);
                            document.getElementById('section-FWD').innerHTML = createTable('FWD', analyses);
                            
                            const lastUpdated = new Date(staticData.metadata.lastUpdated).toLocaleString();
                            updateStatus(`‚úì Loaded ${analyses.length} players from static file (updated: ${lastUpdated})`, 'success');
                            showLoading(false);
                            showCacheInfo();
                            return;
                        }
                    } catch (error) {
                        console.log('Static file not available, trying cache:', error.message);
                    }
                }
                
                // PRIORITY 2: Check localStorage cache (if static file unavailable)
                if (!forceRefresh) {
                    const cached = localStorage.getItem('fpl_players_cache');
                    const cacheTime = localStorage.getItem('fpl_players_cache_time');
                    
                    if (cached && cacheTime) {
                        const ageHours = (Date.now() - parseInt(cacheTime)) / (1000 * 60 * 60);
                        
                        if (ageHours < 24) {
                            console.log(`Using cached data (${ageHours.toFixed(1)} hours old)`);
                            updateStatus('Loading from cache...', 'loading');
                            
                            try {
                                const cachedData = JSON.parse(cached);
                                bootstrapData = cachedData.bootstrapData;
                                
                                // Build teams object from cached bootstrap data
                                teams = {};
                                bootstrapData.teams.forEach(team => {
                                    teams[team.id] = {
                                        id: team.id,
                                        name: team.name,
                                        short_name: team.short_name,
                                        strength: team.strength
                                    };
                                });
                                
                                // Load fresh fixtures (they change frequently)
                                updateStatus('Loading fixtures...', 'loading');
                                await loadFixtures();
                                console.log('‚úÖ Fixtures loaded');
                                
                                // Get analyses from cache and add fixture data
                                const analyses = cachedData.analyses.map(player => {
                                    // Calculate fixture difficulty for cached players
                                    let fixtureData = null;
                                    const playerFixtures = teamFixtures[player.teamId] || [];
                                    
                                    if (playerFixtures.length > 0) {
                                        const next3 = playerFixtures.slice(0, 3);
                                        const next5 = playerFixtures.slice(0, 5);
                                        
                                        const avgFDR3 = next3.reduce((sum, f) => sum + f.difficulty, 0) / next3.length;
                                        const avgFDR5 = next5.reduce((sum, f) => sum + f.difficulty, 0) / next5.length;
                                        
                                        const fixtureString = next3.map(f => {
                                            const opponentTeam = teams[f.opponent];
                                            const opponentName = opponentTeam ? opponentTeam.short_name : 'UNK';
                                            return `${opponentName}(${f.is_home ? 'H' : 'A'})`;
                                        }).join(', ');
                                        
                                        fixtureData = {
                                            avgFDR3: avgFDR3,
                                            avgFDR5: avgFDR5,
                                            next3: next3,
                                            next5: next5,
                                            fixtureString: fixtureString
                                        };
                                    }
                                    
                                    return {
                                        ...player,
                                        fixtures: fixtureData
                                    };
                                });
                                
                                // Detect current gameweek and phase
                                currentGameweek = detectCurrentGameweek(analyses);
                                currentPhase = getSeasonPhase(currentGameweek);
                                console.log(`üìÖ Detected GW${currentGameweek} (${currentPhase} season phase)`);
                                
                                // Store analyses globally for comparison feature
                                allAnalyses = analyses;
                                
                                // Render everything
                                document.getElementById('section-RECOMMENDATIONS').innerHTML = generateRecommendations(analyses);
                                document.getElementById('section-FORM').innerHTML = generateFormPlayers(analyses);
                                document.getElementById('section-CHARTS').innerHTML = generateCharts(analyses);
                                document.getElementById('section-FIXTURES').innerHTML = generateFixtureTicker(analyses);
                                document.getElementById('section-GK').innerHTML = createTable('GK', analyses);
                                document.getElementById('section-DEF').innerHTML = createTable('DEF', analyses);
                                document.getElementById('section-MID').innerHTML = createTable('MID', analyses);
                                document.getElementById('section-FWD').innerHTML = createTable('FWD', analyses);
                                
                                updateStatus(`‚úì Loaded ${analyses.length} players from cache (${ageHours.toFixed(1)}h old)`, 'success');
                                showLoading(false);
                                showCacheInfo();
                                return;
                            } catch (e) {
                                console.warn('Cache corrupted, fetching fresh data');
                                localStorage.removeItem('fpl_players_cache');
                                localStorage.removeItem('fpl_players_cache_time');
                            }
                        } else {
                            console.log('Cache expired (>24 hours), fetching fresh data');
                        }
                    }
                }
                
                // PRIORITY 3: Fetch from API (last resort)
                console.log('Fetching from FPL API (this may take 30-60 seconds)');
                updateStatus('Fetching bootstrap data from API...', 'loading');

                bootstrapData = await fetchBootstrapData();
                
                // Build teams object FIRST - needed for fixtures and player analysis
                teams = {};
                bootstrapData.teams.forEach(team => {
                    teams[team.id] = {
                        id: team.id,
                        name: team.name,
                        short_name: team.short_name,
                        strength: team.strength
                    };
                });
                
                console.log('‚úÖ Teams object built:', Object.keys(teams).length, 'teams');
                
                // Load fixtures AFTER teams object is ready
                updateStatus('Loading fixtures...', 'loading');
                await loadFixtures();
                console.log('‚úÖ Fixtures loaded');

                // Get all players from the API
                const allPlayers = bootstrapData.elements.map(player => ({
                    id: player.id,
                    name: player.web_name,
                    position: player.element_type,
                    team: teams[player.team].short_name,
                    teamId: player.team,
                    totalPoints: player.total_points,
                    minutes: player.minutes,
                    price: player.now_cost / 10, // Convert to actual price
                    form: parseFloat(player.form),
                    selectedByPercent: parseFloat(player.selected_by_percent)
                }));

                // Filter players who have played at least some minutes
                const activePlayers = allPlayers.filter(p => p.minutes > 0);
                
                updateStatus(`Found ${activePlayers.length} active players. Starting detailed analysis...`, 'loading');
                console.log(`Analyzing ${activePlayers.length} players with game time`);

                const analyses = [];
                let successCount = 0;
                let skipCount = 0;
                
                for (let i = 0; i < activePlayers.length; i++) {
                    const player = activePlayers[i];
                    
                    if (i % 10 === 0) {
                        updateStatus(`Analyzing ${player.name} (${i + 1}/${activePlayers.length}) - ${successCount} loaded, ${skipCount} skipped`, 'loading');
                    }
                    
                    try {
                        // This makes the actual API call to element-summary endpoint
                        const analysis = await analyzePlayer(player.id, player.name, player.position, player.team, player.teamId);
                        if (analysis) {
                            // Add price and form data to analysis
                            analysis.price = player.price;
                            analysis.form = player.form;
                            analysis.selectedByPercent = player.selectedByPercent;
                            analyses.push(analysis);
                            successCount++;
                        } else {
                            skipCount++;
                        }
                    } catch (error) {
                        console.error(`Failed to analyze ${player.name}:`, error);
                        skipCount++;
                    }
                    
                    // Add a small delay every 20 players to avoid overwhelming the API
                    if (i > 0 && i % 20 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                }

                console.log(`Analysis complete: ${successCount} players loaded, ${skipCount} skipped`);
                
                // Cache the results
                try {
                    const cacheData = {
                        bootstrapData: bootstrapData,
                        analyses: analyses,
                        timestamp: Date.now()
                    };
                    localStorage.setItem('fpl_players_cache', JSON.stringify(cacheData));
                    localStorage.setItem('fpl_players_cache_time', Date.now().toString());
                    console.log('Data cached successfully');
                } catch (e) {
                    console.warn('Failed to cache data (localStorage full?):', e);
                }

                // Detect current gameweek and phase
                currentGameweek = detectCurrentGameweek(analyses);
                currentPhase = getSeasonPhase(currentGameweek);
                console.log(`üìÖ Detected GW${currentGameweek} (${currentPhase} season phase)`);

                // Store analyses globally for comparison feature
                allAnalyses = analyses;

                // Generate recommendations
                document.getElementById('section-RECOMMENDATIONS').innerHTML = generateRecommendations(analyses);
                
                // Generate form players
                document.getElementById('section-FORM').innerHTML = generateFormPlayers(analyses);
                
                // Generate charts and fixture ticker
                document.getElementById('section-CHARTS').innerHTML = generateCharts(analyses);
                document.getElementById('section-FIXTURES').innerHTML = generateFixtureTicker(analyses);

                // Render tables
                document.getElementById('section-GK').innerHTML = createTable('GK', analyses);
                document.getElementById('section-DEF').innerHTML = createTable('DEF', analyses);
                document.getElementById('section-MID').innerHTML = createTable('MID', analyses);
                document.getElementById('section-FWD').innerHTML = createTable('FWD', analyses);

                updateStatus(`‚úì Successfully loaded ${successCount} players (${skipCount} skipped due to no data)`, 'success');
                showLoading(false);
                showCacheInfo();

            } catch (error) {
                console.error('Error loading data:', error);
                updateStatus(`‚úó Error: ${error.message}`, 'error');
                showLoading(false);
            }
        }

        // ============================================
        // REUSABLE PLAYER STATS COMPONENT
        // Single source of truth for stat display
        // ============================================
        
        /**
         * Renders player stats in a consistent format
         * @param {Object} player - Player object with l5, season, etc.
         * @param {string} position - 'GK', 'DEF', 'MID', 'FWD'
         * @param {string} format - 'card' (recommendation cards) or 'grid' (form player cards)
         * @returns {string} HTML string
         */
        function renderPlayerStats(player, position, format = 'card') {
            const l5Games = player.l5?.games || 1;
            const l5AvgPoints = (player.l5?.points || 0) / l5Games;
            const valueScore = player.valueScore || (l5AvgPoints / player.price);
            
            // Position-specific stats
            let stats = [];
            
            if (position === 'GK') {
                const csRate = (player.l5?.cleanSheets || 0) / l5Games;
                const savesPerGame = (player.l5?.saves || 0) / l5Games;
                const bonusPerGame = (player.l5?.bonus || 0) / l5Games;
                const penaltiesSaved = player.l5?.penaltiesSaved || 0;
                
                stats = [
                    { label: 'Pts/Game', value: l5AvgPoints.toFixed(1), color: 'var(--text)' },
                    { label: 'CS Rate', value: `${(csRate * 100).toFixed(0)}%`, color: csRate >= 0.4 ? 'var(--accent-green)' : 'var(--text)' },
                    { label: 'Saves/G', value: savesPerGame.toFixed(1), color: savesPerGame >= 3 ? 'var(--accent-green)' : 'var(--text)' },
                    { label: 'Bonus/G', value: bonusPerGame.toFixed(1), color: bonusPerGame >= 1 ? 'var(--accent-yellow)' : 'var(--text)' }
                ];
                
                // Add penalty saves badge if any
                if (penaltiesSaved > 0) {
                    stats.push({ label: 'üß§ Pen Saves', value: penaltiesSaved.toString(), color: 'var(--accent-green)', highlight: true });
                }
                
            } else if (position === 'DEF') {
                const csRate = (player.l5?.cleanSheets || 0) / l5Games;
                const l5xGI = (player.l5?.xGI || 0) / l5Games;
                const bonusPerGame = (player.l5?.bonus || 0) / l5Games;
                
                stats = [
                    { label: 'Pts/Game', value: l5AvgPoints.toFixed(1), color: 'var(--text)' },
                    { label: 'Value', value: `${valueScore.toFixed(2)}/¬£m`, color: valueScore >= 1.0 ? 'var(--accent-green)' : 'var(--text)' },
                    { label: 'CS Rate', value: `${(csRate * 100).toFixed(0)}%`, color: csRate >= 0.4 ? 'var(--accent-green)' : 'var(--text)' },
                    { label: 'xGI/G', value: l5xGI.toFixed(2), color: l5xGI >= 0.15 ? 'var(--accent-green)' : 'var(--text)' }
                ];
                
            } else {
                // MID/FWD
                const l5xGI = (player.l5?.xGI || 0) / l5Games;
                const l5Goals = (player.l5?.goals || 0) / l5Games;
                const l5Assists = (player.l5?.assists || 0) / l5Games;
                
                stats = [
                    { label: 'Pts/Game', value: l5AvgPoints.toFixed(1), color: 'var(--text)' },
                    { label: 'Value', value: `${valueScore.toFixed(2)}/¬£m`, color: valueScore >= 1.0 ? 'var(--accent-green)' : 'var(--text)' },
                    { label: 'xGI/G', value: l5xGI.toFixed(2), color: l5xGI >= 0.4 ? 'var(--accent-green)' : 'var(--text)' },
                    { label: 'G+A/G', value: (l5Goals + l5Assists).toFixed(2), color: (l5Goals + l5Assists) >= 0.4 ? 'var(--accent-green)' : 'var(--text)' }
                ];
            }
            
            // Render based on format
            if (format === 'grid') {
                // Form player card format (4-column grid)
                return `
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 12px; padding: 10px; background: var(--bg-dark); border-radius: 3px;">
                        <div>
                            <div style="font-size: 9px; color: var(--text-dim); text-transform: uppercase;">Price</div>
                            <div style="font-size: 12px; font-weight: 600; color: var(--accent-green);">¬£${player.price.toFixed(1)}m</div>
                        </div>
                        <div>
                            <div style="font-size: 9px; color: var(--text-dim); text-transform: uppercase;">Owned</div>
                            <div style="font-size: 12px; font-weight: 600; color: var(--text);">${(player.selectedBy || player.ownership || 0).toFixed(1)}%</div>
                        </div>
                        ${stats.slice(0, 2).map(s => `
                            <div>
                                <div style="font-size: 9px; color: var(--text-dim); text-transform: uppercase;">${s.label}</div>
                                <div style="font-size: 12px; font-weight: 600; color: ${s.color};">${s.value}</div>
                            </div>
                        `).join('')}
                    </div>
                `;
            } else {
                // Recommendation card format (3-column)
                return stats.slice(0, 3).map(s => `
                    <div class="player-rec-stat">
                        <span class="player-rec-stat-label">${s.label}</span>
                        <span class="player-rec-stat-value" style="color: ${s.color};">${s.value}</span>
                    </div>
                `).join('');
            }
        }
        
        /**
         * Renders fixture info badge
         * @param {Object} player - Player object with fixtures
         * @returns {string} HTML string
         */
        function renderFixtureBadge(player) {
            if (!player.fixtures || !player.fixtures.avgFDR3) return '';
            
            const fdr = player.fixtures.avgFDR3;
            const fixtureStr = player.fixtures.fixtureString || '';
            let badgeColor = 'var(--text-dim)';
            let badgeText = 'Neutral';
            
            if (fdr < 2.5) { badgeColor = 'var(--accent-green)'; badgeText = 'üü¢üü¢ Easy'; }
            else if (fdr < 3.0) { badgeColor = '#88cc88'; badgeText = 'üü¢ Good'; }
            else if (fdr > 3.5) { badgeColor = 'var(--accent-red)'; badgeText = 'üî¥ Tough'; }
            else { badgeColor = 'var(--accent-yellow)'; badgeText = 'üü° Mixed'; }
            
            return `
                <div style="margin-top: 8px; padding: 6px 8px; background: var(--bg-darker); border-radius: 3px; border-left: 2px solid ${badgeColor};">
                    <div style="font-size: 8px; color: var(--text-dim); text-transform: uppercase; margin-bottom: 2px;">Next 3 Fixtures</div>
                    <div style="font-size: 9px; color: ${badgeColor}; font-weight: 500;">${badgeText} (FDR ${fdr.toFixed(1)})</div>
                    <div style="font-size: 8px; color: var(--text-dim); margin-top: 2px;">${fixtureStr}</div>
                </div>
            `;
        }

        // ============================================
        // RECOMMENDATION CATEGORY FUNCTIONS
        // ============================================
        
        /**
         * Get top captaincy options - highest ceiling players
         */
        function getTopCaptainOptions(analyses, limit = 5) {
            const positionMap = { 1: 'GK', 2: 'DEF', 3: 'MID', 4: 'FWD' };
            
            return analyses
                .filter(p => {
                    const pos = positionMap[p.position];
                    if (pos === 'GK') return false;
                    if (!p.l5 || p.l5.games < 3) return false;
                    const l5Mins = p.l5.minutes / p.l5.games;
                    return l5Mins >= 70;
                })
                .map(p => {
                    const l5Games = p.l5.games;
                    const l5xGI = p.l5.xGI / l5Games;
                    const l5Pts = p.l5.points / l5Games;
                    const fdr = p.fixtures?.avgFDR3 || 3;
                    
                    const captaincyScore = (l5xGI * 40) + (l5Pts * 3) + 
                                          (fdr < 2.5 ? 20 : fdr < 3 ? 10 : fdr > 3.5 ? -15 : 0) +
                                          (p.l5.goals / l5Games * 10) + (p.l5.bonus / l5Games * 2);
                    
                    return { ...p, captaincyScore, l5xGI, l5Pts, fdr, position: positionMap[p.position] };
                })
                .sort((a, b) => b.captaincyScore - a.captaincyScore)
                .slice(0, limit);
        }
        
        /**
         * Get best transfer targets - form + fixtures + differential value
         */
        function getBestTransferTargets(analyses, limit = 5) {
            const positionMap = { 1: 'GK', 2: 'DEF', 3: 'MID', 4: 'FWD' };
            
            return analyses
                .filter(p => {
                    if (!p.l5 || !p.season || p.l5.games < 4 || p.season.games < 6) return false;
                    const l5Mins = p.l5.minutes / p.l5.games;
                    return l5Mins >= 70 && p.price > 4.0;
                })
                .map(p => {
                    const l5Games = p.l5.games;
                    const seasonGames = p.season.games;
                    const l5Pts = p.l5.points / l5Games;
                    const seasonPts = p.season.points / seasonGames;
                    const l5xGI = p.l5.xGI / l5Games;
                    const fdr = p.fixtures?.avgFDR3 || 3;
                    const ownership = p.selectedBy || 0;
                    
                    const formImprovement = ((l5Pts - seasonPts) / seasonPts) * 100;
                    
                    const transferScore = (formImprovement > 0 ? formImprovement * 0.5 : 0) +
                                         (l5xGI * 30) + (l5Pts * 2) +
                                         (fdr < 2.5 ? 15 : fdr < 3 ? 8 : fdr > 3.5 ? -10 : 0) +
                                         (ownership < 10 ? 10 : ownership < 20 ? 5 : 0);
                    
                    return { ...p, transferScore, formImprovement, l5xGI, l5Pts, fdr, ownership, position: positionMap[p.position] };
                })
                .sort((a, b) => b.transferScore - a.transferScore)
                .slice(0, limit);
        }
        
        /**
         * Get set-and-forget picks - consistent performers
         */
        function getSetAndForgetPicks(analyses, limit = 5) {
            const positionMap = { 1: 'GK', 2: 'DEF', 3: 'MID', 4: 'FWD' };
            
            return analyses
                .filter(p => {
                    if (!p.l5 || !p.season || p.season.games < 10) return false;
                    const seasonMins = p.season.minutes / p.season.games;
                    const l5Mins = p.l5.minutes / p.l5.games;
                    return seasonMins >= 80 && l5Mins >= 80;
                })
                .map(p => {
                    const seasonGames = p.season.games;
                    const seasonPts = p.season.points / seasonGames;
                    const seasonxGI = p.season.xGI / seasonGames;
                    const value = seasonPts / p.price;
                    const l5Pts = p.l5.points / p.l5.games;
                    const l5xGI = p.l5.xGI / p.l5.games;
                    
                    const consistencyScore = (seasonPts * 5) + (value * 15) + (seasonxGI * 20) +
                                            ((p.season.minutes / p.season.games) / 90 * 10);
                    
                    return { ...p, consistencyScore, seasonPts, value, seasonxGI, l5Pts, l5xGI, position: positionMap[p.position] };
                })
                .sort((a, b) => b.consistencyScore - a.consistencyScore)
                .slice(0, limit);
        }
        
        /**
         * Get differentials - low ownership gems (<5%)
         */
        function getDifferentials(analyses, limit = 5) {
            const positionMap = { 1: 'GK', 2: 'DEF', 3: 'MID', 4: 'FWD' };
            
            return analyses
                .filter(p => {
                    if (!p.l5 || p.l5.games < 3) return false;
                    const ownership = p.selectedBy || 0;
                    const l5Mins = p.l5.minutes / p.l5.games;
                    const l5Pts = p.l5.points / p.l5.games;
                    return ownership < 5 && l5Mins >= 60 && l5Pts >= 2;
                })
                .map(p => {
                    const l5Games = p.l5.games;
                    const l5Pts = p.l5.points / l5Games;
                    const l5xGI = p.l5.xGI / l5Games;
                    const ownership = p.selectedBy || 0;
                    const fdr = p.fixtures?.avgFDR3 || 3;
                    
                    const diffScore = (l5Pts * 5) + (l5xGI * 25) + ((5 - ownership) * 3) + (fdr < 3 ? 10 : 0);
                    
                    return { ...p, diffScore, l5Pts, l5xGI, ownership, fdr, position: positionMap[p.position] };
                })
                .sort((a, b) => b.diffScore - a.diffScore)
                .slice(0, limit);
        }
        
        /**
         * Get players to avoid - sell candidates
         */
        function getPlayersToAvoid(analyses, limit = 5) {
            const positionMap = { 1: 'GK', 2: 'DEF', 3: 'MID', 4: 'FWD' };
            
            return analyses
                .filter(p => {
                    if (!p.l5 || !p.season || p.l5.games < 3) return false;
                    const ownership = p.selectedBy || 0;
                    return ownership >= 10;
                })
                .map(p => {
                    const l5Games = p.l5.games;
                    const seasonGames = p.season.games;
                    const l5Pts = p.l5.points / l5Games;
                    const seasonPts = p.season.points / seasonGames;
                    const l5xGI = p.l5.xGI / l5Games;
                    const l5Mins = p.l5.minutes / l5Games;
                    const fdr = p.fixtures?.avgFDR3 || 3;
                    const ownership = p.selectedBy || 0;
                    
                    const formDecline = ((seasonPts - l5Pts) / seasonPts) * 100;
                    
                    let avoidScore = 0;
                    if (formDecline > 20) avoidScore += formDecline * 0.5;
                    if (l5Mins < 70) avoidScore += (70 - l5Mins) * 0.5;
                    if (fdr > 3.5) avoidScore += (fdr - 3) * 10;
                    if (l5xGI < 0.15 && positionMap[p.position] !== 'GK') avoidScore += 10;
                    if (l5Pts / p.price < 0.5) avoidScore += 10;
                    
                    const reasons = [];
                    if (formDecline > 20) reasons.push(`üìâ Form -${formDecline.toFixed(0)}%`);
                    if (l5Mins < 70) reasons.push(`‚ö†Ô∏è ${l5Mins.toFixed(0)}min avg`);
                    if (fdr > 3.5) reasons.push(`üî¥ FDR ${fdr.toFixed(1)}`);
                    if (l5xGI < 0.15 && positionMap[p.position] !== 'GK') reasons.push(`üìä Low xGI`);
                    
                    return { ...p, avoidScore, formDecline, l5Pts, l5xGI, l5Mins, fdr, ownership, reasons, position: positionMap[p.position] };
                })
                .filter(p => p.avoidScore >= 15)
                .sort((a, b) => b.avoidScore - a.avoidScore)
                .slice(0, limit);
        }
        
        /**
         * Render a special category card
         */
        function renderSpecialCategoryCard(player, rank, categoryType) {
            const positionColors = { 'GK': '#f59e0b', 'DEF': '#3b82f6', 'MID': '#10b981', 'FWD': '#ef4444' };
            const categoryColors = {
                'captain': 'var(--accent-yellow)',
                'transfer': 'var(--accent-green)',
                'setforget': 'var(--accent-blue)',
                'differential': '#a855f7',
                'avoid': 'var(--accent-red)'
            };
            
            const posColor = positionColors[player.position] || 'var(--text)';
            const catColor = categoryColors[categoryType] || 'var(--accent-green)';
            
            const scoreLabels = {
                'captain': ['Cap Score', player.captaincyScore],
                'transfer': ['Transfer', player.transferScore],
                'setforget': ['Consistency', player.consistencyScore],
                'differential': ['Diff Score', player.diffScore],
                'avoid': ['Risk', player.avoidScore]
            };
            
            const [scoreLabel, scoreVal] = scoreLabels[categoryType] || ['Score', 0];
            const l5Pts = player.l5Pts || (player.l5?.points / player.l5?.games) || 0;
            const l5xGI = player.l5xGI || (player.l5?.xGI / player.l5?.games) || 0;
            const fdr = player.fdr || player.fixtures?.avgFDR3 || 3;
            const ownership = player.ownership || player.selectedBy || 0;
            
            let fdrColor = fdr < 2.5 ? 'var(--accent-green)' : fdr < 3 ? '#88cc88' : fdr > 3.5 ? 'var(--accent-red)' : 'var(--accent-yellow)';
            
            return `
                <div style="background: var(--surface-light); border-left: 3px solid ${catColor}; padding: 12px; border-radius: 4px; margin-bottom: 10px;">
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
                        <div>
                            <div style="font-size: 13px; font-weight: 600; color: var(--text);">
                                <span style="color: ${catColor}; margin-right: 6px;">#${rank}</span>${player.name}
                            </div>
                            <div style="font-size: 10px; color: var(--text-dim); margin-top: 2px;">
                                ${player.team} ‚Ä¢ <span style="color: ${posColor}; font-weight: 500;">${player.position}</span> ‚Ä¢ ¬£${player.price.toFixed(1)}m
                            </div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 14px; font-weight: 700; color: ${catColor};">${(scoreVal || 0).toFixed(0)}</div>
                            <div style="font-size: 8px; color: var(--text-dim); text-transform: uppercase;">${scoreLabel}</div>
                        </div>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; padding: 8px; background: var(--bg-dark); border-radius: 3px; font-size: 10px;">
                        <div><div style="color: var(--text-dim); font-size: 8px;">Pts/G</div><div style="color: var(--text); font-weight: 600;">${l5Pts.toFixed(1)}</div></div>
                        <div><div style="color: var(--text-dim); font-size: 8px;">xGI/G</div><div style="color: var(--text); font-weight: 600;">${l5xGI.toFixed(2)}</div></div>
                        <div><div style="color: var(--text-dim); font-size: 8px;">FDR</div><div style="color: ${fdrColor}; font-weight: 600;">${fdr.toFixed(1)}</div></div>
                        <div><div style="color: var(--text-dim); font-size: 8px;">Own%</div><div style="color: var(--text); font-weight: 600;">${ownership.toFixed(1)}%</div></div>
                    </div>
                    ${categoryType === 'avoid' && player.reasons?.length ? `<div style="margin-top: 8px; font-size: 10px; color: var(--accent-red);">${player.reasons.slice(0, 2).join(' ‚Ä¢ ')}</div>` : ''}
                </div>
            `;
        }

        function generateRecommendations(analyses) {
            const positionMap = { 1: 'GK', 2: 'DEF', 3: 'MID', 4: 'FWD' };
            const positionNames = { 'GK': 'Goalkeepers', 'DEF': 'Defenders', 'MID': 'Midfielders', 'FWD': 'Forwards' };
            const cfg = RECOMMENDATION_CONFIG; // Shorthand
            
            // Get phase-adjusted weights
            const weights = getPhaseAdjustedWeights();
            const phaseInfo = getPhaseInfo();
            
            // Get special categories
            const captainOptions = getTopCaptainOptions(analyses);
            const transferTargets = getBestTransferTargets(analyses);
            const setAndForget = getSetAndForgetPicks(analyses);
            const differentials = getDifferentials(analyses);
            const avoidList = getPlayersToAvoid(analyses);
            
            // Phase info banner
            let html = `
                <div style="margin-bottom: 25px; padding: 20px; background: var(--surface); border-left: 4px solid ${phaseInfo.color}; border-radius: 4px;">
                    <div style="display: flex; justify-content: space-between; align-items: start; flex-wrap: wrap; gap: 15px;">
                        <div>
                            <h2 style="color: ${phaseInfo.color}; margin-bottom: 8px; font-size: 18px; font-family: 'Space Mono', monospace;">
                                ${phaseInfo.emoji} ${phaseInfo.name} (GW${currentGameweek})
                            </h2>
                            <p style="font-size: 12px; color: var(--text-dim); line-height: 1.5; margin-bottom: 10px;">
                                ${phaseInfo.description}
                            </p>
                            <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                                ${phaseInfo.tips.map(tip => `<span style="font-size: 10px; color: var(--text); background: var(--surface-light); padding: 4px 10px; border-radius: 12px;">üí° ${tip}</span>`).join('')}
                            </div>
                        </div>
                        <div style="text-align: right; min-width: 120px;">
                            <div style="font-size: 9px; color: var(--text-dim); text-transform: uppercase; margin-bottom: 4px;">Weight Focus</div>
                            <div style="font-size: 10px; color: var(--text);">
                                ${currentPhase === 'early' ? 'üìÖ Fixtures +50%<br>üîí Minutes +50%<br>üìä Stats -30%' : ''}
                                ${currentPhase === 'mid' ? '‚öñÔ∏è Balanced<br>All weights normal' : ''}
                                ${currentPhase === 'late' ? 'üéØ Differentials +15<br>üî• Form +20%<br>üìÖ Fixtures +30%' : ''}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Special Categories Section
            html += `
                <div style="margin-bottom: 30px;">
                    <h2 style="color: var(--accent-green); font-family: 'Space Mono', monospace; margin-bottom: 20px; font-size: 16px;">
                        üéØ Quick Actions
                    </h2>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px;">
                        
                        <!-- Captain Options -->
                        <div style="background: var(--surface); padding: 15px; border-radius: 6px; border: 1px solid var(--border);">
                            <h3 style="color: var(--accent-yellow); font-size: 14px; margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
                                üëë Captain Options
                                <span style="font-size: 9px; background: var(--accent-yellow); color: var(--bg-dark); padding: 2px 6px; border-radius: 8px;">TOP ${captainOptions.length}</span>
                            </h3>
                            ${captainOptions.length > 0 ? captainOptions.map((p, i) => renderSpecialCategoryCard(p, i + 1, 'captain')).join('') : '<div style="color: var(--text-dim); font-size: 11px;">No strong captain options found</div>'}
                        </div>
                        
                        <!-- Transfer Targets -->
                        <div style="background: var(--surface); padding: 15px; border-radius: 6px; border: 1px solid var(--border);">
                            <h3 style="color: var(--accent-green); font-size: 14px; margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
                                üîÑ Transfer Targets
                                <span style="font-size: 9px; background: var(--accent-green); color: var(--bg-dark); padding: 2px 6px; border-radius: 8px;">TOP ${transferTargets.length}</span>
                            </h3>
                            ${transferTargets.length > 0 ? transferTargets.map((p, i) => renderSpecialCategoryCard(p, i + 1, 'transfer')).join('') : '<div style="color: var(--text-dim); font-size: 11px;">No strong transfer targets found</div>'}
                        </div>
                        
                        <!-- Set & Forget -->
                        <div style="background: var(--surface); padding: 15px; border-radius: 6px; border: 1px solid var(--border);">
                            <h3 style="color: var(--accent-blue); font-size: 14px; margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
                                üîí Set & Forget
                                <span style="font-size: 9px; background: var(--accent-blue); color: var(--bg-dark); padding: 2px 6px; border-radius: 8px;">TOP ${setAndForget.length}</span>
                            </h3>
                            ${setAndForget.length > 0 ? setAndForget.map((p, i) => renderSpecialCategoryCard(p, i + 1, 'setforget')).join('') : '<div style="color: var(--text-dim); font-size: 11px;">No set-and-forget picks found</div>'}
                        </div>
                        
                        <!-- Differentials -->
                        <div style="background: var(--surface); padding: 15px; border-radius: 6px; border: 1px solid var(--border);">
                            <h3 style="color: #a855f7; font-size: 14px; margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
                                üíé Differentials
                                <span style="font-size: 9px; background: #a855f7; color: white; padding: 2px 6px; border-radius: 8px;">&lt;5% OWNED</span>
                            </h3>
                            ${differentials.length > 0 ? differentials.map((p, i) => renderSpecialCategoryCard(p, i + 1, 'differential')).join('') : '<div style="color: var(--text-dim); font-size: 11px;">No differentials meeting criteria</div>'}
                        </div>
                        
                        <!-- Avoid List -->
                        <div style="background: var(--surface); padding: 15px; border-radius: 6px; border: 1px solid rgba(239, 68, 68, 0.3);">
                            <h3 style="color: var(--accent-red); font-size: 14px; margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
                                ‚ö†Ô∏è Avoid / Sell
                                <span style="font-size: 9px; background: var(--accent-red); color: white; padding: 2px 6px; border-radius: 8px;">CAUTION</span>
                            </h3>
                            ${avoidList.length > 0 ? avoidList.map((p, i) => renderSpecialCategoryCard(p, i + 1, 'avoid')).join('') : '<div style="color: var(--text-dim); font-size: 11px;">No highly-owned players to avoid</div>'}
                        </div>
                        
                    </div>
                </div>
            `;
            
            // Section header for position picks
            html += `
                <h2 style="color: var(--accent-green); font-family: 'Space Mono', monospace; margin-bottom: 20px; font-size: 16px;">
                    üìã By Position
                </h2>
            `;
            
            html += '<div class="recommendations-container">';
            
            ['GK', 'DEF', 'MID', 'FWD'].forEach(position => {
                const players = analyses.filter(a => positionMap[a.position] === position);
                
                // Enhanced filtering criteria based on FPL research
                const eligiblePlayers = players.filter(p => {
                    const avgMinutes = p.season.minutes / p.season.games;
                    const l5AvgMinutes = p.l5.minutes / p.l5.games;
                    
                    // Must be "nailed on" - consistent high minutes in last 5
                    const isNailedOn = l5AvgMinutes >= cfg.thresholds.nailedOnMinutes && p.l5.games >= cfg.thresholds.minL5Games;
                    
                    // Must have reasonable season minutes (not just a recent flash)
                    const hasSeasonMinutes = avgMinutes >= cfg.thresholds.minAvgMinutes && p.season.games >= cfg.thresholds.minSeasonGames;
                    
                    return isNailedOn && hasSeasonMinutes && p.price > cfg.thresholds.minPrice;
                });
                
                // Calculate comprehensive scores for each player
                eligiblePlayers.forEach(p => {
                    const l5Games = p.l5.games;
                    const seasonGames = p.season.games;
                    
                    // VALUE METRIC (most important in FPL)
                    const l5AvgPoints = p.l5.points / l5Games;
                    const pointsPerMillion = l5AvgPoints / p.price;
                    
                    // UNDERLYING STATS (xG, xA - better predictors than actual goals)
                    const l5xGI = p.l5.xGI / l5Games;
                    const seasonxGI = p.season.xGI / seasonGames;
                    
                    // FORM vs EXPECTED (identify over/underperformers)
                    const l5ActualGI = (p.l5.goals + p.l5.assists) / l5Games;
                    const xGIDiff = l5ActualGI - l5xGI; // Negative means underperforming (due for returns)
                    
                    // MINUTES CONSISTENCY (rotation risk)
                    const minutesConsistency = (p.l5.minutes / p.l5.games) / 90;
                    
                    // POSITION-SPECIFIC SCORING
                    let positionScore = 0;
                    
                    if (position === 'GK') {
                        const l5CS = p.l5.cleanSheets / l5Games;
                        const l5SavesPerGame = p.l5.saves / l5Games;
                        const l5xGC = p.l5.xGC / l5Games;
                        const l5PenaltiesSaved = (p.l5.penaltiesSaved || 0) / l5Games;
                        const l5BonusPerGame = (p.l5.bonus || 0) / l5Games;
                        const l5AssistsPerGame = (p.l5.assists || 0) / l5Games;
                        
                        const gkWeights = cfg.gkScoring;
                        
                        // Enhanced GK score:
                        // - Clean sheets (4 pts each, most important)
                        // - Saves bonus (every 3 saves = 1 pt, ~0.33 per save)
                        // - Penalty saves (huge 5 pt swing)
                        // - Bonus points (indicates BPS performance)
                        // - Distribution/assists (rare but valuable)
                        // - Penalize high xGC (team defensive weakness)
                        positionScore = (l5CS * gkWeights.cleanSheet) +
                                       (l5SavesPerGame * gkWeights.savesPerGame) +
                                       (l5PenaltiesSaved * gkWeights.penaltySave) +
                                       (l5BonusPerGame * gkWeights.bonusPerGame) +
                                       (l5AssistsPerGame * gkWeights.assistPerGame) -
                                       (l5xGC * gkWeights.xGCPenalty);
                        
                        // Store GK-specific metrics for display
                        p.gkMetrics = {
                            csRate: l5CS,
                            savesPerGame: l5SavesPerGame,
                            penaltiesSaved: p.l5.penaltiesSaved || 0,
                            bonusPerGame: l5BonusPerGame,
                            xGC: l5xGC
                        };
                        
                    } else if (position === 'DEF') {
                        const l5CS = p.l5.cleanSheets / l5Games;
                        const l5xGC = p.l5.xGC / l5Games;
                        
                        // DEF score: Clean sheets + attacking threat, penalize high xGC
                        positionScore = (l5CS * 12) + (l5xGI * 20) - (l5xGC * 1.5);
                        
                    } else {
                        // MID/FWD score: Pure attacking threat via xGI
                        positionScore = l5xGI * 25;
                        
                        // Bonus for big chance creation (creativity)
                        const l5BCC = p.l5.bigChancesCreated / l5Games;
                        positionScore += l5BCC * 3;
                    }
                    
                    // FIXTURE DIFFICULTY BONUS (phase-adjusted)
                    let fixtureBonus = 0;
                    if (p.fixtures && p.fixtures.avgFDR3) {
                        if (p.fixtures.avgFDR3 < cfg.fdr.easy) fixtureBonus = weights.easyFixtures;
                        else if (p.fixtures.avgFDR3 < cfg.fdr.favorable) fixtureBonus = weights.favorableFixtures;
                        else if (p.fixtures.avgFDR3 > cfg.fdr.tough) fixtureBonus = weights.toughFixtures;
                    }
                    
                    // DIFFERENTIAL BONUS (late season only)
                    let differentialBonus = 0;
                    const ownership = p.selectedBy || 0;
                    if (weights.differentialBonus > 0 && ownership < cfg.gameweekPhases.differentialThreshold) {
                        differentialBonus = weights.differentialBonus;
                    }
                    
                    // COMPREHENSIVE SCORE combining all factors (phase-adjusted)
                    p.recommendationScore = (
                        pointsPerMillion * weights.value +
                        positionScore * weights.positionScore +
                        minutesConsistency * weights.minutesConsistency +
                        (l5xGI > seasonxGI ? weights.formImprovement : weights.formDecline) +
                        fixtureBonus +
                        differentialBonus
                    );
                    
                    // Store metrics for display
                    p.fixtureBonus = fixtureBonus;
                    p.differentialBonus = differentialBonus;
                    p.valueScore = pointsPerMillion;
                    p.l5xGIperGame = l5xGI;
                    p.minutesConsistency = minutesConsistency;
                    // Only flag underperformance if xGI is meaningful (otherwise they're just not good)
                    p.isUnderperforming = l5xGI >= cfg.thresholds.minXGIForUnderperformance && 
                                          (l5xGI - l5ActualGI) > cfg.thresholds.underperformanceXGI;
                });
                
                // Sort by recommendation score
                eligiblePlayers.sort((a, b) => b.recommendationScore - a.recommendationScore);
                
                // Get budget threshold from config
                const threshold = cfg.budgetCaps[position];
                const budgetPlayers = eligiblePlayers.filter(p => p.price <= threshold).slice(0, cfg.display.maxPlayersPerCategory);
                const premiumPlayers = eligiblePlayers.filter(p => p.price > threshold).slice(0, cfg.display.maxPlayersPerCategory);
                
                html += `
                    <div class="position-recommendations">
                        <h2>${positionNames[position]}</h2>
                        <div class="recommendations-grid">
                            ${createRecommendationCategory('Budget Options', budgetPlayers, position, threshold, 'budget')}
                            ${createRecommendationCategory('Premium Options', premiumPlayers, position, threshold, 'premium')}
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            return html;
        }
        
        function createRecommendationCategory(title, players, position, priceThreshold, categoryType) {
            const categoryClass = categoryType;
            
            let html = `<div class="rec-category ${categoryClass}">
                <h3>${title} (${categoryType === 'budget' ? '‚â§' : '>'} ¬£${priceThreshold.toFixed(1)}m)</h3>`;
            
            const cfg = RECOMMENDATION_CONFIG; // Shorthand
            const weights = getPhaseAdjustedWeights(); // Get phase-adjusted weights
            
            if (players.length === 0) {
                html += '<div class="no-data" style="padding: 20px;">No players meet the criteria</div>';
            } else {
                players.forEach(player => {
                    const l5AvgPoints = player.l5.points / player.l5.games;
                    const l5AvgMinutes = player.l5.minutes / player.l5.games;
                    const ownership = player.selectedBy || 0;
                    
                    // Generate smart reasoning based on metrics
                    let reasons = [];
                    
                    // Differential bonus (late season)
                    if (player.differentialBonus > 0) {
                        reasons.push(`üéØ Differential pick (${ownership.toFixed(1)}% owned)`);
                    }
                    
                    if (player.valueScore > cfg.thresholds.excellentValue) {
                        reasons.push(`Excellent value at ${player.valueScore.toFixed(2)} pts/¬£m`);
                    } else if (player.valueScore > cfg.thresholds.goodValue) {
                        reasons.push(`Good value at ${player.valueScore.toFixed(2)} pts/¬£m`);
                    }
                    
                    if (player.minutesConsistency > cfg.thresholds.highMinutesConsistency) {
                        reasons.push('Nailed on starter');
                    }
                    
                    if (player.isUnderperforming) {
                        reasons.push('Underperforming xGI - due returns');
                    }
                    
                    if (player.l5xGIperGame > cfg.thresholds.strongXGI && (position === 'MID' || position === 'FWD')) {
                        reasons.push(`Strong xGI of ${player.l5xGIperGame.toFixed(2)}/game`);
                    }
                    
                    const pointsTrend = calculateTrend(player.season.points, player.l5.points, player.season.games, player.l5.games);
                    if (pointsTrend > 20) {
                        reasons.push('Exceptional recent form');
                    } else if (pointsTrend > 10) {
                        reasons.push('Improving form');
                    }
                    
                    // Add fixture-based reasoning (use base weights for comparison since fixtureBonus was calculated with phase weights)
                    if (player.fixtureBonus >= weights.easyFixtures) {
                        reasons.push('üü¢ Easy fixtures ahead');
                    } else if (player.fixtureBonus >= weights.favorableFixtures) {
                        reasons.push('üü¢ Favorable fixtures');
                    } else if (player.fixtureBonus <= weights.toughFixtures) {
                        reasons.push('‚ö†Ô∏è Tough fixtures - short-term caution');
                    }
                    
                    if (reasons.length === 0) {
                        reasons.push('Consistent performer');
                    }
                    
                    const reason = reasons.slice(0, 2).join(' ‚Ä¢ ');
                    
                    // Use reusable stats component
                    const keyStats = renderPlayerStats(player, position, 'card');
                    
                    // Use reusable fixture badge component
                    const fixtureBadge = renderFixtureBadge(player);
                    
                    html += `
                        <div class="player-rec-card">
                            <div class="player-rec-header">
                                <span class="player-rec-name">${player.name}</span>
                                <span class="player-rec-price">¬£${player.price.toFixed(1)}m</span>
                            </div>
                            <div class="player-rec-team">${player.team} ‚Ä¢ ${l5AvgMinutes.toFixed(0)}min avg</div>
                            <div class="player-rec-stats">
                                ${keyStats}
                            </div>
                            ${fixtureBadge}
                            <div class="rec-reason">
                                üí° ${reason}
                            </div>
                        </div>
                    `;
                });
            }
            
            html += '</div>';
            return html;
        }
        
        function generateFormPlayers(analyses) {
            const positionMap = { 1: 'GK', 2: 'DEF', 3: 'MID', 4: 'FWD' };
            const formSignals = [];
            const cfg = RECOMMENDATION_CONFIG; // Shorthand
            const fs = cfg.formSignals; // Form signals config
            
            // Analyze all players for form signals
            analyses.forEach(player => {
                const position = positionMap[player.position];
                
                // Skip players with no meaningful data
                if (player.l5.games < 3 || player.season.games < 5) return;
                
                let signal = 0;
                const reasons = [];
                
                // Calculate key metrics
                const l5AvgPoints = player.l5.points / player.l5.games;
                const seasonAvgPoints = player.season.points / player.season.games;
                const l5AvgMinutes = player.l5.minutes / player.l5.games;
                const l5xGIperGame = player.l5.xGI / player.l5.games;
                const ownership = player.selectedBy || 0;
                
                // 1. Form Improvement (30 points max)
                const pointsImprovement = ((l5AvgPoints - seasonAvgPoints) / seasonAvgPoints) * 100;
                if (pointsImprovement > fs.formSurge.threshold) {
                    signal += fs.formSurge.points;
                    reasons.push(`üî• Form surging (+${pointsImprovement.toFixed(0)}%)`);
                } else if (pointsImprovement > fs.formImproving.threshold) {
                    signal += fs.formImproving.points;
                    reasons.push(`üìà Form improving (+${pointsImprovement.toFixed(0)}%)`);
                } else if (l5AvgPoints >= fs.hotForm.threshold) {
                    signal += fs.hotForm.points;
                    reasons.push(`Hot form (${l5AvgPoints.toFixed(1)} pts/game)`);
                }
                
                // 2. xGI Quality (25 points max)
                if (position !== 'GK') {
                    if (l5xGIperGame >= fs.eliteXGI.threshold) {
                        signal += fs.eliteXGI.points;
                        reasons.push(`üíé Elite xGI (${l5xGIperGame.toFixed(2)}/game)`);
                    } else if (l5xGIperGame >= fs.strongXGI.threshold) {
                        signal += fs.strongXGI.points;
                        reasons.push(`‚ö° Strong xGI (${l5xGIperGame.toFixed(2)}/game)`);
                    } else if (l5xGIperGame >= fs.goodXGI.threshold) {
                        signal += fs.goodXGI.points;
                        reasons.push(`Good xGI (${l5xGIperGame.toFixed(2)}/game)`);
                    }
                } else {
                    // For GK, use clean sheets
                    const l5CS = player.l5.cleanSheets / player.l5.games;
                    if (l5CS >= cfg.gkThresholds.excellentCS) {
                        signal += fs.eliteXGI.points;
                        reasons.push(`üíé Excellent CS rate (${(l5CS * 100).toFixed(0)}%)`);
                    } else if (l5CS >= cfg.gkThresholds.strongCS) {
                        signal += fs.strongXGI.points;
                        reasons.push(`Strong CS rate (${(l5CS * 100).toFixed(0)}%)`);
                    }
                }
                
                // 3. Minutes Trend (15 points max)
                if (l5AvgMinutes >= fs.nailedOn.threshold) {
                    signal += fs.nailedOn.points;
                    reasons.push(`‚úÖ Nailed on (${l5AvgMinutes.toFixed(0)} mins)`);
                } else if (l5AvgMinutes >= fs.regularStarter.threshold) {
                    signal += fs.regularStarter.points;
                    reasons.push(`Regular starter (${l5AvgMinutes.toFixed(0)} mins)`);
                } else if (l5AvgMinutes >= fs.gettingMinutes.threshold) {
                    signal += fs.gettingMinutes.points;
                    reasons.push(`Getting minutes (${l5AvgMinutes.toFixed(0)} mins)`);
                }
                
                // 4. Ownership Sweet Spot (10 points max)
                if (ownership < fs.ultraDifferential.threshold && l5AvgPoints >= 3) {
                    signal += fs.ultraDifferential.points;
                    reasons.push(`üîì Ultra differential (${ownership.toFixed(1)}%)`);
                } else if (ownership < fs.lowOwned.threshold && l5AvgPoints >= 2) {
                    signal += fs.lowOwned.points;
                    reasons.push(`Low owned (${ownership.toFixed(1)}%)`);
                }
                
                // 5. Underperformance Bonus (10 points)
                const l5ActualGI = (player.l5.goals + player.l5.assists) / player.l5.games;
                const underperformance = l5xGIperGame - l5ActualGI;
                if (underperformance > fs.underperforming.xgiGap && l5xGIperGame > fs.underperforming.minXGI) {
                    signal += fs.underperforming.points;
                    reasons.push(`üìä Underperforming xGI - DUE`);
                }
                
                // 6. Value Score (10 points)
                const ptsPerMillion = l5AvgPoints / player.price;
                if (ptsPerMillion > fs.greatValue.threshold) {
                    signal += fs.greatValue.points;
                    reasons.push(`üí∞ Great value (${ptsPerMillion.toFixed(2)}/¬£m)`);
                } else if (ptsPerMillion > fs.goodValueForm.threshold) {
                    signal += fs.goodValueForm.points;
                    reasons.push(`Good value (${ptsPerMillion.toFixed(2)}/¬£m)`);
                }
                
                // 7. Fixture Difficulty (15 points max)
                if (player.fixtures && player.fixtures.avgFDR3) {
                    const fdr = player.fixtures.avgFDR3;
                    if (fdr < cfg.fdr.easy) {
                        signal += fs.easyFixturesForm.points;
                        reasons.push(`üü¢üü¢ Easy fixtures (FDR ${fdr.toFixed(1)})`);
                    } else if (fdr < cfg.fdr.favorable) {
                        signal += fs.goodFixturesForm.points;
                        reasons.push(`üü¢ Good fixtures (FDR ${fdr.toFixed(1)})`);
                    } else if (fdr > cfg.fdr.tough) {
                        signal += fs.toughFixturesForm.points;
                        reasons.push(`üî¥ Tough fixtures (FDR ${fdr.toFixed(1)})`);
                    }
                }
                
                // Only include if signal meets minimum threshold
                if (signal >= fs.minSignal && reasons.length > 0) {
                    formSignals.push({
                        ...player,
                        signal,
                        reasons,
                        position,
                        priority: signal >= fs.highPriority ? 'HIGH' : signal >= fs.mediumPriority ? 'MEDIUM' : 'WATCH',
                        l5AvgPoints,
                        l5AvgMinutes,
                        l5xGIperGame,
                        ownership
                    });
                }
            });
            
            // Sort by signal strength
            formSignals.sort((a, b) => b.signal - a.signal);
            
            // Take top N players
            const topSignals = formSignals.slice(0, cfg.display.maxFormPlayers);
            
            // Group by priority
            const highPriority = topSignals.filter(p => p.priority === 'HIGH');
            const mediumPriority = topSignals.filter(p => p.priority === 'MEDIUM');
            const watchList = topSignals.filter(p => p.priority === 'WATCH');
            
            let html = `
                <div style="margin-bottom: 25px; padding: 20px; background: var(--surface); border-left: 4px solid var(--accent-red); border-radius: 4px;">
                    <h2 style="color: var(--accent-red); margin-bottom: 12px; font-size: 18px; font-family: 'Space Mono', monospace;">
                        üî• FORM PLAYERS - Early Detection
                    </h2>
                    <p style="font-size: 12px; color: var(--text-dim); line-height: 1.6; margin-bottom: 10px;">
                        These players show <strong>early form signals</strong> based on improving stats, minutes consistency, and low ownership.
                        Act NOW before template managers catch on and prices rise. Perfect for transfers and wildcards.
                    </p>
                    <div style="display: flex; gap: 20px; margin-top: 15px; font-size: 11px;">
                        <span style="color: var(--accent-red);">üî• <strong>HIGH (${fs.highPriority}+)</strong> = Buy now</span>
                        <span style="color: var(--accent-yellow);">‚ö° <strong>MEDIUM (${fs.mediumPriority}-${fs.highPriority - 1})</strong> = Strong option</span>
                        <span style="color: var(--accent-blue);">üëÄ <strong>WATCH (${fs.minSignal}-${fs.mediumPriority - 1})</strong> = Monitor</span>
                    </div>
                </div>
            `;
            
            if (topSignals.length === 0) {
                html += '<div style="padding: 30px; text-align: center; color: var(--text-dim);">No strong form signals detected. Check back after next gameweek.</div>';
                return html;
            }
            
            // Helper to create player card
            function createFormPlayerCard(player, rank) {
                const priorityColor = player.priority === 'HIGH' ? 'var(--accent-red)' : 
                                    player.priority === 'MEDIUM' ? 'var(--accent-yellow)' : 'var(--accent-blue)';
                const priorityEmoji = player.priority === 'HIGH' ? 'üî•' : 
                                     player.priority === 'MEDIUM' ? '‚ö°' : 'üëÄ';
                
                // Use reusable components
                const statsGrid = renderPlayerStats(player, player.position, 'grid');
                const fixtureBadge = renderFixtureBadge(player);
                
                return `
                    <div style="background: var(--surface-light); border-left: 3px solid ${priorityColor}; padding: 15px; border-radius: 4px; margin-bottom: 12px;">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                            <div>
                                <div style="font-size: 14px; font-weight: 600; color: var(--text); margin-bottom: 4px;">
                                    #${rank} ${player.name}
                                </div>
                                <div style="font-size: 10px; color: var(--text-dim);">
                                    ${player.team} ‚Ä¢ ${player.position} ‚Ä¢ ${player.l5AvgMinutes.toFixed(0)}min avg
                                </div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 16px; font-weight: 700; color: ${priorityColor};">
                                    ${priorityEmoji} ${player.signal}
                                </div>
                                <div style="font-size: 9px; color: var(--text-dim); text-transform: uppercase;">
                                    ${player.priority}
                                </div>
                            </div>
                        </div>
                        
                        ${statsGrid}
                        
                        ${fixtureBadge ? `<div style="margin-bottom: 12px;">${fixtureBadge}</div>` : ''}
                        
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 9px; color: var(--text-dim); text-transform: uppercase; margin-bottom: 6px;">Why This Player:</div>
                            ${player.reasons.map(r => `<div style="font-size: 11px; color: var(--text); margin-bottom: 3px; padding-left: 8px; border-left: 2px solid ${priorityColor}; margin-left: 4px;">‚Ä¢ ${r}</div>`).join('')}
                        </div>
                        
                        <div style="padding: 8px 12px; background: linear-gradient(135deg, ${priorityColor} 0%, ${priorityColor}dd 100%); border-radius: 3px; text-align: center;">
                            <span style="font-size: 11px; color: white; font-weight: 600;">
                                ${player.priority === 'HIGH' ? 'üéØ BUY NOW before price rises' : 
                                  player.priority === 'MEDIUM' ? '‚ö° Strong transfer target' : 
                                  'üëÄ Monitor for next gameweek'}
                            </span>
                        </div>
                    </div>
                `;
            }
            
            // Render each priority group
            if (highPriority.length > 0) {
                html += `
                    <h3 style="color: var(--accent-red); margin: 25px 0 15px 0; font-size: 15px; font-weight: 600;">
                        üî• HIGH PRIORITY (Buy Now)
                    </h3>
                `;
                highPriority.forEach((player, i) => {
                    html += createFormPlayerCard(player, i + 1);
                });
            }
            
            if (mediumPriority.length > 0) {
                html += `
                    <h3 style="color: var(--accent-yellow); margin: 25px 0 15px 0; font-size: 15px; font-weight: 600;">
                        ‚ö° MEDIUM PRIORITY (Strong Options)
                    </h3>
                `;
                const offset = highPriority.length;
                mediumPriority.forEach((player, i) => {
                    html += createFormPlayerCard(player, offset + i + 1);
                });
            }
            
            if (watchList.length > 0) {
                html += `
                    <h3 style="color: var(--accent-blue); margin: 25px 0 15px 0; font-size: 15px; font-weight: 600;">
                        üëÄ WATCH LIST (Monitor Closely)
                    </h3>
                `;
                const offset = highPriority.length + mediumPriority.length;
                watchList.forEach((player, i) => {
                    html += createFormPlayerCard(player, offset + i + 1);
                });
            }
            
            return html;
        }

        // ============================================
        // CHARTS: Scatter Plots for Visual Analysis
        // ============================================
        
        let chartInstances = {}; // Store chart instances for cleanup
        
        function generateCharts(analyses) {
            const positionMap = { 1: 'GK', 2: 'DEF', 3: 'MID', 4: 'FWD' };
            const positionColors = {
                'GK': 'rgba(245, 158, 11, 0.8)',
                'DEF': 'rgba(59, 130, 246, 0.8)',
                'MID': 'rgba(16, 185, 129, 0.8)',
                'FWD': 'rgba(239, 68, 68, 0.8)'
            };
            
            // Filter valid players
            const validPlayers = analyses.filter(p => 
                p.l5 && p.l5.games >= 3 && p.season && p.season.games >= 5
            );
            
            let html = `
                <div style="padding: 20px;">
                    <div style="margin-bottom: 25px; padding: 20px; background: var(--surface); border-left: 4px solid var(--accent-blue); border-radius: 4px;">
                        <h2 style="color: var(--accent-blue); font-family: 'Space Mono', monospace; margin-bottom: 10px;">
                            üìä Visual Analysis
                        </h2>
                        <p style="font-size: 12px; color: var(--text-dim);">
                            Scatter plots to identify outliers: underperformers (below the line) are due for returns, 
                            overperformers (above the line) may regress. Hover over points for player details.
                        </p>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(500px, 1fr)); gap: 25px;">
                        <!-- Price vs Points Chart -->
                        <div style="background: var(--surface); padding: 20px; border-radius: 6px; border: 1px solid var(--border);">
                            <h3 style="color: var(--accent-green); font-size: 14px; margin-bottom: 15px;">
                                üí∞ Price vs Points/Game (L5)
                                <span style="font-size: 10px; color: var(--text-dim); font-weight: normal; margin-left: 10px;">Find value picks</span>
                            </h3>
                            <div style="position: relative; height: 400px;">
                                <canvas id="priceVsPointsChart"></canvas>
                            </div>
                            <div style="margin-top: 10px; font-size: 10px; color: var(--text-dim);">
                                <strong>Above diagonal</strong> = Great value | <strong>Below diagonal</strong> = Overpriced
                            </div>
                        </div>
                        
                        <!-- xGI vs Actual Returns Chart -->
                        <div style="background: var(--surface); padding: 20px; border-radius: 6px; border: 1px solid var(--border);">
                            <h3 style="color: var(--accent-yellow); font-size: 14px; margin-bottom: 15px;">
                                üéØ xGI vs Actual G+A (L5)
                                <span style="font-size: 10px; color: var(--text-dim); font-weight: normal; margin-left: 10px;">Find underperformers</span>
                            </h3>
                            <div style="position: relative; height: 400px;">
                                <canvas id="xgiVsActualChart"></canvas>
                            </div>
                            <div style="margin-top: 10px; font-size: 10px; color: var(--text-dim);">
                                <strong>Above line</strong> = Overperforming (may regress) | <strong>Below line</strong> = Due returns
                            </div>
                        </div>
                        
                        <!-- Ownership vs Form Chart -->
                        <div style="background: var(--surface); padding: 20px; border-radius: 6px; border: 1px solid var(--border);">
                            <h3 style="color: #a855f7; font-size: 14px; margin-bottom: 15px;">
                                üíé Ownership vs Form
                                <span style="font-size: 10px; color: var(--text-dim); font-weight: normal; margin-left: 10px;">Find differentials</span>
                            </h3>
                            <div style="position: relative; height: 400px;">
                                <canvas id="ownershipVsFormChart"></canvas>
                            </div>
                            <div style="margin-top: 10px; font-size: 10px; color: var(--text-dim);">
                                <strong>Top-left quadrant</strong> = Low owned + high form = DIFFERENTIALS
                            </div>
                        </div>
                        
                        <!-- Position Distribution -->
                        <div style="background: var(--surface); padding: 20px; border-radius: 6px; border: 1px solid var(--border);">
                            <h3 style="color: var(--accent-red); font-size: 14px; margin-bottom: 15px;">
                                üìà Points Distribution by Position
                                <span style="font-size: 10px; color: var(--text-dim); font-weight: normal; margin-left: 10px;">Where to invest?</span>
                            </h3>
                            <div style="position: relative; height: 400px;">
                                <canvas id="positionDistChart"></canvas>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Legend -->
                    <div style="margin-top: 20px; padding: 15px; background: var(--surface); border-radius: 6px; display: flex; gap: 20px; flex-wrap: wrap; justify-content: center;">
                        <span style="display: flex; align-items: center; gap: 6px; font-size: 11px;">
                            <span style="width: 12px; height: 12px; background: ${positionColors['GK']}; border-radius: 50%;"></span> GK
                        </span>
                        <span style="display: flex; align-items: center; gap: 6px; font-size: 11px;">
                            <span style="width: 12px; height: 12px; background: ${positionColors['DEF']}; border-radius: 50%;"></span> DEF
                        </span>
                        <span style="display: flex; align-items: center; gap: 6px; font-size: 11px;">
                            <span style="width: 12px; height: 12px; background: ${positionColors['MID']}; border-radius: 50%;"></span> MID
                        </span>
                        <span style="display: flex; align-items: center; gap: 6px; font-size: 11px;">
                            <span style="width: 12px; height: 12px; background: ${positionColors['FWD']}; border-radius: 50%;"></span> FWD
                        </span>
                    </div>
                </div>
            `;
            
            // Destroy existing charts
            Object.values(chartInstances).forEach(chart => chart?.destroy());
            chartInstances = {};
            
            // Schedule chart creation after DOM update
            setTimeout(() => {
                createScatterCharts(validPlayers, positionMap, positionColors);
            }, 100);
            
            return html;
        }
        
        function createScatterCharts(players, positionMap, positionColors) {
            const chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        backgroundColor: 'rgba(21, 25, 32, 0.95)',
                        titleColor: '#00ff88',
                        bodyColor: '#e0e5ed',
                        borderColor: '#2a3340',
                        borderWidth: 1,
                        padding: 12,
                        callbacks: {
                            label: function(context) {
                                const p = context.raw;
                                return [
                                    `${p.name} (${p.team})`,
                                    `Price: ¬£${p.price.toFixed(1)}m`,
                                    `Pts/G: ${p.ptsPerGame?.toFixed(1) || '-'}`,
                                    `xGI/G: ${p.xgiPerGame?.toFixed(2) || '-'}`
                                ];
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        grid: { color: 'rgba(42, 51, 64, 0.5)' },
                        ticks: { color: '#8b95a5', font: { size: 10 } }
                    },
                    y: {
                        grid: { color: 'rgba(42, 51, 64, 0.5)' },
                        ticks: { color: '#8b95a5', font: { size: 10 } }
                    }
                }
            };
            
            // 1. Price vs Points Chart
            const priceVsPointsData = players
                .filter(p => positionMap[p.position] !== 'GK')
                .map(p => ({
                    x: p.price,
                    y: p.l5.points / p.l5.games,
                    name: p.name,
                    team: p.team,
                    price: p.price,
                    ptsPerGame: p.l5.points / p.l5.games,
                    position: positionMap[p.position]
                }));
            
            const priceCtx = document.getElementById('priceVsPointsChart')?.getContext('2d');
            if (priceCtx) {
                chartInstances.priceVsPoints = new Chart(priceCtx, {
                    type: 'scatter',
                    data: {
                        datasets: ['DEF', 'MID', 'FWD'].map(pos => ({
                            label: pos,
                            data: priceVsPointsData.filter(p => p.position === pos),
                            backgroundColor: positionColors[pos],
                            borderColor: positionColors[pos].replace('0.8', '1'),
                            pointRadius: 6,
                            pointHoverRadius: 9
                        }))
                    },
                    options: {
                        ...chartOptions,
                        scales: {
                            ...chartOptions.scales,
                            x: { ...chartOptions.scales.x, title: { display: true, text: 'Price (¬£m)', color: '#8b95a5' } },
                            y: { ...chartOptions.scales.y, title: { display: true, text: 'Points/Game (L5)', color: '#8b95a5' } }
                        },
                        plugins: {
                            ...chartOptions.plugins,
                            annotation: {
                                annotations: {
                                    line1: {
                                        type: 'line',
                                        xMin: 4, yMin: 2,
                                        xMax: 14, yMax: 7,
                                        borderColor: 'rgba(0, 255, 136, 0.3)',
                                        borderWidth: 2,
                                        borderDash: [5, 5]
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // 2. xGI vs Actual G+A Chart
            const xgiVsActualData = players
                .filter(p => positionMap[p.position] !== 'GK')
                .map(p => ({
                    x: p.l5.xGI / p.l5.games,
                    y: (p.l5.goals + p.l5.assists) / p.l5.games,
                    name: p.name,
                    team: p.team,
                    price: p.price,
                    xgiPerGame: p.l5.xGI / p.l5.games,
                    actualGI: (p.l5.goals + p.l5.assists) / p.l5.games,
                    position: positionMap[p.position]
                }));
            
            const xgiCtx = document.getElementById('xgiVsActualChart')?.getContext('2d');
            if (xgiCtx) {
                chartInstances.xgiVsActual = new Chart(xgiCtx, {
                    type: 'scatter',
                    data: {
                        datasets: [
                            // Reference line (y = x)
                            {
                                label: 'Expected',
                                data: [{x: 0, y: 0}, {x: 1.5, y: 1.5}],
                                type: 'line',
                                borderColor: 'rgba(0, 255, 136, 0.4)',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                pointRadius: 0,
                                fill: false
                            },
                            ...['DEF', 'MID', 'FWD'].map(pos => ({
                                label: pos,
                                data: xgiVsActualData.filter(p => p.position === pos),
                                backgroundColor: positionColors[pos],
                                borderColor: positionColors[pos].replace('0.8', '1'),
                                pointRadius: 6,
                                pointHoverRadius: 9
                            }))
                        ]
                    },
                    options: {
                        ...chartOptions,
                        scales: {
                            ...chartOptions.scales,
                            x: { ...chartOptions.scales.x, title: { display: true, text: 'xGI per Game', color: '#8b95a5' }, min: 0 },
                            y: { ...chartOptions.scales.y, title: { display: true, text: 'Actual G+A per Game', color: '#8b95a5' }, min: 0 }
                        }
                    }
                });
            }
            
            // 3. Ownership vs Form Chart
            const ownershipVsFormData = players.map(p => ({
                x: p.selectedBy || 0,
                y: p.l5.points / p.l5.games,
                name: p.name,
                team: p.team,
                price: p.price,
                ptsPerGame: p.l5.points / p.l5.games,
                position: positionMap[p.position]
            }));
            
            const ownershipCtx = document.getElementById('ownershipVsFormChart')?.getContext('2d');
            if (ownershipCtx) {
                chartInstances.ownershipVsForm = new Chart(ownershipCtx, {
                    type: 'scatter',
                    data: {
                        datasets: ['GK', 'DEF', 'MID', 'FWD'].map(pos => ({
                            label: pos,
                            data: ownershipVsFormData.filter(p => p.position === pos),
                            backgroundColor: positionColors[pos],
                            borderColor: positionColors[pos].replace('0.8', '1'),
                            pointRadius: 5,
                            pointHoverRadius: 8
                        }))
                    },
                    options: {
                        ...chartOptions,
                        scales: {
                            ...chartOptions.scales,
                            x: { ...chartOptions.scales.x, title: { display: true, text: 'Ownership %', color: '#8b95a5' } },
                            y: { ...chartOptions.scales.y, title: { display: true, text: 'Points/Game (L5)', color: '#8b95a5' } }
                        }
                    }
                });
            }
            
            // 4. Position Distribution (Box-like visualization using bar chart)
            const positionStats = ['GK', 'DEF', 'MID', 'FWD'].map(pos => {
                const posPlayers = players.filter(p => positionMap[p.position] === pos);
                const points = posPlayers.map(p => p.l5.points / p.l5.games).sort((a, b) => a - b);
                
                return {
                    position: pos,
                    avg: points.reduce((a, b) => a + b, 0) / points.length || 0,
                    max: Math.max(...points) || 0,
                    top5Avg: points.slice(-5).reduce((a, b) => a + b, 0) / 5 || 0
                };
            });
            
            const distCtx = document.getElementById('positionDistChart')?.getContext('2d');
            if (distCtx) {
                chartInstances.positionDist = new Chart(distCtx, {
                    type: 'bar',
                    data: {
                        labels: ['GK', 'DEF', 'MID', 'FWD'],
                        datasets: [
                            {
                                label: 'Average',
                                data: positionStats.map(p => p.avg),
                                backgroundColor: 'rgba(139, 149, 165, 0.6)',
                                borderColor: 'rgba(139, 149, 165, 1)',
                                borderWidth: 1
                            },
                            {
                                label: 'Top 5 Average',
                                data: positionStats.map(p => p.top5Avg),
                                backgroundColor: 'rgba(0, 255, 136, 0.6)',
                                borderColor: 'rgba(0, 255, 136, 1)',
                                borderWidth: 1
                            },
                            {
                                label: 'Best Player',
                                data: positionStats.map(p => p.max),
                                backgroundColor: 'rgba(255, 204, 0, 0.6)',
                                borderColor: 'rgba(255, 204, 0, 1)',
                                borderWidth: 1
                            }
                        ]
                    },
                    options: {
                        ...chartOptions,
                        plugins: {
                            ...chartOptions.plugins,
                            legend: { 
                                display: true,
                                labels: { color: '#8b95a5', font: { size: 10 } }
                            }
                        },
                        scales: {
                            ...chartOptions.scales,
                            y: { ...chartOptions.scales.y, title: { display: true, text: 'Points/Game (L5)', color: '#8b95a5' } }
                        }
                    }
                });
            }
        }
        
        // ============================================
        // FIXTURE TICKER: Visual Team Fixture Display
        // ============================================
        
        function generateFixtureTicker(analyses) {
            // Get unique teams from analyses
            const teamData = {};
            analyses.forEach(p => {
                if (p.teamId && p.fixtures && !teamData[p.teamId]) {
                    teamData[p.teamId] = {
                        id: p.teamId,
                        name: p.team,
                        fixtures: p.fixtures
                    };
                }
            });
            
            // Sort by average FDR (easiest first)
            const sortedTeams = Object.values(teamData)
                .filter(t => t.fixtures && t.fixtures.next5)
                .sort((a, b) => (a.fixtures.avgFDR5 || 5) - (b.fixtures.avgFDR5 || 5));
            
            const getFDRColor = (fdr) => {
                if (fdr <= 2) return '#10b981'; // Very easy - bright green
                if (fdr <= 2.5) return '#22c55e'; // Easy - green
                if (fdr <= 3) return '#84cc16'; // Fairly easy - lime
                if (fdr <= 3.5) return '#f59e0b'; // Medium - amber
                if (fdr <= 4) return '#ef4444'; // Hard - red
                return '#991b1b'; // Very hard - dark red
            };
            
            const getFDRLabel = (fdr) => {
                if (fdr <= 2) return 'Very Easy';
                if (fdr <= 2.5) return 'Easy';
                if (fdr <= 3) return 'Medium';
                if (fdr <= 3.5) return 'Tricky';
                if (fdr <= 4) return 'Hard';
                return 'Very Hard';
            };
            
            let html = `
                <div style="padding: 20px;">
                    <div style="margin-bottom: 25px; padding: 20px; background: var(--surface); border-left: 4px solid var(--accent-yellow); border-radius: 4px;">
                        <h2 style="color: var(--accent-yellow); font-family: 'Space Mono', monospace; margin-bottom: 10px;">
                            üìÖ Fixture Ticker - Next 5 Gameweeks
                        </h2>
                        <p style="font-size: 12px; color: var(--text-dim);">
                            Teams sorted by fixture difficulty (easiest first). Target players from teams with green runs.
                            <strong>H</strong> = Home, <strong>A</strong> = Away
                        </p>
                    </div>
                    
                    <!-- FDR Legend -->
                    <div style="display: flex; gap: 15px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center; padding: 15px; background: var(--surface); border-radius: 6px;">
                        <span style="font-size: 11px; color: var(--text-dim);">FDR Scale:</span>
                        ${[1, 2, 2.5, 3, 3.5, 4, 5].map(fdr => `
                            <span style="display: flex; align-items: center; gap: 4px; font-size: 10px;">
                                <span style="width: 20px; height: 20px; background: ${getFDRColor(fdr)}; border-radius: 3px;"></span>
                                ${fdr <= 2 ? '1-2' : fdr <= 2.5 ? '2-2.5' : fdr <= 3 ? '2.5-3' : fdr <= 3.5 ? '3-3.5' : fdr <= 4 ? '3.5-4' : '4-5'}
                            </span>
                        `).join('')}
                    </div>
                    
                    <!-- Fixture Table -->
                    <div style="background: var(--surface); border-radius: 6px; overflow: hidden; border: 1px solid var(--border);">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="background: var(--surface-light);">
                                    <th style="padding: 12px 15px; text-align: left; color: var(--accent-green); font-size: 11px; border-bottom: 2px solid var(--accent-green);">Team</th>
                                    <th style="padding: 12px; text-align: center; color: var(--text-dim); font-size: 10px; border-bottom: 2px solid var(--accent-green);">GW+1</th>
                                    <th style="padding: 12px; text-align: center; color: var(--text-dim); font-size: 10px; border-bottom: 2px solid var(--accent-green);">GW+2</th>
                                    <th style="padding: 12px; text-align: center; color: var(--text-dim); font-size: 10px; border-bottom: 2px solid var(--accent-green);">GW+3</th>
                                    <th style="padding: 12px; text-align: center; color: var(--text-dim); font-size: 10px; border-bottom: 2px solid var(--accent-green);">GW+4</th>
                                    <th style="padding: 12px; text-align: center; color: var(--text-dim); font-size: 10px; border-bottom: 2px solid var(--accent-green);">GW+5</th>
                                    <th style="padding: 12px 15px; text-align: center; color: var(--accent-yellow); font-size: 10px; border-bottom: 2px solid var(--accent-green);">Avg FDR</th>
                                </tr>
                            </thead>
                            <tbody>
            `;
            
            sortedTeams.forEach((team, index) => {
                const fixtures = team.fixtures.next5 || [];
                const avgFDR = team.fixtures.avgFDR5 || 3;
                const rowBg = index % 2 === 0 ? 'var(--surface)' : 'var(--surface-light)';
                
                html += `
                    <tr style="background: ${rowBg};">
                        <td style="padding: 10px 15px; font-weight: 600; color: var(--text); font-size: 12px; border-bottom: 1px solid var(--border);">
                            ${team.name}
                            <span style="font-size: 9px; color: var(--text-dim); margin-left: 6px;">#${index + 1}</span>
                        </td>
                `;
                
                // Render 5 fixtures
                for (let i = 0; i < 5; i++) {
                    const fixture = fixtures[i];
                    if (fixture) {
                        const opponentTeam = teams[fixture.opponent];
                        const opponentName = opponentTeam ? opponentTeam.short_name : 'UNK';
                        const isHome = fixture.is_home;
                        const fdr = fixture.difficulty;
                        const bgColor = getFDRColor(fdr);
                        const textColor = fdr <= 3 ? '#000' : '#fff';
                        
                        html += `
                            <td style="padding: 6px; text-align: center; border-bottom: 1px solid var(--border);">
                                <div style="background: ${bgColor}; color: ${textColor}; padding: 8px 4px; border-radius: 4px; font-size: 10px; font-weight: 600;">
                                    ${opponentName}
                                    <div style="font-size: 8px; opacity: 0.8; margin-top: 2px;">${isHome ? 'H' : 'A'}</div>
                                </div>
                            </td>
                        `;
                    } else {
                        html += `
                            <td style="padding: 6px; text-align: center; border-bottom: 1px solid var(--border);">
                                <div style="background: var(--bg-dark); color: var(--text-dim); padding: 8px 4px; border-radius: 4px; font-size: 10px;">
                                    -
                                </div>
                            </td>
                        `;
                    }
                }
                
                // Average FDR
                const avgColor = getFDRColor(avgFDR);
                html += `
                        <td style="padding: 10px 15px; text-align: center; border-bottom: 1px solid var(--border);">
                            <div style="display: inline-block; background: ${avgColor}; color: ${avgFDR <= 3 ? '#000' : '#fff'}; padding: 6px 12px; border-radius: 15px; font-size: 11px; font-weight: 600;">
                                ${avgFDR.toFixed(2)}
                            </div>
                            <div style="font-size: 8px; color: var(--text-dim); margin-top: 4px;">${getFDRLabel(avgFDR)}</div>
                        </td>
                    </tr>
                `;
            });
            
            html += `
                            </tbody>
                        </table>
                    </div>
                    
                    <!-- Quick Summary Cards -->
                    <div style="margin-top: 25px; display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                        <div style="background: var(--surface); padding: 20px; border-radius: 6px; border-left: 4px solid var(--accent-green);">
                            <h4 style="color: var(--accent-green); font-size: 12px; margin-bottom: 10px;">üü¢ Easiest Runs (Next 5)</h4>
                            <div style="font-size: 11px; color: var(--text);">
                                ${sortedTeams.slice(0, 5).map((t, i) => `
                                    <div style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid var(--border);">
                                        <span>${i + 1}. ${t.name}</span>
                                        <span style="color: var(--accent-green);">${t.fixtures.avgFDR5.toFixed(2)}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        
                        <div style="background: var(--surface); padding: 20px; border-radius: 6px; border-left: 4px solid var(--accent-red);">
                            <h4 style="color: var(--accent-red); font-size: 12px; margin-bottom: 10px;">üî¥ Toughest Runs (Next 5)</h4>
                            <div style="font-size: 11px; color: var(--text);">
                                ${sortedTeams.slice(-5).reverse().map((t, i) => `
                                    <div style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid var(--border);">
                                        <span>${i + 1}. ${t.name}</span>
                                        <span style="color: var(--accent-red);">${t.fixtures.avgFDR5.toFixed(2)}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        
                        <div style="background: var(--surface); padding: 20px; border-radius: 6px; border-left: 4px solid var(--accent-yellow);">
                            <h4 style="color: var(--accent-yellow); font-size: 12px; margin-bottom: 10px;">‚ö° Fixture Swing (Improving)</h4>
                            <div style="font-size: 10px; color: var(--text-dim); margin-bottom: 8px;">Teams whose fixtures get easier</div>
                            <div style="font-size: 11px; color: var(--text);">
                                ${sortedTeams
                                    .filter(t => t.fixtures.next5 && t.fixtures.next5.length >= 5)
                                    .map(t => {
                                        const first2 = t.fixtures.next5.slice(0, 2).reduce((a, f) => a + f.difficulty, 0) / 2;
                                        const last2 = t.fixtures.next5.slice(3, 5).reduce((a, f) => a + f.difficulty, 0) / 2;
                                        return { ...t, swing: first2 - last2 };
                                    })
                                    .sort((a, b) => b.swing - a.swing)
                                    .slice(0, 5)
                                    .map((t, i) => `
                                        <div style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid var(--border);">
                                            <span>${i + 1}. ${t.name}</span>
                                            <span style="color: ${t.swing > 0 ? 'var(--accent-green)' : 'var(--accent-red)'};">
                                                ${t.swing > 0 ? '‚Üó' : '‚Üò'} ${Math.abs(t.swing).toFixed(1)}
                                            </span>
                                        </div>
                                    `).join('')}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            return html;
        }

        // ============================================
        // NEW FEATURES: Presets, Search, Export, Sparklines
        // ============================================

        let currentPosition = null; // Track current tab
        let activeAdvancedFilters = {
            fdr: null,
            price: null,
            ownership: null,
            priceRange: null,
            ownershipRange: null
        };

        // Global Search across all players
        function globalSearch() {
            const searchTerm = document.getElementById('globalSearch').value.toLowerCase();
            if (!currentPosition) return;
            
            const table = document.getElementById(`table-${currentPosition}`);
            if (!table) return;
            
            const tbody = table.querySelector('tbody');
            const rows = tbody.querySelectorAll('tr');
            
            rows.forEach(row => {
                const playerName = row.cells[0]?.textContent.toLowerCase() || '';
                const teamName = row.cells[1]?.textContent.toLowerCase() || '';
                
                if (playerName.includes(searchTerm) || teamName.includes(searchTerm)) {
                    row.style.display = '';
                } else {
                    row.style.display = 'none';
                }
            });
        }

        // Apply Preset Filters
        function applyPreset(presetType) {
            if (!currentPosition || ['RECOMMENDATIONS', 'FORM'].includes(currentPosition)) {
                alert('Please select a position tab (GK/DEF/MID/FWD) to use presets');
                return;
            }
            
            const table = document.getElementById(`table-${currentPosition}`);
            if (!table) return;
            
            // Clear all filters first
            const filterInputs = table.querySelectorAll('.filter-input');
            filterInputs.forEach(input => input.value = '');
            
            if (presetType === 'clear') {
                // Show all rows
                const tbody = table.querySelector('tbody');
                const rows = tbody.querySelectorAll('tr');
                rows.forEach(row => row.style.display = '');
                
                // Clear advanced filters too
                clearAdvancedFilters();
                return;
            }
            
            // Get column indices (varies by position)
            const headers = Array.from(table.querySelectorAll('thead tr:first-child th'));
            const getColIndex = (label) => {
                const index = headers.findIndex(h => h.textContent.includes(label));
                return index;
            };
            
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            // Define price column based on whether Price column exists
            const hasPriceCol = headers.some(h => h.textContent.includes('Price'));
            
            // Apply preset logic
            rows.forEach(row => {
                let show = true;
                const cells = row.cells;
                
                if (presetType === 'budget-enablers') {
                    // Minutes (L5) >=75 - removed price filter since it's not in table
                    const minsL5Idx = headers.findIndex(h => h.textContent.includes('Mins') && h.textContent.includes('L5'));
                    const minsL5 = parseFloat(cells[minsL5Idx]?.textContent || 0);
                    show = minsL5 >= 75;
                    
                } else if (presetType === 'form-players') {
                    // Pts (L5) >=5, Minutes (L5) >=60
                    const ptsL5Idx = headers.findIndex(h => h.textContent.includes('Pts') && h.textContent.includes('L5'));
                    const minsL5Idx = headers.findIndex(h => h.textContent.includes('Mins') && h.textContent.includes('L5'));
                    
                    const ptsL5 = parseFloat(cells[ptsL5Idx]?.textContent || 0);
                    const minsL5 = parseFloat(cells[minsL5Idx]?.textContent || 0);
                    
                    show = ptsL5 >= 5 && minsL5 >= 60;
                    
                } else if (presetType === 'nailed-starters') {
                    // Minutes (L5) >=80
                    const minsL5Idx = headers.findIndex(h => h.textContent.includes('Mins') && h.textContent.includes('L5'));
                    const minsL5 = parseFloat(cells[minsL5Idx]?.textContent || 0);
                    show = minsL5 >= 80;
                    
                } else if (presetType === 'value-picks') {
                    // Pts (L5) >=4, Minutes (L5) >=70
                    const ptsL5Idx = headers.findIndex(h => h.textContent.includes('Pts') && h.textContent.includes('L5'));
                    const minsL5Idx = headers.findIndex(h => h.textContent.includes('Mins') && h.textContent.includes('L5'));
                    
                    const ptsL5 = parseFloat(cells[ptsL5Idx]?.textContent || 0);
                    const minsL5 = parseFloat(cells[minsL5Idx]?.textContent || 0);
                    
                    show = ptsL5 >= 4 && minsL5 >= 70;
                    
                } else if (presetType === 'easy-fixtures') {
                    // FDR <3.0
                    const fdrIdx = getColIndex('FDR');
                    if (fdrIdx !== -1) {
                        const fdrText = cells[fdrIdx]?.textContent || '';
                        const fdr = parseFloat(fdrText.replace(/[^\d.]/g, ''));
                        show = !isNaN(fdr) && fdr < 3.0;
                    }
                }
                
                row.style.display = show ? '' : 'none';
            });
        }

        // Apply Advanced Filters (FDR, Price presets, Ownership presets)
        function applyAdvancedFilter(filterType, filterValue) {
            if (!currentPosition || ['RECOMMENDATIONS', 'FORM'].includes(currentPosition)) {
                alert('Please select a position tab (GK/DEF/MID/FWD) to use filters');
                return;
            }
            
            // Find the parent filter group of the clicked button
            const clickedBtn = event.target;
            const filterGroup = clickedBtn.closest('.filter-group');
            
            // Toggle filter (click again to deactivate)
            if (activeAdvancedFilters[filterType] === filterValue) {
                activeAdvancedFilters[filterType] = null;
                clickedBtn.classList.remove('active');
            } else {
                activeAdvancedFilters[filterType] = filterValue;
                // Remove active class only from chips in the SAME filter group
                if (filterGroup) {
                    filterGroup.querySelectorAll('.filter-chip').forEach(btn => btn.classList.remove('active'));
                }
                clickedBtn.classList.add('active');
                
                // Clear custom range input if using preset for same type
                if (filterType === 'price') {
                    document.getElementById('priceMin').value = '';
                    document.getElementById('priceMax').value = '';
                    activeAdvancedFilters.priceRange = null;
                } else if (filterType === 'ownership') {
                    document.getElementById('ownershipMin').value = '';
                    document.getElementById('ownershipMax').value = '';
                    activeAdvancedFilters.ownershipRange = null;
                }
            }
            
            applyAllAdvancedFilters();
        }

        // Apply custom price range filter
        function applyCustomPriceFilter() {
            const minPrice = parseFloat(document.getElementById('priceMin').value);
            const maxPrice = parseFloat(document.getElementById('priceMax').value);
            
            if (!isNaN(minPrice) || !isNaN(maxPrice)) {
                activeAdvancedFilters.priceRange = {
                    min: isNaN(minPrice) ? 0 : minPrice,
                    max: isNaN(maxPrice) ? 999 : maxPrice
                };
                activeAdvancedFilters.price = null; // Clear preset
                // Only clear price filter chips (in the same filter group)
                const priceGroup = document.getElementById('priceMin').closest('.filter-group');
                if (priceGroup) {
                    priceGroup.querySelectorAll('.filter-chip').forEach(btn => btn.classList.remove('active'));
                }
            }
            
            applyAllAdvancedFilters();
        }

        // Apply custom ownership range filter
        function applyCustomOwnershipFilter() {
            const minOwnership = parseFloat(document.getElementById('ownershipMin').value);
            const maxOwnership = parseFloat(document.getElementById('ownershipMax').value);
            
            if (!isNaN(minOwnership) || !isNaN(maxOwnership)) {
                activeAdvancedFilters.ownershipRange = {
                    min: isNaN(minOwnership) ? 0 : minOwnership,
                    max: isNaN(maxOwnership) ? 999 : maxOwnership
                };
                activeAdvancedFilters.ownership = null; // Clear preset
                // Only clear ownership filter chips (in the same filter group)
                const ownershipGroup = document.getElementById('ownershipMin').closest('.filter-group');
                if (ownershipGroup) {
                    ownershipGroup.querySelectorAll('.filter-chip').forEach(btn => btn.classList.remove('active'));
                }
            }
            
            applyAllAdvancedFilters();
        }

        // Apply all active advanced filters
        function applyAllAdvancedFilters() {
            if (!currentPosition) return;
            
            const table = document.getElementById(`table-${currentPosition}`);
            if (!table) return;
            
            const headers = Array.from(table.querySelectorAll('thead tr:first-child th'));
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            // Helper to get column index
            const getColIndex = (label) => headers.findIndex(h => h.textContent.includes(label));
            
            rows.forEach(row => {
                let show = true;
                const cells = row.cells;
                
                // FDR Filter
                if (activeAdvancedFilters.fdr) {
                    const fdrIdx = getColIndex('FDR');
                    if (fdrIdx !== -1) {
                        const fdrText = cells[fdrIdx]?.textContent || '';
                        const fdr = parseFloat(fdrText.replace(/[^\d.]/g, ''));
                        
                        if (!isNaN(fdr)) {
                            if (activeAdvancedFilters.fdr === 'easy' && fdr >= 2.6) show = false;
                            if (activeAdvancedFilters.fdr === 'favorable' && (fdr < 2.6 || fdr >= 2.9)) show = false;
                            if (activeAdvancedFilters.fdr === 'neutral' && (fdr < 2.9 || fdr >= 3.1)) show = false;
                            if (activeAdvancedFilters.fdr === 'tough' && fdr <= 3.4) show = false;
                        }
                    }
                }
                
                // Price Filter (presets)
                if (activeAdvancedFilters.price) {
                    const priceIdx = getColIndex('Price');
                    if (priceIdx !== -1) {
                        const priceText = cells[priceIdx]?.textContent || '';
                        const price = parseFloat(priceText.replace(/[¬£,]/g, ''));
                        
                        if (!isNaN(price)) {
                            if (activeAdvancedFilters.price === 'budget' && price > 5.5) show = false;
                            if (activeAdvancedFilters.price === 'mid' && (price < 5.5 || price > 8.0)) show = false;
                            if (activeAdvancedFilters.price === 'premium' && price <= 8.0) show = false;
                        }
                    }
                }
                
                // Price Range Filter
                if (activeAdvancedFilters.priceRange) {
                    const priceIdx = getColIndex('Price');
                    if (priceIdx !== -1) {
                        const priceText = cells[priceIdx]?.textContent || '';
                        const price = parseFloat(priceText.replace(/[¬£,]/g, ''));
                        
                        if (!isNaN(price)) {
                            if (price < activeAdvancedFilters.priceRange.min || price > activeAdvancedFilters.priceRange.max) {
                                show = false;
                            }
                        }
                    }
                }
                
                // Ownership Filter (presets)
                if (activeAdvancedFilters.ownership) {
                    const ownIdx = getColIndex('Own%');
                    if (ownIdx !== -1) {
                        const ownText = cells[ownIdx]?.textContent || '';
                        const ownership = parseFloat(ownText.replace(/[%,]/g, ''));
                        
                        if (!isNaN(ownership)) {
                            if (activeAdvancedFilters.ownership === 'template' && ownership <= 20) show = false;
                            if (activeAdvancedFilters.ownership === 'popular' && (ownership < 10 || ownership > 20)) show = false;
                            if (activeAdvancedFilters.ownership === 'differential' && ownership >= 10) show = false;
                            if (activeAdvancedFilters.ownership === 'unique' && ownership >= 5) show = false;
                        }
                    }
                }
                
                // Ownership Range Filter
                if (activeAdvancedFilters.ownershipRange) {
                    const ownIdx = getColIndex('Own%');
                    if (ownIdx !== -1) {
                        const ownText = cells[ownIdx]?.textContent || '';
                        const ownership = parseFloat(ownText.replace(/[%,]/g, ''));
                        
                        if (!isNaN(ownership)) {
                            if (ownership < activeAdvancedFilters.ownershipRange.min || ownership > activeAdvancedFilters.ownershipRange.max) {
                                show = false;
                            }
                        }
                    }
                }
                
                row.style.display = show ? '' : 'none';
            });
        }

        // Clear all advanced filters
        function clearAdvancedFilters() {
            activeAdvancedFilters = {
                fdr: null,
                price: null,
                ownership: null,
                priceRange: null,
                ownershipRange: null
            };
            
            // Clear input fields
            document.getElementById('priceMin').value = '';
            document.getElementById('priceMax').value = '';
            document.getElementById('ownershipMin').value = '';
            document.getElementById('ownershipMax').value = '';
            
            // Remove active classes
            document.querySelectorAll('.filter-chip').forEach(btn => btn.classList.remove('active'));
            
            // Show all rows
            if (currentPosition) {
                const table = document.getElementById(`table-${currentPosition}`);
                if (table) {
                    const tbody = table.querySelector('tbody');
                    const rows = tbody.querySelectorAll('tr');
                    rows.forEach(row => row.style.display = '');
                }
            }
        }

        // Export Table to CSV
        function exportToCSV() {
            if (!currentPosition || ['RECOMMENDATIONS', 'FORM'].includes(currentPosition)) {
                alert('Please select a position tab (GK/DEF/MID/FWD) to export');
                return;
            }
            
            const table = document.getElementById(`table-${currentPosition}`);
            if (!table) return;
            
            const rows = [];
            
            // Get headers
            const headerRow = table.querySelectorAll('thead tr:first-child th');
            const headers = Array.from(headerRow).map(th => {
                const text = th.textContent.replace(/‚áÖ/g, '').trim();
                return text;
            });
            rows.push(headers.join(','));
            
            // Get data rows (only visible ones)
            const dataRows = table.querySelectorAll('tbody tr');
            dataRows.forEach(row => {
                if (row.style.display === 'none') return; // Skip hidden rows
                
                const cells = Array.from(row.cells).map(td => {
                    let text = td.textContent.trim();
                    // Clean up emoji and special chars for CSV
                    text = text.replace(/[üü¢üü°üî¥üü†]/g, '');
                    // Escape commas
                    if (text.includes(',')) text = `"${text}"`;
                    return text;
                });
                rows.push(cells.join(','));
            });
            
            // Create CSV file
            const csv = rows.join('\n');
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            
            // Download
            const a = document.createElement('a');
            a.href = url;
            a.download = `fpl-${currentPosition.toLowerCase()}-${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Tab switching - show/hide preset filters
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('tab')) {
                const position = e.target.dataset.position;
                currentPosition = position;
                
                const presetFilters = document.getElementById('presetFilters');
                const advancedFilters = document.getElementById('advancedFilters');
                
                // Show filters only for position tabs (not recommendations/form)
                if (['GK', 'DEF', 'MID', 'FWD'].includes(position)) {
                    presetFilters.style.display = 'flex';
                    advancedFilters.style.display = 'flex';
                    
                    // Clear global search
                    document.getElementById('globalSearch').value = '';
                    
                    // Clear advanced filters
                    clearAdvancedFilters();
                } else {
                    presetFilters.style.display = 'none';
                    advancedFilters.style.display = 'none';
                }
            }
        });

        // Auto-load on page load and show cache info
        window.addEventListener('load', () => {
            showCacheInfo();
            loadData(); // Will use cache if available
        });
    </script>
</body>
</html>