<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPL Players Analysis</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Space+Grotesk:wght@500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        /* ========================================
           DESIGN SYSTEM TOKENS
           ======================================== */
        :root {
            /* Surfaces (GitHub-inspired tinted scale) */
            --surface-background: #0A0E14;
            --surface-0: #0D1117;
            --surface-1: #161B22;
            --surface-2: #1C2128;
            --surface-3: #21262D;
            --surface-4: #30363D;
            
            /* Legacy mappings for JS compatibility */
            --bg-dark: #0A0E14;
            --bg-darker: #0D1117;
            --surface: #161B22;
            --surface-light: #1C2128;
            
            /* Text hierarchy (opacity-based) */
            --text-primary: rgba(255, 255, 255, 0.87);
            --text-secondary: rgba(255, 255, 255, 0.60);
            --text-muted: rgba(255, 255, 255, 0.45);
            --text-disabled: rgba(255, 255, 255, 0.38);
            --text: rgba(255, 255, 255, 0.87);
            --text-dim: rgba(255, 255, 255, 0.60);
            
            /* Borders */
            --border-subtle: rgba(255, 255, 255, 0.06);
            --border-default: rgba(255, 255, 255, 0.10);
            --border-emphasis: rgba(255, 255, 255, 0.16);
            --border: rgba(255, 255, 255, 0.10);
            
            /* Semantic states */
            --color-success: #4ADE80;
            --color-error: #F87171;
            --color-warning: #FBBF24;
            --color-info: #60A5FA;
            
            /* Legacy mappings */
            --accent-green: #4ADE80;
            --accent-red: #F87171;
            --accent-yellow: #FBBF24;
            --accent-blue: #60A5FA;
            
            /* FDR Scale (5 tiers) */
            --fdr-1: #4ADE80;
            --fdr-2: #86EFAC;
            --fdr-3: #A3A3A3;
            --fdr-4: #FB923C;
            --fdr-5: #EF4444;
            
            /* Position badges */
            --position-gk: #FCD34D;
            --position-def: #34D399;
            --position-mid: #60A5FA;
            --position-fwd: #F87171;
            
            /* Typography */
            --font-display: 'Space Grotesk', system-ui, sans-serif;
            --font-body: 'Inter', system-ui, sans-serif;
            --font-mono: 'JetBrains Mono', 'SF Mono', Consolas, monospace;
            
            /* Type scale */
            --text-xs: 0.75rem;
            --text-sm: 0.875rem;
            --text-base: 1rem;
            --text-lg: 1.125rem;
            --text-xl: 1.25rem;
            --text-2xl: 1.5rem;
            
            /* Spacing (8px grid) */
            --space-1: 0.25rem;
            --space-2: 0.5rem;
            --space-3: 0.75rem;
            --space-4: 1rem;
            --space-6: 1.5rem;
            --space-8: 2rem;
            --space-12: 3rem;
            
            /* Radii */
            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 12px;
            --radius-full: 9999px;
            
            /* Transitions */
            --transition-fast: 100ms ease-out;
            --transition-normal: 200ms ease-out;
            --transition-slow: 300ms ease-out;
        }
        
        /* ========================================
           RESET & BASE
           ======================================== */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        html {
            font-size: 16px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        body {
            background: var(--surface-background);
            color: var(--text-primary);
            font-family: var(--font-body);
            font-size: var(--text-sm);
            line-height: 1.5;
            overflow-x: hidden;
        }
        
        /* ========================================
           HEADER
           ======================================== */
        .header {
            background: var(--surface-0);
            border-bottom: 1px solid var(--color-success);
            padding: var(--space-6) var(--space-8);
            position: sticky;
            top: 0;
            z-index: 1000;
        }
        
        .header h1 {
            font-family: var(--font-display);
            font-size: var(--text-2xl);
            font-weight: 700;
            color: var(--color-success);
            letter-spacing: -0.01em;
            margin-bottom: var(--space-1);
        }
        
        .header p {
            color: var(--text-secondary);
            font-size: var(--text-xs);
        }
        
        /* ========================================
           BACK BUTTON
           ======================================== */
        .back-button {
            position: fixed;
            top: var(--space-4);
            left: var(--space-4);
            display: inline-flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-4);
            background: var(--surface-1);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-md);
            color: var(--text-secondary);
            font-family: var(--font-body);
            font-size: var(--text-xs);
            text-decoration: none;
            z-index: 10000;
            transition: all var(--transition-normal);
        }
        
        .back-button:hover {
            border-color: var(--color-success);
            color: var(--color-success);
            transform: translateX(-2px);
        }
        
        /* ========================================
           CONTROLS
           ======================================== */
        .controls {
            background: var(--surface-1);
            padding: var(--space-3) var(--space-6);
            border-bottom: 1px solid var(--border-default);
            display: flex;
            gap: var(--space-4);
            align-items: center;
            flex-wrap: wrap;
        }
        
        .btn {
            display: inline-flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-4);
            background: var(--color-success);
            color: var(--surface-background);
            border: none;
            border-radius: var(--radius-md);
            font-family: var(--font-display);
            font-size: var(--text-xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            cursor: pointer;
            transition: all var(--transition-normal);
        }
        
        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(74, 222, 128, 0.3);
        }
        
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .status {
            display: inline-flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-4);
            background: var(--surface-2);
            border-radius: var(--radius-md);
            border-left: 3px solid var(--color-info);
            font-size: var(--text-xs);
            color: var(--text-secondary);
        }
        
        .status.loading { border-left-color: var(--color-warning); animation: pulse 1.5s ease-in-out infinite; }
        .status.success { border-left-color: var(--color-success); }
        .status.error { border-left-color: var(--color-error); }
        
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        /* ========================================
           TABS
           ======================================== */
        .tabs {
            display: flex;
            background: var(--surface-0);
            padding: 0 var(--space-6);
            border-bottom: 1px solid var(--border-default);
            overflow-x: auto;
        }
        
        .tab {
            padding: var(--space-3) var(--space-6);
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            color: var(--text-secondary);
            font-family: var(--font-body);
            font-size: var(--text-xs);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: all var(--transition-normal);
            white-space: nowrap;
        }
        
        .tab:hover { color: var(--text-primary); background: var(--surface-1); }
        .tab.active { color: var(--color-success); border-bottom-color: var(--color-success); background: var(--surface-1); }
        
        /* ========================================
           PRESET FILTERS
           ======================================== */
        .preset-filters {
            background: var(--surface-1);
            padding: var(--space-3) var(--space-6);
            border-bottom: 1px solid var(--border-default);
            display: flex;
            gap: var(--space-3);
            align-items: center;
            flex-wrap: wrap;
        }
        
        .preset-btn {
            padding: var(--space-2) var(--space-3);
            background: var(--surface-2);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-md);
            color: var(--text-secondary);
            font-family: var(--font-body);
            font-size: var(--text-xs);
            cursor: pointer;
            transition: all var(--transition-normal);
        }
        
        .preset-btn:hover { border-color: var(--color-success); color: var(--color-success); }
        .preset-btn.active { background: var(--color-success); border-color: var(--color-success); color: var(--surface-background); }
        
        .global-search {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: var(--space-3);
        }
        
        .global-search input {
            background: var(--surface-0);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-md);
            color: var(--text-primary);
            font-family: var(--font-body);
            font-size: var(--text-xs);
            padding: var(--space-2) var(--space-3);
            min-width: 200px;
            outline: none;
            transition: all var(--transition-normal);
        }
        
        .global-search input:focus { border-color: var(--color-success); box-shadow: 0 0 0 3px rgba(74, 222, 128, 0.1); }
        
        .export-btn {
            padding: var(--space-2) var(--space-3);
            background: var(--color-info);
            border: none;
            border-radius: var(--radius-md);
            color: var(--surface-background);
            font-family: var(--font-body);
            font-size: var(--text-xs);
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-normal);
        }
        
        .export-btn:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(96, 165, 250, 0.3); }
        
        /* ========================================
           ADVANCED FILTERS
           ======================================== */
        .advanced-filters {
            background: var(--surface-2);
            padding: var(--space-4) var(--space-6);
            border-bottom: 1px solid var(--border-default);
            display: flex;
            flex-direction: column;
            gap: var(--space-3);
        }
        
        .filter-group {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            flex-wrap: wrap;
        }
        
        .filter-chip {
            padding: var(--space-1) var(--space-3);
            background: var(--surface-0);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-full);
            color: var(--text-secondary);
            font-family: var(--font-body);
            font-size: var(--text-xs);
            cursor: pointer;
            transition: all var(--transition-normal);
        }
        
        .filter-chip:hover { border-color: var(--color-success); color: var(--color-success); }
        .filter-chip.active { background: var(--color-success); border-color: var(--color-success); color: var(--surface-background); font-weight: 600; }
        
        .filter-apply-btn {
            padding: var(--space-1) var(--space-3);
            background: var(--color-success);
            border: none;
            border-radius: var(--radius-md);
            color: var(--surface-background);
            font-family: var(--font-body);
            font-size: var(--text-xs);
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-normal);
        }
        
        .filter-apply-btn:hover { transform: scale(1.02); }
        
        #priceMin, #priceMax, #ownershipMin, #ownershipMax {
            background: var(--surface-0);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            font-family: var(--font-mono);
            font-size: var(--text-xs);
            padding: var(--space-1) var(--space-2);
            width: 60px;
            text-align: center;
            outline: none;
        }
        
        #priceMin:focus, #priceMax:focus, #ownershipMin:focus, #ownershipMax:focus { border-color: var(--color-success); }
        
        /* ========================================
           CONTENT
           ======================================== */
        .content {
            padding: var(--space-6);
            max-width: 1800px;
            margin: 0 auto;
        }
        
        .position-section { display: none; }
        .position-section.active { display: block; }
        
        /* ========================================
           DATA TABLES
           ======================================== */
        .table-container {
            background: var(--surface-0);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-lg);
            overflow: hidden;
            margin-bottom: var(--space-8);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
            font-variant-numeric: tabular-nums lining-nums;
        }
        
        thead {
            background: var(--surface-1);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        th {
            padding: var(--space-2) var(--space-2);
            text-align: left;
            font-family: var(--font-body);
            font-weight: 600;
            font-size: 9px;
            color: var(--color-success);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            border-bottom: 2px solid var(--color-success);
            border-right: 1px solid var(--border-subtle);
            white-space: nowrap;
            cursor: pointer;
            user-select: none;
            transition: background var(--transition-fast);
        }
        
        th:hover { background: var(--surface-2); }
        
        th:first-child {
            position: sticky;
            left: 0;
            background: var(--surface-1);
            z-index: 101;
        }
        
        th:first-child:hover { background: var(--surface-2); }
        
        .sort-icon {
            display: inline-block;
            margin-left: 4px;
            font-size: 8px;
            opacity: 0.4;
        }
        
        .sort-icon.active { opacity: 1; color: var(--color-success); }
        
        .filter-row { background: var(--surface-2); }
        
        .filter-row th {
            padding: var(--space-1);
            border-bottom: 1px solid var(--border-default);
        }
        
        .filter-row th:first-child {
            position: sticky;
            left: 0;
            background: var(--surface-2);
            z-index: 101;
        }
        
        .filter-input {
            width: 100%;
            background: var(--surface-0);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            font-family: var(--font-mono);
            font-size: 9px;
            padding: 3px 4px;
            outline: none;
        }
        
        .filter-input:focus { border-color: var(--color-success); box-shadow: 0 0 5px rgba(74, 222, 128, 0.2); }
        .filter-input::placeholder { color: var(--text-disabled); }
        
        td {
            padding: 6px;
            border-bottom: 1px solid var(--border-subtle);
            border-right: 1px solid var(--border-subtle);
            white-space: nowrap;
            color: var(--text-primary);
        }
        
        td:first-child {
            position: sticky;
            left: 0;
            background: var(--surface-0);
            z-index: 99;
            font-weight: 500;
        }
        
        tr:hover td { background: var(--surface-1); }
        tr:hover td:first-child { background: var(--surface-1); }
        
        /* Trend indicators */
        .trend-positive { background: rgba(74, 222, 128, 0.15) !important; color: var(--color-success) !important; }
        .trend-negative { background: rgba(248, 113, 113, 0.15) !important; color: var(--color-error) !important; }
        .trend-neutral { background: rgba(251, 191, 36, 0.15) !important; color: var(--color-warning) !important; }
        
        .stat-high { color: var(--color-success); font-weight: 600; }
        .stat-low { color: var(--color-error); }
        .stat-medium { color: var(--text-secondary); }
        
        .player-cell { display: flex; align-items: center; gap: var(--space-2); }
        
        .team-badge {
            font-size: 9px;
            padding: 2px 6px;
            background: var(--surface-2);
            border-radius: var(--radius-sm);
            color: var(--color-info);
            font-family: var(--font-mono);
        }
        
        /* ========================================
           LOADING OVERLAY
           ======================================== */
        .loading-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(10, 14, 20, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            opacity: 0;
            pointer-events: none;
            transition: opacity var(--transition-slow);
        }
        
        .loading-overlay.show { opacity: 1; pointer-events: all; }
        
        .loader { text-align: center; }
        
        .loader-spinner {
            width: 48px;
            height: 48px;
            border: 3px solid var(--border-default);
            border-top-color: var(--color-success);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto var(--space-4);
        }
        
        @keyframes spin { to { transform: rotate(360deg); } }
        
        .loader-text {
            font-family: var(--font-display);
            font-size: var(--text-sm);
            color: var(--color-success);
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }
        
        /* ========================================
           LEGEND
           ======================================== */
        .legend {
            display: flex;
            gap: var(--space-6);
            padding: var(--space-4) var(--space-6);
            background: var(--surface-0);
            border-top: 1px solid var(--border-default);
            font-size: var(--text-xs);
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            color: var(--text-secondary);
        }
        
        .legend-box {
            width: 12px;
            height: 12px;
            border-radius: var(--radius-sm);
        }
        
        /* ========================================
           RECOMMENDATIONS
           ======================================== */
        .recommendations-container {
            display: flex;
            flex-direction: column;
            gap: var(--space-8);
        }
        
        .position-recommendations {
            background: var(--surface-0);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-lg);
            padding: var(--space-6);
        }
        
        .position-recommendations h2 {
            font-family: var(--font-display);
            font-size: var(--text-lg);
            font-weight: 600;
            color: var(--color-success);
            margin-bottom: var(--space-4);
            padding-bottom: var(--space-3);
            border-bottom: 2px solid var(--color-success);
        }
        
        .recommendations-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: var(--space-4);
        }
        
        .rec-category {
            background: var(--surface-1);
            border-radius: var(--radius-md);
            padding: var(--space-4);
            border: 1px solid var(--border-default);
        }
        
        .rec-category h3 {
            font-size: var(--text-sm);
            font-weight: 600;
            color: var(--color-info);
            margin-bottom: var(--space-3);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .rec-category.budget h3 { color: var(--color-success); }
        .rec-category.premium h3 { color: var(--color-warning); }
        
        .player-rec-card {
            background: var(--surface-0);
            border-radius: var(--radius-md);
            padding: var(--space-3);
            margin-bottom: var(--space-2);
            border-left: 3px solid var(--color-success);
            transition: all var(--transition-normal);
        }
        
        .player-rec-card:hover { background: var(--surface-2); transform: translateX(4px); }
        
        .player-rec-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-2);
        }
        
        .player-rec-name { font-weight: 600; font-size: var(--text-sm); color: var(--text-primary); }
        .player-rec-price { font-family: var(--font-mono); font-size: var(--text-sm); color: var(--color-warning); font-weight: 600; }
        .player-rec-team { font-size: var(--text-xs); color: var(--text-secondary); margin-bottom: var(--space-2); }
        
        .player-rec-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: var(--space-2);
        }
        
        .player-rec-stat { display: flex; flex-direction: column; }
        .player-rec-stat-label { font-size: 8px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.03em; }
        .player-rec-stat-value { font-family: var(--font-mono); font-size: var(--text-sm); color: var(--color-success); font-weight: 600; }
        .player-rec-stat-value.trend-up { color: var(--color-success); }
        .player-rec-stat-value.trend-down { color: var(--color-error); }
        
        .rec-reason {
            margin-top: var(--space-2);
            padding-top: var(--space-2);
            border-top: 1px solid var(--border-subtle);
            font-size: var(--text-xs);
            color: var(--text-secondary);
            font-style: italic;
        }
        
        /* ========================================
           GUIDE SECTION
           ======================================== */
        .guide-section {
            background: var(--surface-0);
            border-bottom: 1px solid var(--border-default);
        }
        
        .guide-header {
            padding: var(--space-4) var(--space-6);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all var(--transition-normal);
        }
        
        .guide-header:hover { background: var(--surface-1); }
        
        .guide-title { font-size: var(--text-sm); font-weight: 600; color: var(--color-success); display: block; margin-bottom: 2px; }
        .guide-subtitle { font-size: var(--text-xs); color: var(--text-secondary); display: block; }
        .guide-toggle { font-size: var(--text-lg); color: var(--color-success); transition: transform var(--transition-normal); }
        .guide-toggle.open { transform: rotate(180deg); }
        
        .guide-content { max-height: 0; overflow: hidden; transition: max-height 0.5s ease; }
        .guide-content.open { max-height: 15000px; }
        
        .guide-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
            gap: var(--space-4);
            padding: var(--space-6);
        }
        
        .guide-card {
            background: var(--surface-1);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-md);
            padding: var(--space-4);
            border-left: 3px solid var(--color-success);
        }
        
        .guide-card h3 {
            font-family: var(--font-display);
            font-size: var(--text-sm);
            font-weight: 600;
            color: var(--color-success);
            margin-bottom: var(--space-3);
        }
        
        .guide-text { font-size: 10px; color: var(--text-primary); line-height: 1.6; }
        .guide-text p { margin-bottom: var(--space-3); }
        .guide-text strong { color: var(--color-success); font-weight: 600; }
        .guide-text ul { margin: var(--space-2) 0 var(--space-3) var(--space-4); list-style: none; }
        .guide-text ul li { margin-bottom: var(--space-2); position: relative; padding-left: var(--space-4); }
        .guide-text ul li::before { content: "‚ñ∏"; position: absolute; left: 0; color: var(--color-success); }
        
        /* ========================================
           COLUMN TOGGLES
           ======================================== */
        .column-toggles {
            background: var(--surface-2);
            padding: var(--space-2) var(--space-6);
            border-bottom: 1px solid var(--border-default);
            display: flex;
            gap: var(--space-4);
            align-items: center;
            font-size: var(--text-xs);
        }
        
        .column-toggle { display: flex; align-items: center; gap: var(--space-2); cursor: pointer; user-select: none; color: var(--text-secondary); }
        .column-toggle input[type="checkbox"] { cursor: pointer; accent-color: var(--color-success); }
        .column-toggle label { cursor: pointer; }
        
        .col-attacking.hidden, .col-defensive.hidden, .col-advanced.hidden { display: none; }
        
        /* ========================================
           COMPARE BUTTON & MODAL
           ======================================== */
        #compareBtn {
            position: fixed;
            bottom: var(--space-8);
            right: var(--space-8);
            background: linear-gradient(135deg, var(--color-success) 0%, #22c55e 100%);
            color: var(--surface-background);
            padding: 14px 24px;
            border-radius: 30px;
            cursor: pointer;
            font-family: var(--font-display);
            font-weight: 600;
            font-size: 13px;
            box-shadow: 0 4px 20px rgba(74, 222, 128, 0.4);
            z-index: 1000;
            display: none;
            align-items: center;
            gap: var(--space-2);
            transition: all var(--transition-normal);
        }
        
        #compareBtn:hover { transform: translateY(-2px); box-shadow: 0 8px 30px rgba(74, 222, 128, 0.5); }
        
        #comparisonModal {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            justify-content: center;
            align-items: flex-start;
            padding: var(--space-8);
            overflow-y: auto;
        }
        
        #comparisonContent {
            background: var(--surface-background);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-lg);
            max-width: 1200px;
            width: 100%;
            padding: var(--space-6);
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .no-data { text-align: center; padding: var(--space-16); color: var(--text-secondary); font-size: var(--text-sm); }
        
        /* ========================================
           RESPONSIVE
           ======================================== */
        @media (max-width: 768px) {
            .header h1 { font-size: var(--text-lg); }
            .content { padding: var(--space-4); }
            th, td { padding: 4px 3px; font-size: 9px; }
            .recommendations-grid { grid-template-columns: 1fr; }
            .controls { flex-direction: column; align-items: stretch; }
            .btn { width: 100%; justify-content: center; }
            .global-search { margin-left: 0; flex-wrap: wrap; }
            .guide-grid { grid-template-columns: 1fr; }
            .back-button { top: auto; bottom: var(--space-4); left: var(--space-4); }
        }
        
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after { animation-duration: 0.01ms !important; transition-duration: 0.01ms !important; }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-button">
        <span>‚Üê</span> Back to Home
    </a>

    <div class="loading-overlay" id="loadingOverlay">
        <div class="loader">
            <div class="loader-spinner"></div>
            <div class="loader-text">Loading FPL Data...</div>
        </div>
    </div>

    <div class="header">
        <h1>‚ö° Players Analysis</h1>
        <p>Real-time player performance metrics from Fantasy Premier League API</p>
    </div>

    <div class="guide-section" id="guideSection">
        <div class="guide-header" onclick="toggleGuide()">
            <div>
                <span class="guide-title">üìö How to Use This Tool & Make Smart Player Decisions</span>
                <span class="guide-subtitle">Click to expand comprehensive guide on player selection strategy</span>
            </div>
            <span class="guide-toggle" id="guideToggle">‚ñº</span>
        </div>
        <div class="guide-content" id="guideContent">
            <div class="guide-grid">
                <div class="guide-card">
                    <h3>‚≠ê Using the Recommendations Tab</h3>
                    <div class="guide-text">
                        <p><strong>What it does:</strong> Automatically identifies the best value players in each position based on research-backed FPL metrics.</p>
                        <p><strong>How players are scored:</strong></p>
                        <ul>
                            <li><strong>Points per Million (30% weight):</strong> The #1 factor. Shows true value</li>
                            <li><strong>xGI - Expected Goal Involvements (25%):</strong> More predictive than actual goals</li>
                            <li><strong>Minutes Consistency (15%):</strong> Must average 75+ mins in last 5 games</li>
                            <li><strong>Form Direction (10%):</strong> Is xGI improving?</li>
                        </ul>
                        <p><strong>Budget vs Premium:</strong> GK ‚â§¬£5.0m, DEF ‚â§¬£5.5m, MID ‚â§¬£7.0m, FWD ‚â§¬£7.5m</p>
                    </div>
                </div>

                <div class="guide-card">
                    <h3>üìä Understanding xG, xA, and xGI</h3>
                    <div class="guide-text">
                        <p><strong>Why these matter:</strong> They predict FUTURE performance, not just past results.</p>
                        <ul>
                            <li><strong>xG:</strong> Measures quality of scoring chances (0.0-1.0)</li>
                            <li><strong>xA:</strong> Probability that a pass leads to a goal</li>
                            <li><strong>xGI:</strong> Total attacking threat per game</li>
                        </ul>
                        <p><strong>Benchmarks:</strong> Excellent: 0.6+/game ‚Ä¢ Good: 0.4-0.6 ‚Ä¢ Average: 0.2-0.4</p>
                    </div>
                </div>

                <div class="guide-card">
                    <h3>üìà Season vs Last 5 Games (L5)</h3>
                    <div class="guide-text">
                        <p><strong>Core Concept:</strong> Recent form (L5) predicts immediate performance better than season averages.</p>
                        <p><strong>How to interpret trends (Œî%):</strong></p>
                        <ul>
                            <li><strong style="color: #4ADE80;">Green (>10%):</strong> Player improving! Prime target</li>
                            <li><strong style="color: #FBBF24;">Yellow (-10% to +10%):</strong> Consistent performer</li>
                            <li><strong style="color: #F87171;">Red (<-10%):</strong> Declining. Sell or avoid</li>
                        </ul>
                    </div>
                </div>

                <div class="guide-card">
                    <h3>üí∞ Points Per Million: The Value Game</h3>
                    <div class="guide-text">
                        <p><strong>Value benchmarks by position:</strong></p>
                        <ul>
                            <li><strong>GK:</strong> 0.8+ good, 1.0+ excellent</li>
                            <li><strong>DEF:</strong> 0.9+ good, 1.2+ excellent</li>
                            <li><strong>MID:</strong> 0.8+ good, 1.1+ excellent</li>
                            <li><strong>FWD:</strong> 0.7+ good, 1.0+ excellent</li>
                        </ul>
                        <p><strong>Strategy:</strong> 3 Premiums + 8 Value picks for optimal squad balance.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="controls">
        <button class="btn" onclick="loadData(true)" id="refreshBtn">üîÑ Refresh Data</button>
        <div id="statusText" class="status">Ready to load data</div>
        <div id="cacheInfo" style="font-size: 10px; color: var(--text-dim); margin-left: 10px;"></div>
    </div>

    <div class="tabs" id="tabs">
        <button class="tab" data-position="RECOMMENDATIONS">‚≠ê Recommendations</button>
        <button class="tab" data-position="FORM">üî• Form Players</button>
        <button class="tab" data-position="CHARTS">üìä Charts</button>
        <button class="tab" data-position="FIXTURES">üìÖ Fixtures</button>
        <button class="tab" data-position="GK">üß§ Goalkeepers</button>
        <button class="tab" data-position="DEF">üõ°Ô∏è Defenders</button>
        <button class="tab" data-position="MID">‚ö° Midfielders</button>
        <button class="tab" data-position="FWD">üéØ Forwards</button>
    </div>

    <div class="preset-filters" id="presetFilters" style="display: none;">
        <button class="preset-btn" onclick="applyPreset('budget-enablers')">üí∞ Budget Enablers</button>
        <button class="preset-btn" onclick="applyPreset('form-players')">üî• Form Players</button>
        <button class="preset-btn" onclick="applyPreset('nailed-starters')">üîí Nailed Starters</button>
        <button class="preset-btn" onclick="applyPreset('value-picks')">üíé Value Picks</button>
        <button class="preset-btn" onclick="applyPreset('easy-fixtures')">üü¢ Easy Fixtures</button>
        <button class="preset-btn" onclick="applyPreset('clear')">‚úñÔ∏è Clear</button>
        <div class="global-search">
            <span style="color: var(--text-dim); font-size: 10px;">üîç SEARCH:</span>
            <input type="text" id="globalSearch" placeholder="Search all players..." oninput="globalSearch()">
            <button class="export-btn" onclick="exportToCSV()">üìä Export CSV</button>
        </div>
    </div>

    <div class="advanced-filters" id="advancedFilters" style="display: none;">
        <div class="filter-group">
            <span style="color: var(--text-dim); font-size: 10px; margin-right: 8px;">üéØ FIXTURES:</span>
            <button class="filter-chip" onclick="applyAdvancedFilter('fdr', 'easy')">üü¢üü¢ Easy (<2.6)</button>
            <button class="filter-chip" onclick="applyAdvancedFilter('fdr', 'favorable')">üü¢ Favorable (<2.9)</button>
            <button class="filter-chip" onclick="applyAdvancedFilter('fdr', 'neutral')">üü° Neutral (2.9-3.1)</button>
            <button class="filter-chip" onclick="applyAdvancedFilter('fdr', 'tough')">üî¥ Tough (>3.4)</button>
        </div>
        
        <div class="filter-group">
            <span style="color: var(--text-dim); font-size: 10px; margin-right: 8px;">üí∞ PRICE:</span>
            <button class="filter-chip" onclick="applyAdvancedFilter('price', 'budget')">Budget (<¬£5.5)</button>
            <button class="filter-chip" onclick="applyAdvancedFilter('price', 'mid')">Mid (¬£5.5-¬£8.0)</button>
            <button class="filter-chip" onclick="applyAdvancedFilter('price', 'premium')">Premium (>¬£8.0)</button>
            <span style="color: var(--text-dim); font-size: 10px; margin: 0 8px;">or</span>
            <input type="number" id="priceMin" placeholder="Min" step="0.1" min="4" max="15" style="width: 60px;">
            <span style="color: var(--text-dim); margin: 0 4px;">-</span>
            <input type="number" id="priceMax" placeholder="Max" step="0.1" min="4" max="15" style="width: 60px;">
            <button class="filter-apply-btn" onclick="applyCustomPriceFilter()">Apply</button>
        </div>
        
        <div class="filter-group">
            <span style="color: var(--text-dim); font-size: 10px; margin-right: 8px;">üë• OWNERSHIP:</span>
            <button class="filter-chip" onclick="applyAdvancedFilter('ownership', 'template')">Template (>20%)</button>
            <button class="filter-chip" onclick="applyAdvancedFilter('ownership', 'popular')">Popular (10-20%)</button>
            <button class="filter-chip" onclick="applyAdvancedFilter('ownership', 'differential')">Differential (<10%)</button>
            <button class="filter-chip" onclick="applyAdvancedFilter('ownership', 'unique')">Unique (<5%)</button>
            <span style="color: var(--text-dim); font-size: 10px; margin: 0 8px;">or</span>
            <input type="number" id="ownershipMin" placeholder="Min %" step="1" min="0" max="100" style="width: 60px;">
            <span style="color: var(--text-dim); margin: 0 4px;">-</span>
            <input type="number" id="ownershipMax" placeholder="Max %" step="1" min="0" max="100" style="width: 60px;">
            <button class="filter-apply-btn" onclick="applyCustomOwnershipFilter()">Apply</button>
            <span style="margin-left: 20px;"></span>
            <button class="filter-apply-btn" onclick="clearAdvancedFilters()" style="background: var(--color-error);">‚úñ Clear All Filters</button>
        </div>
    </div>

    <div class="content">
        <div class="position-section" id="section-RECOMMENDATIONS"></div>
        <div class="position-section" id="section-FORM"></div>
        <div class="position-section" id="section-CHARTS"></div>
        <div class="position-section" id="section-FIXTURES"></div>
        <div class="position-section" id="section-GK"></div>
        <div class="position-section" id="section-DEF"></div>
        <div class="position-section" id="section-MID"></div>
        <div class="position-section" id="section-FWD"></div>
    </div>

    <div class="legend">
        <div class="legend-item">
            <div class="legend-box trend-positive"></div>
            <span>Improving (>10%)</span>
        </div>
        <div class="legend-item">
            <div class="legend-box trend-neutral"></div>
            <span>Stable (-10% to 10%)</span>
        </div>
        <div class="legend-item">
            <div class="legend-box trend-negative"></div>
            <span>Declining (<-10%)</span>
        </div>
        <div class="legend-item" style="margin-left: 30px; border-left: 2px solid var(--border); padding-left: 20px;">
            <span>üìä <strong>Filter Tips:</strong> Use >= (greater/equal), <= (less/equal), > (greater), < (less)</span>
        </div>
    </div>

    <div id="compareBtn" style="display: none; position: fixed; bottom: 30px; right: 30px; background: linear-gradient(135deg, var(--accent-green) 0%, #22c55e 100%); color: var(--bg-dark); padding: 14px 24px; border-radius: 30px; cursor: pointer; font-family: 'Space Grotesk', monospace; font-weight: 600; font-size: 13px; box-shadow: 0 4px 20px rgba(74, 222, 128, 0.4); z-index: 1000; align-items: center; gap: 10px;" onclick="openComparisonModal()">
        <span>‚öñÔ∏è Compare</span>
        <span id="compareCount" style="background: var(--bg-dark); color: var(--accent-green); padding: 2px 8px; border-radius: 12px; font-size: 11px;">0</span>
        <span onclick="event.stopPropagation(); clearComparisonSelection();" style="margin-left: 8px; padding: 4px 8px; background: rgba(0,0,0,0.2); border-radius: 8px; font-size: 10px;">‚úï Clear</span>
    </div>

    <div id="comparisonModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 2000; justify-content: center; align-items: flex-start; padding: 40px; overflow-y: auto;">
        <div id="comparisonContent" style="background: var(--bg-dark); border: 1px solid var(--border); border-radius: 8px; max-width: 1200px; width: 100%; padding: 25px; max-height: 90vh; overflow-y: auto;">
        </div>
    </div>

    <script>
        const CORS_PROXY = 'https://corsproxy.io/?';

        let bootstrapData = null;
        let playerAnalyses = {};
        let teamFixtures = {}; // Store fixtures by team ID
        let teams = {}; // Store team data by ID
        let currentGameweek = null; // Current gameweek (detected from data)
        let currentPhase = 'mid'; // Current season phase: 'early', 'mid', 'late'
        let allAnalyses = []; // Store all player analyses for comparison feature
        
        // ============================================
        // PLAYER COMPARISON MODE
        // ============================================
        let selectedForComparison = []; // Array of player IDs selected for comparison
        const MAX_COMPARISON = 4; // Maximum players to compare
        
        // Toggle player selection for comparison
        function togglePlayerComparison(playerId, checkbox) {
            const player = allAnalyses.find(p => p.id === playerId);
            if (!player) return;
            
            if (checkbox.checked) {
                if (selectedForComparison.length >= MAX_COMPARISON) {
                    checkbox.checked = false;
                    alert(`Maximum ${MAX_COMPARISON} players can be compared at once`);
                    return;
                }
                selectedForComparison.push(playerId);
            } else {
                selectedForComparison = selectedForComparison.filter(id => id !== playerId);
            }
            
            updateCompareButton();
        }
        
        // Update compare button visibility and count
        function updateCompareButton() {
            const btn = document.getElementById('compareBtn');
            const count = document.getElementById('compareCount');
            
            if (selectedForComparison.length >= 2) {
                btn.style.display = 'flex';
                count.textContent = selectedForComparison.length;
            } else {
                btn.style.display = 'none';
            }
        }
        
        // Clear all selections
        function clearComparisonSelection() {
            selectedForComparison = [];
            document.querySelectorAll('.compare-checkbox').forEach(cb => cb.checked = false);
            updateCompareButton();
        }
        
        // Open comparison modal
        function openComparisonModal() {
            if (selectedForComparison.length < 2) return;
            
            const players = selectedForComparison.map(id => allAnalyses.find(p => p.id === id)).filter(Boolean);
            const positionMap = { 1: 'GK', 2: 'DEF', 3: 'MID', 4: 'FWD' };
            
            const modal = document.getElementById('comparisonModal');
            const content = document.getElementById('comparisonContent');
            
            // Build comparison table
            let html = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 style="color: var(--accent-green); font-family: 'Space Mono', monospace;">‚öñÔ∏è Player Comparison</h2>
                    <button onclick="closeComparisonModal()" style="background: var(--accent-red); border: none; color: white; padding: 8px 16px; cursor: pointer; font-family: 'DM Mono', monospace;">‚úï Close</button>
                </div>
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse;">
            `;
            
            // Header row with player names
            html += '<thead><tr style="background: var(--surface-light);">';
            html += '<th style="padding: 12px; text-align: left; color: var(--accent-green); border-bottom: 2px solid var(--accent-green);">Stat</th>';
            players.forEach(p => {
                html += `<th style="padding: 12px; text-align: center; color: var(--text); border-bottom: 2px solid var(--accent-green); min-width: 140px;">
                    <div style="font-size: 14px; font-weight: 600;">${p.name}</div>
                    <div style="font-size: 10px; color: var(--text-dim);">${p.team} ‚Ä¢ ${positionMap[p.position]}</div>
                    <div style="font-size: 12px; color: var(--accent-yellow); margin-top: 4px;">¬£${p.price.toFixed(1)}m</div>
                </th>`;
            });
            html += '</tr></thead><tbody>';
            
            // Define comparison stats
            const comparisonStats = [
                { label: 'üìä Points (Season)', getValue: p => p.season.points, format: v => v.toFixed(0), highlight: 'high' },
                { label: 'üìä Points/Game (L5)', getValue: p => p.l5.points / p.l5.games, format: v => v.toFixed(1), highlight: 'high' },
                { label: '‚ö° xGI/Game (L5)', getValue: p => p.l5.xGI / p.l5.games, format: v => v.toFixed(2), highlight: 'high' },
                { label: '‚öΩ Goals (L5)', getValue: p => p.l5.goals, format: v => v.toFixed(0), highlight: 'high' },
                { label: 'üÖ∞Ô∏è Assists (L5)', getValue: p => p.l5.assists, format: v => v.toFixed(0), highlight: 'high' },
                { label: 'üéØ xG/Game (L5)', getValue: p => p.l5.xG / p.l5.games, format: v => v.toFixed(2), highlight: 'high' },
                { label: 'üéØ xA/Game (L5)', getValue: p => p.l5.xA / p.l5.games, format: v => v.toFixed(2), highlight: 'high' },
                { label: '‚è±Ô∏è Minutes (L5)', getValue: p => p.l5.minutes / p.l5.games, format: v => v.toFixed(0), highlight: 'high' },
                { label: 'üõ°Ô∏è Clean Sheets (L5)', getValue: p => p.l5.cleanSheets, format: v => v.toFixed(0), highlight: 'high' },
                { label: 'üí∞ Value (pts/¬£m)', getValue: p => (p.l5.points / p.l5.games) / p.price, format: v => v.toFixed(2), highlight: 'high' },
                { label: 'üë• Ownership', getValue: p => p.selectedBy || 0, format: v => v.toFixed(1) + '%', highlight: 'none' },
                { label: '‚≠ê Bonus (L5)', getValue: p => p.l5.bonus || 0, format: v => v.toFixed(0), highlight: 'high' },
                { label: 'üìÖ FDR (Next 3)', getValue: p => p.fixtures?.avgFDR3 || 0, format: v => v.toFixed(2), highlight: 'low' },
                { label: 'üìÖ Next Fixtures', getValue: p => p.fixtures?.fixtureString || '-', format: v => v, highlight: 'none' }
            ];
            
            comparisonStats.forEach(stat => {
                html += '<tr>';
                html += `<td style="padding: 10px 12px; border-bottom: 1px solid var(--border); color: var(--text-dim); font-size: 11px;">${stat.label}</td>`;
                
                // Get values and find best
                const values = players.map(p => {
                    try { return stat.getValue(p); } catch { return 0; }
                });
                
                const numericValues = values.filter(v => typeof v === 'number' && !isNaN(v));
                const best = stat.highlight === 'high' ? Math.max(...numericValues) : 
                            stat.highlight === 'low' ? Math.min(...numericValues) : null;
                
                players.forEach((p, i) => {
                    const val = values[i];
                    const formatted = stat.format(val);
                    const isBest = stat.highlight !== 'none' && val === best && numericValues.length > 1;
                    
                    html += `<td style="padding: 10px 12px; border-bottom: 1px solid var(--border); text-align: center; font-size: 12px; font-weight: ${isBest ? '600' : '400'}; color: ${isBest ? 'var(--accent-green)' : 'var(--text)'}; background: ${isBest ? 'rgba(0, 255, 136, 0.1)' : 'transparent'};">
                        ${formatted}
                        ${isBest ? ' ‚úì' : ''}
                    </td>`;
                });
                
                html += '</tr>';
            });
            
            html += '</tbody></table></div>';
            
            // Verdict section
            html += `
                <div style="margin-top: 25px; padding: 20px; background: var(--surface-light); border-left: 4px solid var(--accent-green);">
                    <h3 style="color: var(--accent-green); margin-bottom: 15px; font-size: 14px;">üìù Quick Verdict</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
            `;
            
            players.forEach(p => {
                const l5Pts = p.l5.points / p.l5.games;
                const l5xGI = p.l5.xGI / p.l5.games;
                const value = l5Pts / p.price;
                const fdr = p.fixtures?.avgFDR3 || 3;
                
                let verdict = '';
                let verdictColor = 'var(--text)';
                
                if (l5Pts >= 5 && fdr < 3) {
                    verdict = 'üî• HOT PICK - Form + Fixtures';
                    verdictColor = 'var(--accent-green)';
                } else if (value > 1.0 && l5xGI > 0.3) {
                    verdict = 'üí∞ VALUE PICK - Good underlying';
                    verdictColor = 'var(--accent-green)';
                } else if (l5Pts < 3 && fdr > 3.5) {
                    verdict = '‚ö†Ô∏è AVOID - Poor form + tough fixtures';
                    verdictColor = 'var(--accent-red)';
                } else if (l5xGI > l5Pts * 0.15) {
                    verdict = 'üìà DUE RETURNS - underperforming xGI';
                    verdictColor = 'var(--accent-yellow)';
                } else {
                    verdict = '‚û°Ô∏è HOLD - Monitor form';
                    verdictColor = 'var(--text-dim)';
                }
                
                html += `
                    <div style="background: var(--bg-dark); padding: 12px; border-radius: 4px;">
                        <div style="font-weight: 600; margin-bottom: 6px; color: var(--text);">${p.name}</div>
                        <div style="font-size: 11px; color: ${verdictColor};">${verdict}</div>
                    </div>
                `;
            });
            
            html += '</div></div>';
            
            content.innerHTML = html;
            modal.style.display = 'flex';
        }
        
        // Close comparison modal
        function closeComparisonModal() {
            document.getElementById('comparisonModal').style.display = 'none';
        }

        // ============================================
        // GAMEWEEK & PHASE DETECTION
        // ============================================
        
        // Detect current gameweek from player history data
        function detectCurrentGameweek(analyses) {
            if (!analyses || analyses.length === 0) return 1;
            
            // Find the maximum gameweek from all player season games
            // This assumes season.games roughly equals current gameweek for active players
            let maxGames = 0;
            analyses.forEach(p => {
                if (p.season && p.season.games > maxGames) {
                    maxGames = p.season.games;
                }
            });
            
            // The current gameweek is approximately the max games played + 1
            // (since max games = completed gameweeks for ever-present players)
            return Math.min(maxGames + 1, 38);
        }
        
        // Determine season phase based on gameweek
        function getSeasonPhase(gameweek) {
            const phases = RECOMMENDATION_CONFIG.gameweekPhases;
            
            if (gameweek >= phases.early.start && gameweek <= phases.early.end) {
                return 'early';
            } else if (gameweek >= phases.late.start && gameweek <= phases.late.end) {
                return 'late';
            } else {
                return 'mid';
            }
        }
        
        // Get phase-adjusted weights
        function getPhaseAdjustedWeights() {
            const cfg = RECOMMENDATION_CONFIG;
            const baseWeights = cfg.weights;
            const modifiers = cfg.gameweekPhases.weightModifiers[currentPhase];
            
            return {
                value: baseWeights.value * modifiers.value,
                positionScore: baseWeights.positionScore * modifiers.positionScore,
                minutesConsistency: baseWeights.minutesConsistency * modifiers.minutesConsistency,
                formImprovement: baseWeights.formImprovement * modifiers.formImprovement,
                formDecline: baseWeights.formDecline,
                easyFixtures: baseWeights.easyFixtures * modifiers.easyFixtures,
                favorableFixtures: baseWeights.favorableFixtures * modifiers.favorableFixtures,
                toughFixtures: baseWeights.toughFixtures * modifiers.toughFixtures,
                differentialBonus: modifiers.differentialBonus
            };
        }
        
        // Get phase display info
        function getPhaseInfo() {
            const phaseDetails = {
                early: {
                    name: 'Early Season',
                    emoji: 'üå±',
                    color: 'var(--accent-green)',
                    description: 'Focus on fixtures & nailed starters. Form data is limited.',
                    tips: ['Prioritize easy fixture runs', 'Avoid rotation risks', 'Trust preseason expectations']
                },
                mid: {
                    name: 'Mid Season',
                    emoji: '‚ö°',
                    color: 'var(--accent-blue)',
                    description: 'Balanced approach. Trust form and underlying stats.',
                    tips: ['Follow the form', 'Watch for fixture swings', 'Build for double gameweeks']
                },
                late: {
                    name: 'Late Season',
                    emoji: 'üèÅ',
                    color: 'var(--accent-red)',
                    description: 'Rank push time! Differentials and DGW players are key.',
                    tips: ['Target differentials (<10% owned)', 'Plan for DGW/BGW', 'Take calculated risks']
                }
            };
            return phaseDetails[currentPhase];
        }

        // ============================================
        // RECOMMENDATION CONFIGURATION
        // Tune these values to adjust the algorithm
        // ============================================
        const RECOMMENDATION_CONFIG = {
            // Scoring weights for recommendation algorithm
            weights: {
                value: 30,              // Points per million importance
                positionScore: 1.5,     // Position-specific metrics multiplier
                minutesConsistency: 10, // Nailed-on bonus
                formImprovement: 5,     // xGI improvement bonus
                formDecline: -2,        // xGI decline penalty
                easyFixtures: 15,       // FDR < 2.5 bonus
                favorableFixtures: 8,   // FDR < 3.0 bonus
                toughFixtures: -10      // FDR > 3.5 penalty
            },
            // Thresholds for player eligibility
            thresholds: {
                minL5Games: 4,          // Minimum games in last 5
                minSeasonGames: 8,      // Minimum season games
                minAvgMinutes: 60,      // Minimum average minutes per game
                nailedOnMinutes: 75,    // Minutes threshold for "nailed on"
                minPrice: 3.9,          // Minimum price to consider
                underperformanceXGI: 0.2,  // xGI gap to flag underperformance
                minXGIForUnderperformance: 0.35, // Minimum xGI to consider underperformance (otherwise they're just bad)
                goodValue: 0.9,         // pts/¬£m threshold for "good value"
                excellentValue: 1.2,    // pts/¬£m threshold for "excellent value"
                strongXGI: 0.5,         // xGI/game for attackers
                highMinutesConsistency: 0.95 // % of 90 mins for nailed on
            },
            // Budget thresholds by position (based on FPL meta)
            budgetCaps: {
                GK: 5.0,
                DEF: 5.5,
                MID: 7.0,
                FWD: 7.5
            },
            // FDR thresholds
            fdr: {
                easy: 2.5,      // Below this = easy
                favorable: 3.0, // Below this = favorable
                tough: 3.5      // Above this = tough
            },
            // Form Players scoring
            formSignals: {
                formSurge: { threshold: 50, points: 30 },      // Form improvement %
                formImproving: { threshold: 25, points: 20 },
                hotForm: { threshold: 5, points: 15 },         // L5 avg points
                eliteXGI: { threshold: 0.6, points: 25 },
                strongXGI: { threshold: 0.4, points: 15 },
                goodXGI: { threshold: 0.25, points: 8 },
                nailedOn: { threshold: 85, points: 15 },       // Minutes
                regularStarter: { threshold: 70, points: 10 },
                gettingMinutes: { threshold: 60, points: 5 },
                ultraDifferential: { threshold: 5, points: 10 }, // Ownership %
                lowOwned: { threshold: 10, points: 6 },
                underperforming: { xgiGap: 0.2, minXGI: 0.35, points: 10 },
                greatValue: { threshold: 1.0, points: 10 },
                goodValueForm: { threshold: 0.7, points: 5 },
                easyFixturesForm: { points: 15 },
                goodFixturesForm: { points: 8 },
                toughFixturesForm: { points: -5 },
                minSignal: 45,  // Minimum signal to include player
                highPriority: 70,
                mediumPriority: 55
            },
            // GK-specific clean sheet thresholds
            gkThresholds: {
                excellentCS: 0.6,
                strongCS: 0.4
            },
            // GK scoring weights
            gkScoring: {
                cleanSheet: 15,
                savesPerGame: 0.5,
                penaltySave: 25,      // Huge swing - 5 pts per save
                bonusPerGame: 3,
                assistPerGame: 8,
                xGCPenalty: 2
            },
            // Display settings
            display: {
                maxPlayersPerCategory: 5,
                maxFormPlayers: 20
            },
            // Gameweek phase configuration
            gameweekPhases: {
                // Phase definitions
                early: { start: 1, end: 8 },      // GW1-8: Limited data
                mid: { start: 9, end: 30 },       // GW9-30: Full data available
                late: { start: 31, end: 38 },     // GW31-38: Rank push time
                
                // Weight multipliers by phase (1.0 = normal, >1 = more important, <1 = less important)
                weightModifiers: {
                    early: {
                        // Early season: fixtures and nailed starters are king, form data is unreliable
                        value: 0.8,              // Less reliable early
                        positionScore: 0.7,      // Less reliable early
                        minutesConsistency: 1.5, // Very important - want nailed players
                        formImprovement: 0.5,    // Unreliable with small sample
                        easyFixtures: 1.5,       // Fixtures are crucial early
                        favorableFixtures: 1.3,
                        toughFixtures: 1.3,      // Avoid tough fixtures more
                        differentialBonus: 0     // Don't chase differentials early
                    },
                    mid: {
                        // Mid season: balanced approach, trust the data
                        value: 1.0,
                        positionScore: 1.0,
                        minutesConsistency: 1.0,
                        formImprovement: 1.0,
                        easyFixtures: 1.0,
                        favorableFixtures: 1.0,
                        toughFixtures: 1.0,
                        differentialBonus: 0
                    },
                    late: {
                        // Late season: differentials for rank climbing, DGW targets
                        value: 0.9,
                        positionScore: 1.1,      // Trust underlying stats
                        minutesConsistency: 1.2, // Still want starters
                        formImprovement: 1.2,    // Hot form matters for final push
                        easyFixtures: 1.3,       // DGW teams often have good fixtures
                        favorableFixtures: 1.2,
                        toughFixtures: 0.8,      // Can take more risks
                        differentialBonus: 15    // Big bonus for low ownership
                    }
                },
                // Ownership thresholds for differential bonus in late season
                differentialThreshold: 10  // Below this % = differential
            }
        };

        // Toggle guide section
        function toggleGuide() {
            const content = document.getElementById('guideContent');
            const toggle = document.getElementById('guideToggle');
            
            content.classList.toggle('open');
            toggle.classList.toggle('open');
        }
        
        // Clear cache function
        function clearCache() {
            localStorage.removeItem('fpl_players_cache');
            localStorage.removeItem('fpl_players_cache_time');
            updateStatus('Cache cleared! Click "Force Refresh" to reload data.', 'info');
            showCacheInfo();
            console.log('Cache cleared');
        }
        
        // Show cache info
        function showCacheInfo() {
            const cacheInfo = document.getElementById('cacheInfo');
            const cacheTime = localStorage.getItem('fpl_players_cache_time');
            
            if (cacheTime) {
                const ageHours = (Date.now() - parseInt(cacheTime)) / (1000 * 60 * 60);
                const date = new Date(parseInt(cacheTime));
                if (ageHours < 24) {
                    cacheInfo.textContent = `üì¶ Cached: ${date.toLocaleString()} (${ageHours.toFixed(1)}h ago)`;
                    cacheInfo.style.color = 'var(--accent-green)';
                } else {
                    cacheInfo.textContent = `‚ö†Ô∏è Cache expired (${ageHours.toFixed(1)}h ago)`;
                    cacheInfo.style.color = 'var(--accent-yellow)';
                }
            } else {
                cacheInfo.textContent = 'üíæ No cache - will fetch fresh data';
                cacheInfo.style.color = 'var(--text-dim)';
            }
        }

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.position-section').forEach(s => s.classList.remove('active'));
                
                tab.classList.add('active');
                const position = tab.dataset.position;
                document.getElementById(`section-${position}`).classList.add('active');
            });
        });

        // Set Recommendations as default active tab
        document.addEventListener('DOMContentLoaded', () => {
            const firstTab = document.querySelector('.tab[data-position="RECOMMENDATIONS"]');
            if (firstTab) {
                firstTab.classList.add('active');
                document.getElementById('section-RECOMMENDATIONS').classList.add('active');
            }
        });

        function showLoading(show) {
            const overlay = document.getElementById('loadingOverlay');
            if (show) {
                overlay.classList.add('show');
            } else {
                overlay.classList.remove('show');
            }
        }

        function updateStatus(message, type = 'info') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = 'status ' + type;
        }

        async function fetchBootstrapData() {
            const response = await fetch(CORS_PROXY + encodeURIComponent('https://fantasy.premierleague.com/api/bootstrap-static/'));
            if (!response.ok) throw new Error('Failed to fetch bootstrap data');
            return await response.json();
        }

        async function fetchPlayerDetails(elementId) {
            const response = await fetch(CORS_PROXY + encodeURIComponent(`https://fantasy.premierleague.com/api/element-summary/${elementId}/`));
            if (!response.ok) throw new Error(`Failed to fetch player ${elementId}`);
            return await response.json();
        }

        async function loadFixtures() {
            try {
                console.log('üìÖ Loading fixtures...');
                const fixturesUrl = 'https://fantasy.premierleague.com/api/fixtures/';
                const response = await fetch(CORS_PROXY + encodeURIComponent(fixturesUrl));
                
                if (!response.ok) {
                    throw new Error('Failed to fetch fixtures');
                }
                
                const fixtures = await response.json();
                console.log(`‚úÖ Loaded ${fixtures.length} total fixtures`);
                
                // Filter for upcoming fixtures only (not finished)
                const upcomingFixtures = fixtures.filter(f => !f.finished);
                console.log(`üìä ${upcomingFixtures.length} upcoming fixtures`);
                
                // Group fixtures by team
                teamFixtures = {};
                
                upcomingFixtures.forEach(fixture => {
                    // Home team fixtures
                    if (!teamFixtures[fixture.team_h]) {
                        teamFixtures[fixture.team_h] = [];
                    }
                    teamFixtures[fixture.team_h].push({
                        opponent: fixture.team_a,
                        is_home: true,
                        difficulty: fixture.team_h_difficulty,
                        event: fixture.event,
                        kickoff_time: fixture.kickoff_time
                    });
                    
                    // Away team fixtures
                    if (!teamFixtures[fixture.team_a]) {
                        teamFixtures[fixture.team_a] = [];
                    }
                    teamFixtures[fixture.team_a].push({
                        opponent: fixture.team_h,
                        is_home: false,
                        difficulty: fixture.team_a_difficulty,
                        event: fixture.event,
                        kickoff_time: fixture.kickoff_time
                    });
                });
                
                // Sort each team's fixtures by event (gameweek)
                Object.keys(teamFixtures).forEach(teamId => {
                    teamFixtures[teamId].sort((a, b) => (a.event || 999) - (b.event || 999));
                });
                
                console.log('‚úÖ Fixtures organized by team:', Object.keys(teamFixtures).length, 'teams');
                
            } catch (error) {
                console.error('‚ùå Error loading fixtures:', error);
                throw error;
            }
        }

        function calculateStats(history, last5 = false) {
            const games = last5 ? history.slice(-5) : history;
            const numGames = games.length;
            
            if (numGames === 0) return null;

            const sum = (arr, key) => arr.reduce((acc, g) => acc + (parseFloat(g[key]) || 0), 0);
            
            return {
                games: numGames,  // This is the count of games, not a sum
                minutes: sum(games, 'minutes'),
                points: sum(games, 'total_points'),
                goals: sum(games, 'goals_scored'),
                assists: sum(games, 'assists'),
                cleanSheets: sum(games, 'clean_sheets'),
                goalsConceded: sum(games, 'goals_conceded'),
                ownGoals: sum(games, 'own_goals'),
                penaltiesSaved: sum(games, 'penalties_saved'),
                penaltiesMissed: sum(games, 'penalties_missed'),
                yellowCards: sum(games, 'yellow_cards'),
                redCards: sum(games, 'red_cards'),
                saves: sum(games, 'saves'),
                bonus: sum(games, 'bonus'),
                bps: sum(games, 'bps'),
                xG: sum(games, 'expected_goals'),
                xA: sum(games, 'expected_assists'),
                xGI: sum(games, 'expected_goal_involvements'),
                xGC: sum(games, 'expected_goals_conceded'),
                ict: sum(games, 'ict_index'),
                influence: sum(games, 'influence'),
                creativity: sum(games, 'creativity'),
                threat: sum(games, 'threat'),
                bigChancesCreated: sum(games, 'big_chances_created'),
                bigChancesMissed: sum(games, 'big_chances_missed'),
                keyPasses: sum(games, 'key_passes')
            };
        }

        function calculateTrend(seasonVal, l5Val, seasonGames, l5Games) {
            if (seasonGames === 0 || l5Games === 0) return 0;
            const seasonAvg = seasonVal / seasonGames;
            const l5Avg = l5Val / l5Games;
            if (seasonAvg === 0) return 0;
            return ((l5Avg - seasonAvg) / seasonAvg) * 100;
        }

        function getTrendClass(trend, reverse = false) {
            const threshold = 10;
            if (reverse) {
                if (trend < -threshold) return 'trend-positive';
                if (trend > threshold) return 'trend-negative';
            } else {
                if (trend > threshold) return 'trend-positive';
                if (trend < -threshold) return 'trend-negative';
            }
            return 'trend-neutral';
        }

        async function analyzePlayer(elementId, playerName, position, team, teamId) {
            try {
                // Make the actual API call to get player's detailed history
                const data = await fetchPlayerDetails(elementId);
                const history = data.history || [];
                
                // Skip players with no game history
                if (history.length === 0) {
                    console.log(`Skipping ${playerName} - no history`);
                    return null;
                }

                const seasonStats = calculateStats(history);
                const l5Stats = calculateStats(history, true);

                // Verify we got valid stats
                if (!seasonStats || !l5Stats) {
                    console.log(`Skipping ${playerName} - invalid stats`);
                    return null;
                }

                // Calculate fixture difficulty
                let fixtureData = null;
                const playerFixtures = teamFixtures[teamId] || [];
                
                if (playerFixtures.length > 0) {
                    const next3 = playerFixtures.slice(0, 3);
                    const next5 = playerFixtures.slice(0, 5);
                    
                    const avgFDR3 = next3.reduce((sum, f) => sum + f.difficulty, 0) / next3.length;
                    const avgFDR5 = next5.reduce((sum, f) => sum + f.difficulty, 0) / next5.length;
                    
                    // Build fixture string with opponent names
                    const fixtureString = next3.map(f => {
                        const opponentTeam = teams[f.opponent];
                        const opponentName = opponentTeam ? opponentTeam.short_name : 'UNK';
                        return `${opponentName}(${f.is_home ? 'H' : 'A'})`;
                    }).join(', ');
                    
                    fixtureData = {
                        avgFDR3: avgFDR3,
                        avgFDR5: avgFDR5,
                        next3: next3,
                        next5: next5,
                        fixtureString: fixtureString
                    };
                }

                return {
                    name: playerName,
                    team: team,
                    teamId: teamId,
                    position: position,
                    season: seasonStats,
                    l5: l5Stats,
                    fixtures: fixtureData
                };
            } catch (error) {
                console.error(`Error analyzing ${playerName}:`, error);
                return null;
            }
        }

        function createTable(position, analyses) {
            const positionMap = { 1: 'GK', 2: 'DEF', 3: 'MID', 4: 'FWD' };
            const filteredAnalyses = analyses.filter(a => a && positionMap[a.position] === position);

            if (filteredAnalyses.length === 0) {
                return '<div class="no-data">No data available for this position</div>';
            }

            // Metric descriptions for tooltips
            const tooltips = {
                'GP': 'Games Played - Number of matches the player has appeared in',
                'Mins': 'Minutes - Total minutes played',
                'Pts': 'Points - Total FPL points scored',
                'CS': 'Clean Sheets - Games where the team did not concede a goal',
                'Saves': 'Saves - Total saves made by goalkeeper',
                'GC': 'Goals Conceded - Goals conceded while on the pitch',
                'xGC': 'Expected Goals Conceded - Statistical measure of goals likely to be conceded based on shot quality',
                'Pen S': 'Penalties Saved - Number of penalty kicks saved',
                'G': 'Goals - Goals scored by the player',
                'A': 'Assists - Assists provided by the player',
                'xG': 'Expected Goals - Statistical measure of goals a player should score based on shot quality',
                'xA': 'Expected Assists - Statistical measure of assists a player should have based on chances created',
                'xGI': 'Expected Goal Involvements - Combined xG and xA',
                'BCC': 'Big Chances Created - Clear goal-scoring opportunities created',
                'BCM': 'Big Chances Missed - Clear goal-scoring opportunities missed',
                'KP': 'Key Passes - Passes that lead to a shot on goal',
                'Bonus': 'Bonus Points - Extra FPL points awarded to top performers',
                'BPS': 'Bonus Points System - Score determining bonus point allocation',
                'ICT': 'ICT Index - Combined measure of Influence, Creativity, and Threat',
                'Infl': 'Influence - Impact on match outcome',
                'Creat': 'Creativity - Ability to create scoring chances',
                'Threat': 'Threat - Likelihood to score goals',
                'Player': 'Player Name',
                'Team': 'Team',
                'Œî%': 'Trend Percentage - Percentage change between season average and last 5 games average',
                'FDR': 'Fixture Difficulty Rating - Average difficulty of next 3 fixtures (1=Easy, 5=Hard)',
                'Next 3': 'Next 3 Fixtures - Upcoming opponents with home/away indicator',
                'Price': 'Current Price in ¬£m',
                'Own%': 'Ownership Percentage - How many managers own this player'
            };

            let columns = [];
            
            if (position === 'GK') {
                columns = [
                    { key: 'name', label: 'Player', seasonal: false },
                    { key: 'team', label: 'Team', seasonal: false },
                    { key: 'price', label: 'Price', seasonal: false },
                    { key: 'ownership', label: 'Own%', seasonal: false },
                    { key: 'games', label: 'GP', seasonal: true },
                    { key: 'minutes', label: 'Mins', seasonal: true },
                    { key: 'points', label: 'Pts', seasonal: true },
                    { key: 'cleanSheets', label: 'CS', seasonal: true },
                    { key: 'saves', label: 'Saves', seasonal: true },
                    { key: 'goalsConceded', label: 'GC', seasonal: true },
                    { key: 'xGC', label: 'xGC', seasonal: true },
                    { key: 'penaltiesSaved', label: 'Pen S', seasonal: true },
                    { key: 'bonus', label: 'Bonus', seasonal: true },
                    { key: 'bps', label: 'BPS', seasonal: true },
                    { key: 'fdr', label: 'FDR', seasonal: false },
                    { key: 'fixtures', label: 'Next 3', seasonal: false }
                ];
            } else if (position === 'DEF') {
                columns = [
                    { key: 'name', label: 'Player', seasonal: false },
                    { key: 'team', label: 'Team', seasonal: false },
                    { key: 'price', label: 'Price', seasonal: false },
                    { key: 'ownership', label: 'Own%', seasonal: false },
                    { key: 'games', label: 'GP', seasonal: true },
                    { key: 'minutes', label: 'Mins', seasonal: true },
                    { key: 'points', label: 'Pts', seasonal: true },
                    { key: 'cleanSheets', label: 'CS', seasonal: true },
                    { key: 'goalsConceded', label: 'GC', seasonal: true },
                    { key: 'xGC', label: 'xGC', seasonal: true },
                    { key: 'goals', label: 'G', seasonal: true },
                    { key: 'assists', label: 'A', seasonal: true },
                    { key: 'xG', label: 'xG', seasonal: true },
                    { key: 'xA', label: 'xA', seasonal: true },
                    { key: 'bigChancesCreated', label: 'BCC', seasonal: true },
                    { key: 'keyPasses', label: 'KP', seasonal: true },
                    { key: 'bonus', label: 'Bonus', seasonal: true },
                    { key: 'bps', label: 'BPS', seasonal: true },
                    { key: 'ict', label: 'ICT', seasonal: true },
                    { key: 'fdr', label: 'FDR', seasonal: false },
                    { key: 'fixtures', label: 'Next 3', seasonal: false }
                ];
            } else if (position === 'MID') {
                columns = [
                    { key: 'name', label: 'Player', seasonal: false },
                    { key: 'team', label: 'Team', seasonal: false },
                    { key: 'price', label: 'Price', seasonal: false },
                    { key: 'ownership', label: 'Own%', seasonal: false },
                    { key: 'games', label: 'GP', seasonal: true },
                    { key: 'minutes', label: 'Mins', seasonal: true },
                    { key: 'points', label: 'Pts', seasonal: true },
                    { key: 'goals', label: 'G', seasonal: true },
                    { key: 'assists', label: 'A', seasonal: true },
                    { key: 'xG', label: 'xG', seasonal: true },
                    { key: 'xA', label: 'xA', seasonal: true },
                    { key: 'xGI', label: 'xGI', seasonal: true },
                    { key: 'bigChancesCreated', label: 'BCC', seasonal: true },
                    { key: 'bigChancesMissed', label: 'BCM', seasonal: true },
                    { key: 'keyPasses', label: 'KP', seasonal: true },
                    { key: 'cleanSheets', label: 'CS', seasonal: true },
                    { key: 'bonus', label: 'Bonus', seasonal: true },
                    { key: 'bps', label: 'BPS', seasonal: true },
                    { key: 'ict', label: 'ICT', seasonal: true },
                    { key: 'influence', label: 'Infl', seasonal: true },
                    { key: 'creativity', label: 'Creat', seasonal: true },
                    { key: 'threat', label: 'Threat', seasonal: true },
                    { key: 'fdr', label: 'FDR', seasonal: false },
                    { key: 'fixtures', label: 'Next 3', seasonal: false }
                ];
            } else if (position === 'FWD') {
                columns = [
                    { key: 'name', label: 'Player', seasonal: false },
                    { key: 'team', label: 'Team', seasonal: false },
                    { key: 'price', label: 'Price', seasonal: false },
                    { key: 'ownership', label: 'Own%', seasonal: false },
                    { key: 'games', label: 'GP', seasonal: true },
                    { key: 'minutes', label: 'Mins', seasonal: true },
                    { key: 'points', label: 'Pts', seasonal: true },
                    { key: 'goals', label: 'G', seasonal: true },
                    { key: 'assists', label: 'A', seasonal: true },
                    { key: 'xG', label: 'xG', seasonal: true },
                    { key: 'xA', label: 'xA', seasonal: true },
                    { key: 'xGI', label: 'xGI', seasonal: true },
                    { key: 'bigChancesCreated', label: 'BCC', seasonal: true },
                    { key: 'bigChancesMissed', label: 'BCM', seasonal: true },
                    { key: 'keyPasses', label: 'KP', seasonal: true },
                    { key: 'bonus', label: 'Bonus', seasonal: true },
                    { key: 'bps', label: 'BPS', seasonal: true },
                    { key: 'ict', label: 'ICT', seasonal: true },
                    { key: 'influence', label: 'Infl', seasonal: true },
                    { key: 'creativity', label: 'Creat', seasonal: true },
                    { key: 'threat', label: 'Threat', seasonal: true },
                    { key: 'fdr', label: 'FDR', seasonal: false },
                    { key: 'fixtures', label: 'Next 3', seasonal: false }
                ];
            }

            const tableId = `table-${position}`;
            let html = `<div class="table-container"><table id="${tableId}"><thead>`;
            
            // Header row with sortable columns and tooltips
            html += '<tr>';
            // Add compare checkbox column
            html += '<th style="width: 40px; text-align: center;" title="Select players to compare">‚öñÔ∏è</th>';
            let colIndex = 1; // Start at 1 because of compare column
            columns.forEach(col => {
                const tooltip = tooltips[col.label] || '';
                if (!col.seasonal) {
                    html += `<th onclick="sortTable('${tableId}', ${colIndex}, '${col.key}')" title="${tooltip}">${col.label}<span class="sort-icon">‚áÖ</span></th>`;
                    colIndex++;
                } else {
                    html += `<th onclick="sortTable('${tableId}', ${colIndex}, '${col.key}-season')" title="${tooltip} (Season Average)">${col.label} (S)<span class="sort-icon">‚áÖ</span></th>`;
                    colIndex++;
                    html += `<th onclick="sortTable('${tableId}', ${colIndex}, '${col.key}-l5')" title="${tooltip} (Last 5 Games Average)">${col.label} (L5)<span class="sort-icon">‚áÖ</span></th>`;
                    colIndex++;
                    html += `<th onclick="sortTable('${tableId}', ${colIndex}, '${col.key}-trend')" title="${tooltips['Œî%']}">Œî%<span class="sort-icon">‚áÖ</span></th>`;
                    colIndex++;
                }
            });
            html += '</tr>';

            // Filter row
            html += '<tr class="filter-row">';
            // Empty cell for compare column
            html += '<th></th>';
            colIndex = 1;
            columns.forEach(col => {
                if (!col.seasonal) {
                    const placeholder = (col.key === 'name' || col.key === 'team') ? 'Filter...' : 
                                      (col.key === 'price') ? '¬£' :
                                      (col.key === 'ownership') ? '%' : '>=';
                    html += `<th><input type="text" class="filter-input" placeholder="${placeholder}" onkeyup="filterTable('${tableId}', ${colIndex})"></th>`;
                    colIndex++;
                } else {
                    html += `<th><input type="text" class="filter-input" placeholder=">=" onkeyup="filterTable('${tableId}', ${colIndex})"></th>`;
                    colIndex++;
                    html += `<th><input type="text" class="filter-input" placeholder=">=" onkeyup="filterTable('${tableId}', ${colIndex})"></th>`;
                    colIndex++;
                    html += `<th><input type="text" class="filter-input" placeholder=">=" onkeyup="filterTable('${tableId}', ${colIndex})"></th>`;
                    colIndex++;
                }
            });
            html += '</tr>';
            
            html += '</thead><tbody>';

            filteredAnalyses.forEach(analysis => {
                const isSelected = selectedForComparison.includes(analysis.id);
                html += '<tr>';
                
                // Compare checkbox column
                html += `<td style="text-align: center;">
                    <input type="checkbox" class="compare-checkbox" 
                        ${isSelected ? 'checked' : ''} 
                        onchange="togglePlayerComparison(${analysis.id}, this)"
                        style="cursor: pointer; width: 16px; height: 16px; accent-color: var(--accent-green);">
                </td>`;
                
                columns.forEach(col => {
                    if (col.key === 'name') {
                        html += `<td data-value="${analysis.name}">${analysis.name}</td>`;
                    } else if (col.key === 'team') {
                        html += `<td data-value="${analysis.team}"><span class="team-badge">${analysis.team}</span></td>`;
                    } else if (col.key === 'price') {
                        // Price column
                        const price = analysis.price || 0;
                        html += `<td data-value="${price.toFixed(1)}">¬£${price.toFixed(1)}</td>`;
                    } else if (col.key === 'ownership') {
                        // Ownership column
                        const ownership = analysis.selectedBy || analysis.selectedByPercent || 0;
                        html += `<td data-value="${ownership.toFixed(1)}">${ownership.toFixed(1)}%</td>`;
                    } else if (col.key === 'fdr') {
                        // FDR column with visual indicators
                        if (analysis.fixtures && analysis.fixtures.avgFDR3) {
                            const fdr = analysis.fixtures.avgFDR3;
                            let fdrColor = '#f59e0b'; // default yellow
                            let fdrIcon = 'üü°';
                            
                            if (fdr < 2.6) {
                                fdrColor = '#10b981';
                                fdrIcon = 'üü¢üü¢';
                            } else if (fdr < 2.9) {
                                fdrColor = '#22c55e';
                                fdrIcon = 'üü¢';
                            } else if (fdr < 3.1) {
                                fdrColor = '#f59e0b';
                                fdrIcon = 'üü°';
                            } else if (fdr < 3.4) {
                                fdrColor = '#fb923c';
                                fdrIcon = 'üü†';
                            } else {
                                fdrColor = '#ef4444';
                                fdrIcon = 'üî¥';
                            }
                            
                            html += `<td data-value="${fdr.toFixed(2)}" style="font-weight: 700; color: ${fdrColor};">${fdrIcon} ${fdr.toFixed(1)}</td>`;
                        } else {
                            html += `<td data-value="999">-</td>`;
                        }
                    } else if (col.key === 'fixtures') {
                        // Next 3 fixtures text
                        if (analysis.fixtures && analysis.fixtures.fixtureString) {
                            html += `<td data-value="${analysis.fixtures.fixtureString}" style="font-size: 9px; white-space: nowrap;">${analysis.fixtures.fixtureString}</td>`;
                        } else {
                            html += `<td data-value="zzz">-</td>`;
                        }
                    } else if (col.seasonal) {
                        const seasonVal = analysis.season[col.key];
                        const l5Val = analysis.l5[col.key];
                        const trend = calculateTrend(seasonVal, l5Val, analysis.season.games, analysis.l5.games);
                        
                        // For 'games', show the count directly, not an average
                        if (col.key === 'games') {
                            html += `<td data-value="${seasonVal}">${seasonVal}</td>`;
                            html += `<td data-value="${l5Val}">${l5Val}</td>`;
                            html += `<td class="trend-neutral" data-value="0">-</td>`;
                        } else {
                            const seasonAvg = seasonVal / analysis.season.games;
                            const l5Avg = l5Val / analysis.l5.games;
                            
                            const reverse = ['goalsConceded', 'xGC', 'ownGoals', 'penaltiesMissed', 'yellowCards', 'redCards', 'bigChancesMissed'].includes(col.key);
                            const trendClass = getTrendClass(trend, reverse);
                            
                            html += `<td data-value="${seasonAvg.toFixed(1)}">${seasonAvg.toFixed(1)}</td>`;
                            html += `<td data-value="${l5Avg.toFixed(1)}">${l5Avg.toFixed(1)}</td>`;
                            html += `<td class="${trendClass}" data-value="${trend.toFixed(0)}">${trend > 0 ? '+' : ''}${trend.toFixed(0)}%</td>`;
                        }
                    }
                });
                
                html += '</tr>';
            });

            html += '</tbody></table></div>';
            return html;
        }

        function sortTable(tableId, columnIndex, columnKey) {
            const table = document.getElementById(tableId);
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            // Determine sort direction
            const currentSort = table.dataset.sortColumn;
            const currentDir = table.dataset.sortDirection || 'asc';
            const newDir = (currentSort === columnIndex.toString() && currentDir === 'asc') ? 'desc' : 'asc';
            
            // Update sort indicators
            table.querySelectorAll('.sort-icon').forEach(icon => {
                icon.classList.remove('active');
                icon.textContent = '‚áÖ';
            });
            
            const header = table.querySelectorAll('thead tr:first-child th')[columnIndex];
            const sortIcon = header.querySelector('.sort-icon');
            sortIcon.classList.add('active');
            sortIcon.textContent = newDir === 'asc' ? '‚Üë' : '‚Üì';
            
            // Sort rows
            rows.sort((a, b) => {
                const aCell = a.cells[columnIndex];
                const bCell = b.cells[columnIndex];
                
                const aValue = aCell.dataset.value || aCell.textContent;
                const bValue = bCell.dataset.value || bCell.textContent;
                
                // Try to parse as number
                const aNum = parseFloat(aValue);
                const bNum = parseFloat(bValue);
                
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return newDir === 'asc' ? aNum - bNum : bNum - aNum;
                }
                
                // String comparison
                return newDir === 'asc' 
                    ? aValue.localeCompare(bValue)
                    : bValue.localeCompare(aValue);
            });
            
            // Re-append sorted rows
            rows.forEach(row => tbody.appendChild(row));
            
            // Store sort state
            table.dataset.sortColumn = columnIndex;
            table.dataset.sortDirection = newDir;
        }

        function filterTable(tableId, columnIndex) {
            const table = document.getElementById(tableId);
            const filterInputs = table.querySelectorAll('.filter-row input');
            const tbody = table.querySelector('tbody');
            const rows = tbody.querySelectorAll('tr');
            
            rows.forEach(row => {
                let showRow = true;
                
                filterInputs.forEach((input, idx) => {
                    const filterValue = input.value.trim();
                    if (filterValue) {
                        const cell = row.cells[idx];
                        const cellValue = cell.dataset.value || cell.textContent;
                        const cellText = cellValue.toLowerCase();
                        const filterText = filterValue.toLowerCase();
                        
                        // Try to parse as number for numeric comparisons
                        const cellNum = parseFloat(cellValue);
                        const isNumeric = !isNaN(cellNum);
                        
                        let matches = false;
                        
                        // Check for comparison operators
                        if (isNumeric) {
                            if (filterText.startsWith('>=')) {
                                const threshold = parseFloat(filterText.substring(2));
                                matches = !isNaN(threshold) && cellNum >= threshold;
                            } else if (filterText.startsWith('<=')) {
                                const threshold = parseFloat(filterText.substring(2));
                                matches = !isNaN(threshold) && cellNum <= threshold;
                            } else if (filterText.startsWith('>')) {
                                const threshold = parseFloat(filterText.substring(1));
                                matches = !isNaN(threshold) && cellNum > threshold;
                            } else if (filterText.startsWith('<')) {
                                const threshold = parseFloat(filterText.substring(1));
                                matches = !isNaN(threshold) && cellNum < threshold;
                            } else {
                                // If just a number is entered, treat it as >= for numeric columns
                                const threshold = parseFloat(filterText);
                                if (!isNaN(threshold)) {
                                    matches = cellNum >= threshold;
                                } else {
                                    // Text search fallback
                                    matches = cellText.includes(filterText);
                                }
                            }
                        } else {
                            // Text search for non-numeric columns
                            matches = cellText.includes(filterText);
                        }
                        
                        if (!matches) {
                            showRow = false;
                        }
                    }
                });
                
                row.style.display = showRow ? '' : 'none';
            });
        }

        async function loadData(forceRefresh = false) {
            try {
                showLoading(true);
                
                // PRIORITY 1: Try to load from static file (GitHub Actions generated)
                if (!forceRefresh) {
                    try {
                        updateStatus('Loading from pre-generated data file...', 'loading');
                        const response = await fetch('/data/players-data.json');
                        
                        if (response.ok) {
                            console.log('Loading from static file (GitHub Actions)');
                            const staticData = await response.json();
                            
                            // Process the pre-fetched data
                            bootstrapData = {
                                teams: staticData.teams,
                                element_types: staticData.elementTypes,
                                elements: staticData.players.map(p => ({
                                    id: p.id,
                                    web_name: p.name,
                                    element_type: p.position,
                                    team: p.team,
                                    now_cost: p.price,
                                    form: p.form,
                                    selected_by_percent: p.ownership,
                                    total_points: p.totalPoints,
                                    minutes: p.minutes
                                }))
                            };
                            
                            // Build teams object
                            teams = {};
                            staticData.teams.forEach(team => {
                                teams[team.id] = {
                                    id: team.id,
                                    name: team.name,
                                    short_name: team.short_name,
                                    strength: team.strength
                                };
                            });
                            
                            // Load fixtures
                            updateStatus('Loading fixtures...', 'loading');
                            await loadFixtures();
                            console.log('‚úÖ Fixtures loaded');
                            
                            // Process player analyses from pre-fetched history
                            const analyses = [];
                            for (const player of staticData.players) {
                                if (player.history && player.history.length > 0) {
                                    const season = calculateStats(player.history, false);
                                    const l5 = calculateStats(player.history, true);
                                    
                                    if (season && l5) {
                                        // Calculate fixture difficulty
                                        let fixtureData = null;
                                        const playerFixtures = teamFixtures[player.team] || [];
                                        
                                        if (playerFixtures.length > 0) {
                                            const next3 = playerFixtures.slice(0, 3);
                                            const next5 = playerFixtures.slice(0, 5);
                                            
                                            const avgFDR3 = next3.reduce((sum, f) => sum + f.difficulty, 0) / next3.length;
                                            const avgFDR5 = next5.reduce((sum, f) => sum + f.difficulty, 0) / next5.length;
                                            
                                            const fixtureString = next3.map(f => {
                                                const opponentTeam = teams[f.opponent];
                                                const opponentName = opponentTeam ? opponentTeam.short_name : 'UNK';
                                                return `${opponentName}(${f.is_home ? 'H' : 'A'})`;
                                            }).join(', ');
                                            
                                            fixtureData = {
                                                avgFDR3: avgFDR3,
                                                avgFDR5: avgFDR5,
                                                next3: next3,
                                                next5: next5,
                                                fixtureString: fixtureString
                                            };
                                        }
                                        
                                        analyses.push({
                                            id: player.id,
                                            name: player.name,
                                            fullName: player.fullName || player.name,
                                            position: player.position,
                                            team: teams[player.team].short_name,
                                            teamId: player.team,
                                            price: player.price / 10,
                                            form: parseFloat(player.form),
                                            selectedBy: parseFloat(player.ownership),
                                            totalPoints: player.totalPoints,
                                            season,
                                            l5,
                                            fixtures: fixtureData
                                        });
                                    }
                                }
                            }
                            
                            console.log(`Loaded ${analyses.length} players from static file`);
                            
                            // Store analyses globally for comparison feature
                            allAnalyses = analyses;
                            
                            // Detect current gameweek and phase
                            currentGameweek = detectCurrentGameweek(analyses);
                            currentPhase = getSeasonPhase(currentGameweek);
                            console.log(`üìÖ Detected GW${currentGameweek} (${currentPhase} season phase)`);
                            
                            // Render everything
                            document.getElementById('section-RECOMMENDATIONS').innerHTML = generateRecommendations(analyses);
                            document.getElementById('section-FORM').innerHTML = generateFormPlayers(analyses);
                            document.getElementById('section-CHARTS').innerHTML = generateCharts(analyses);
                            document.getElementById('section-FIXTURES').innerHTML = generateFixtureTicker(analyses);
                            document.getElementById('section-GK').innerHTML = createTable('GK', analyses);
                            document.getElementById('section-DEF').innerHTML = createTable('DEF', analyses);
                            document.getElementById('section-MID').innerHTML = createTable('MID', analyses);
                            document.getElementById('section-FWD').innerHTML = createTable('FWD', analyses);
                            
                            const lastUpdated = new Date(staticData.metadata.lastUpdated).toLocaleString();
                            updateStatus(`‚úì Loaded ${analyses.length} players from static file (updated: ${lastUpdated})`, 'success');
                            showLoading(false);
                            showCacheInfo();
                            return;
                        }
                    } catch (error) {
                        console.log('Static file not available, trying cache:', error.message);
                    }
                }
                
                // PRIORITY 2: Check localStorage cache (if static file unavailable)
                if (!forceRefresh) {
                    const cached = localStorage.getItem('fpl_players_cache');
                    const cacheTime = localStorage.getItem('fpl_players_cache_time');
                    
                    if (cached && cacheTime) {
                        const ageHours = (Date.now() - parseInt(cacheTime)) / (1000 * 60 * 60);
                        
                        if (ageHours < 24) {
                            console.log(`Using cached data (${ageHours.toFixed(1)} hours old)`);
                            updateStatus('Loading from cache...', 'loading');
                            
                            try {
                                const cachedData = JSON.parse(cached);
                                bootstrapData = cachedData.bootstrapData;
                                
                                // Build teams object from cached bootstrap data
                                teams = {};
                                bootstrapData.teams.forEach(team => {
                                    teams[team.id] = {
                                        id: team.id,
                                        name: team.name,
                                        short_name: team.short_name,
                                        strength: team.strength
                                    };
                                });
                                
                                // Load fresh fixtures (they change frequently)
                                updateStatus('Loading fixtures...', 'loading');
                                await loadFixtures();
                                console.log('‚úÖ Fixtures loaded');
                                
                                // Get analyses from cache and add fixture data
                                const analyses = cachedData.analyses.map(player => {
                                    // Calculate fixture difficulty for cached players
                                    let fixtureData = null;
                                    const playerFixtures = teamFixtures[player.teamId] || [];
                                    
                                    if (playerFixtures.length > 0) {
                                        const next3 = playerFixtures.slice(0, 3);
                                        const next5 = playerFixtures.slice(0, 5);
                                        
                                        const avgFDR3 = next3.reduce((sum, f) => sum + f.difficulty, 0) / next3.length;
                                        const avgFDR5 = next5.reduce((sum, f) => sum + f.difficulty, 0) / next5.length;
                                        
                                        const fixtureString = next3.map(f => {
                                            const opponentTeam = teams[f.opponent];
                                            const opponentName = opponentTeam ? opponentTeam.short_name : 'UNK';
                                            return `${opponentName}(${f.is_home ? 'H' : 'A'})`;
                                        }).join(', ');
                                        
                                        fixtureData = {
                                            avgFDR3: avgFDR3,
                                            avgFDR5: avgFDR5,
                                            next3: next3,
                                            next5: next5,
                                            fixtureString: fixtureString
                                        };
                                    }
                                    
                                    return {
                                        ...player,
                                        fixtures: fixtureData
                                    };
                                });
                                
                                // Detect current gameweek and phase
                                currentGameweek = detectCurrentGameweek(analyses);
                                currentPhase = getSeasonPhase(currentGameweek);
                                console.log(`üìÖ Detected GW${currentGameweek} (${currentPhase} season phase)`);
                                
                                // Store analyses globally for comparison feature
                                allAnalyses = analyses;
                                
                                // Render everything
                                document.getElementById('section-RECOMMENDATIONS').innerHTML = generateRecommendations(analyses);
                                document.getElementById('section-FORM').innerHTML = generateFormPlayers(analyses);
                                document.getElementById('section-CHARTS').innerHTML = generateCharts(analyses);
                                document.getElementById('section-FIXTURES').innerHTML = generateFixtureTicker(analyses);
                                document.getElementById('section-GK').innerHTML = createTable('GK', analyses);
                                document.getElementById('section-DEF').innerHTML = createTable('DEF', analyses);
                                document.getElementById('section-MID').innerHTML = createTable('MID', analyses);
                                document.getElementById('section-FWD').innerHTML = createTable('FWD', analyses);
                                
                                updateStatus(`‚úì Loaded ${analyses.length} players from cache (${ageHours.toFixed(1)}h old)`, 'success');
                                showLoading(false);
                                showCacheInfo();
                                return;
                            } catch (e) {
                                console.warn('Cache corrupted, fetching fresh data');
                                localStorage.removeItem('fpl_players_cache');
                                localStorage.removeItem('fpl_players_cache_time');
                            }
                        } else {
                            console.log('Cache expired (>24 hours), fetching fresh data');
                        }
                    }
                }
                
                // PRIORITY 3: Fetch from API (last resort)
                console.log('Fetching from FPL API (this may take 30-60 seconds)');
                updateStatus('Fetching bootstrap data from API...', 'loading');

                bootstrapData = await fetchBootstrapData();
                
                // Build teams object FIRST - needed for fixtures and player analysis
                teams = {};
                bootstrapData.teams.forEach(team => {
                    teams[team.id] = {
                        id: team.id,
                        name: team.name,
                        short_name: team.short_name,
                        strength: team.strength
                    };
                });
                
                console.log('‚úÖ Teams object built:', Object.keys(teams).length, 'teams');
                
                // Load fixtures AFTER teams object is ready
                updateStatus('Loading fixtures...', 'loading');
                await loadFixtures();
                console.log('‚úÖ Fixtures loaded');

                // Get all players from the API
                const allPlayers = bootstrapData.elements.map(player => ({
                    id: player.id,
                    name: player.web_name,
                    position: player.element_type,
                    team: teams[player.team].short_name,
                    teamId: player.team,
                    totalPoints: player.total_points,
                    minutes: player.minutes,
                    price: player.now_cost / 10, // Convert to actual price
                    form: parseFloat(player.form),
                    selectedByPercent: parseFloat(player.selected_by_percent)
                }));

                // Filter players who have played at least some minutes
                const activePlayers = allPlayers.filter(p => p.minutes > 0);
                
                updateStatus(`Found ${activePlayers.length} active players. Starting detailed analysis...`, 'loading');
                console.log(`Analyzing ${activePlayers.length} players with game time`);

                const analyses = [];
                let successCount = 0;
                let skipCount = 0;
                
                for (let i = 0; i < activePlayers.length; i++) {
                    const player = activePlayers[i];
                    
                    if (i % 10 === 0) {
                        updateStatus(`Analyzing ${player.name} (${i + 1}/${activePlayers.length}) - ${successCount} loaded, ${skipCount} skipped`, 'loading');
                    }
                    
                    try {
                        // This makes the actual API call to element-summary endpoint
                        const analysis = await analyzePlayer(player.id, player.name, player.position, player.team, player.teamId);
                        if (analysis) {
                            // Add price and form data to analysis
                            analysis.price = player.price;
                            analysis.form = player.form;
                            analysis.selectedByPercent = player.selectedByPercent;
                            analyses.push(analysis);
                            successCount++;
                        } else {
                            skipCount++;
                        }
                    } catch (error) {
                        console.error(`Failed to analyze ${player.name}:`, error);
                        skipCount++;
                    }
                    
                    // Add a small delay every 20 players to avoid overwhelming the API
                    if (i > 0 && i % 20 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                }

                console.log(`Analysis complete: ${successCount} players loaded, ${skipCount} skipped`);
                
                // Cache the results
                try {
                    const cacheData = {
                        bootstrapData: bootstrapData,
                        analyses: analyses,
                        timestamp: Date.now()
                    };
                    localStorage.setItem('fpl_players_cache', JSON.stringify(cacheData));
                    localStorage.setItem('fpl_players_cache_time', Date.now().toString());
                    console.log('Data cached successfully');
                } catch (e) {
                    console.warn('Failed to cache data (localStorage full?):', e);
                }

                // Detect current gameweek and phase
                currentGameweek = detectCurrentGameweek(analyses);
                currentPhase = getSeasonPhase(currentGameweek);
                console.log(`üìÖ Detected GW${currentGameweek} (${currentPhase} season phase)`);

                // Store analyses globally for comparison feature
                allAnalyses = analyses;

                // Generate recommendations
                document.getElementById('section-RECOMMENDATIONS').innerHTML = generateRecommendations(analyses);
                
                // Generate form players
                document.getElementById('section-FORM').innerHTML = generateFormPlayers(analyses);
                
                // Generate charts and fixture ticker
                document.getElementById('section-CHARTS').innerHTML = generateCharts(analyses);
                document.getElementById('section-FIXTURES').innerHTML = generateFixtureTicker(analyses);

                // Render tables
                document.getElementById('section-GK').innerHTML = createTable('GK', analyses);
                document.getElementById('section-DEF').innerHTML = createTable('DEF', analyses);
                document.getElementById('section-MID').innerHTML = createTable('MID', analyses);
                document.getElementById('section-FWD').innerHTML = createTable('FWD', analyses);

                updateStatus(`‚úì Successfully loaded ${successCount} players (${skipCount} skipped due to no data)`, 'success');
                showLoading(false);
                showCacheInfo();

            } catch (error) {
                console.error('Error loading data:', error);
                updateStatus(`‚úó Error: ${error.message}`, 'error');
                showLoading(false);
            }
        }

        // ============================================
        // REUSABLE PLAYER STATS COMPONENT
        // Single source of truth for stat display
        // ============================================
        
        /**
         * Renders player stats in a consistent format
         * @param {Object} player - Player object with l5, season, etc.
         * @param {string} position - 'GK', 'DEF', 'MID', 'FWD'
         * @param {string} format - 'card' (recommendation cards) or 'grid' (form player cards)
         * @returns {string} HTML string
         */
        function renderPlayerStats(player, position, format = 'card') {
            const l5Games = player.l5?.games || 1;
            const l5AvgPoints = (player.l5?.points || 0) / l5Games;
            const valueScore = player.valueScore || (l5AvgPoints / player.price);
            
            // Position-specific stats
            let stats = [];
            
            if (position === 'GK') {
                const csRate = (player.l5?.cleanSheets || 0) / l5Games;
                const savesPerGame = (player.l5?.saves || 0) / l5Games;
                const bonusPerGame = (player.l5?.bonus || 0) / l5Games;
                const penaltiesSaved = player.l5?.penaltiesSaved || 0;
                
                stats = [
                    { label: 'Pts/Game', value: l5AvgPoints.toFixed(1), color: 'var(--text)' },
                    { label: 'CS Rate', value: `${(csRate * 100).toFixed(0)}%`, color: csRate >= 0.4 ? 'var(--accent-green)' : 'var(--text)' },
                    { label: 'Saves/G', value: savesPerGame.toFixed(1), color: savesPerGame >= 3 ? 'var(--accent-green)' : 'var(--text)' },
                    { label: 'Bonus/G', value: bonusPerGame.toFixed(1), color: bonusPerGame >= 1 ? 'var(--accent-yellow)' : 'var(--text)' }
                ];
                
                // Add penalty saves badge if any
                if (penaltiesSaved > 0) {
                    stats.push({ label: 'üß§ Pen Saves', value: penaltiesSaved.toString(), color: 'var(--accent-green)', highlight: true });
                }
                
            } else if (position === 'DEF') {
                const csRate = (player.l5?.cleanSheets || 0) / l5Games;
                const l5xGI = (player.l5?.xGI || 0) / l5Games;
                const bonusPerGame = (player.l5?.bonus || 0) / l5Games;
                
                stats = [
                    { label: 'Pts/Game', value: l5AvgPoints.toFixed(1), color: 'var(--text)' },
                    { label: 'Value', value: `${valueScore.toFixed(2)}/¬£m`, color: valueScore >= 1.0 ? 'var(--accent-green)' : 'var(--text)' },
                    { label: 'CS Rate', value: `${(csRate * 100).toFixed(0)}%`, color: csRate >= 0.4 ? 'var(--accent-green)' : 'var(--text)' },
                    { label: 'xGI/G', value: l5xGI.toFixed(2), color: l5xGI >= 0.15 ? 'var(--accent-green)' : 'var(--text)' }
                ];
                
            } else {
                // MID/FWD
                const l5xGI = (player.l5?.xGI || 0) / l5Games;
                const l5Goals = (player.l5?.goals || 0) / l5Games;
                const l5Assists = (player.l5?.assists || 0) / l5Games;
                
                stats = [
                    { label: 'Pts/Game', value: l5AvgPoints.toFixed(1), color: 'var(--text)' },
                    { label: 'Value', value: `${valueScore.toFixed(2)}/¬£m`, color: valueScore >= 1.0 ? 'var(--accent-green)' : 'var(--text)' },
                    { label: 'xGI/G', value: l5xGI.toFixed(2), color: l5xGI >= 0.4 ? 'var(--accent-green)' : 'var(--text)' },
                    { label: 'G+A/G', value: (l5Goals + l5Assists).toFixed(2), color: (l5Goals + l5Assists) >= 0.4 ? 'var(--accent-green)' : 'var(--text)' }
                ];
            }
            
            // Render based on format
            if (format === 'grid') {
                // Form player card format (4-column grid)
                return `
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 12px; padding: 10px; background: var(--bg-dark); border-radius: 3px;">
                        <div>
                            <div style="font-size: 9px; color: var(--text-dim); text-transform: uppercase;">Price</div>
                            <div style="font-size: 12px; font-weight: 600; color: var(--accent-green);">¬£${player.price.toFixed(1)}m</div>
                        </div>
                        <div>
                            <div style="font-size: 9px; color: var(--text-dim); text-transform: uppercase;">Owned</div>
                            <div style="font-size: 12px; font-weight: 600; color: var(--text);">${(player.selectedBy || player.ownership || 0).toFixed(1)}%</div>
                        </div>
                        ${stats.slice(0, 2).map(s => `
                            <div>
                                <div style="font-size: 9px; color: var(--text-dim); text-transform: uppercase;">${s.label}</div>
                                <div style="font-size: 12px; font-weight: 600; color: ${s.color};">${s.value}</div>
                            </div>
                        `).join('')}
                    </div>
                `;
            } else {
                // Recommendation card format (3-column)
                return stats.slice(0, 3).map(s => `
                    <div class="player-rec-stat">
                        <span class="player-rec-stat-label">${s.label}</span>
                        <span class="player-rec-stat-value" style="color: ${s.color};">${s.value}</span>
                    </div>
                `).join('');
            }
        }
        
        /**
         * Renders fixture info badge
         * @param {Object} player - Player object with fixtures
         * @returns {string} HTML string
         */
        function renderFixtureBadge(player) {
            if (!player.fixtures || !player.fixtures.avgFDR3) return '';
            
            const fdr = player.fixtures.avgFDR3;
            const fixtureStr = player.fixtures.fixtureString || '';
            let badgeColor = 'var(--text-dim)';
            let badgeText = 'Neutral';
            
            if (fdr < 2.5) { badgeColor = 'var(--accent-green)'; badgeText = 'üü¢üü¢ Easy'; }
            else if (fdr < 3.0) { badgeColor = '#88cc88'; badgeText = 'üü¢ Good'; }
            else if (fdr > 3.5) { badgeColor = 'var(--accent-red)'; badgeText = 'üî¥ Tough'; }
            else { badgeColor = 'var(--accent-yellow)'; badgeText = 'üü° Mixed'; }
            
            return `
                <div style="margin-top: 8px; padding: 6px 8px; background: var(--bg-darker); border-radius: 3px; border-left: 2px solid ${badgeColor};">
                    <div style="font-size: 8px; color: var(--text-dim); text-transform: uppercase; margin-bottom: 2px;">Next 3 Fixtures</div>
                    <div style="font-size: 9px; color: ${badgeColor}; font-weight: 500;">${badgeText} (FDR ${fdr.toFixed(1)})</div>
                    <div style="font-size: 8px; color: var(--text-dim); margin-top: 2px;">${fixtureStr}</div>
                </div>
            `;
        }

        // ============================================
        // RECOMMENDATION CATEGORY FUNCTIONS
        // ============================================
        
        /**
         * Get top captaincy options - highest ceiling players
         */
        function getTopCaptainOptions(analyses, limit = 5) {
            const positionMap = { 1: 'GK', 2: 'DEF', 3: 'MID', 4: 'FWD' };
            
            return analyses
                .filter(p => {
                    const pos = positionMap[p.position];
                    if (pos === 'GK') return false;
                    if (!p.l5 || p.l5.games < 3) return false;
                    const l5Mins = p.l5.minutes / p.l5.games;
                    return l5Mins >= 70;
                })
                .map(p => {
                    const l5Games = p.l5.games;
                    const l5xGI = p.l5.xGI / l5Games;
                    const l5Pts = p.l5.points / l5Games;
                    const fdr = p.fixtures?.avgFDR3 || 3;
                    
                    const captaincyScore = (l5xGI * 40) + (l5Pts * 3) + 
                                          (fdr < 2.5 ? 20 : fdr < 3 ? 10 : fdr > 3.5 ? -15 : 0) +
                                          (p.l5.goals / l5Games * 10) + (p.l5.bonus / l5Games * 2);
                    
                    return { ...p, captaincyScore, l5xGI, l5Pts, fdr, position: positionMap[p.position] };
                })
                .sort((a, b) => b.captaincyScore - a.captaincyScore)
                .slice(0, limit);
        }
        
        /**
         * Get best transfer targets - form + fixtures + differential value
         */
        function getBestTransferTargets(analyses, limit = 5) {
            const positionMap = { 1: 'GK', 2: 'DEF', 3: 'MID', 4: 'FWD' };
            
            return analyses
                .filter(p => {
                    if (!p.l5 || !p.season || p.l5.games < 4 || p.season.games < 6) return false;
                    const l5Mins = p.l5.minutes / p.l5.games;
                    return l5Mins >= 70 && p.price > 4.0;
                })
                .map(p => {
                    const l5Games = p.l5.games;
                    const seasonGames = p.season.games;
                    const l5Pts = p.l5.points / l5Games;
                    const seasonPts = p.season.points / seasonGames;
                    const l5xGI = p.l5.xGI / l5Games;
                    const fdr = p.fixtures?.avgFDR3 || 3;
                    const ownership = p.selectedBy || 0;
                    
                    const formImprovement = ((l5Pts - seasonPts) / seasonPts) * 100;
                    
                    const transferScore = (formImprovement > 0 ? formImprovement * 0.5 : 0) +
                                         (l5xGI * 30) + (l5Pts * 2) +
                                         (fdr < 2.5 ? 15 : fdr < 3 ? 8 : fdr > 3.5 ? -10 : 0) +
                                         (ownership < 10 ? 10 : ownership < 20 ? 5 : 0);
                    
                    return { ...p, transferScore, formImprovement, l5xGI, l5Pts, fdr, ownership, position: positionMap[p.position] };
                })
                .sort((a, b) => b.transferScore - a.transferScore)
                .slice(0, limit);
        }
        
        /**
         * Get set-and-forget picks - consistent performers
         */
        function getSetAndForgetPicks(analyses, limit = 5) {
            const positionMap = { 1: 'GK', 2: 'DEF', 3: 'MID', 4: 'FWD' };
            
            return analyses
                .filter(p => {
                    if (!p.l5 || !p.season || p.season.games < 10) return false;
                    const seasonMins = p.season.minutes / p.season.games;
                    const l5Mins = p.l5.minutes / p.l5.games;
                    return seasonMins >= 80 && l5Mins >= 80;
                })
                .map(p => {
                    const seasonGames = p.season.games;
                    const seasonPts = p.season.points / seasonGames;
                    const seasonxGI = p.season.xGI / seasonGames;
                    const value = seasonPts / p.price;
                    const l5Pts = p.l5.points / p.l5.games;
                    const l5xGI = p.l5.xGI / p.l5.games;
                    
                    const consistencyScore = (seasonPts * 5) + (value * 15) + (seasonxGI * 20) +
                                            ((p.season.minutes / p.season.games) / 90 * 10);
                    
                    return { ...p, consistencyScore, seasonPts, value, seasonxGI, l5Pts, l5xGI, position: positionMap[p.position] };
                })
                .sort((a, b) => b.consistencyScore - a.consistencyScore)
                .slice(0, limit);
        }
        
        /**
         * Get differentials - low ownership gems (<5%)
         */
        function getDifferentials(analyses, limit = 5) {
            const positionMap = { 1: 'GK', 2: 'DEF', 3: 'MID', 4: 'FWD' };
            
            return analyses
                .filter(p => {
                    if (!p.l5 || p.l5.games < 3) return false;
                    const ownership = p.selectedBy || 0;
                    const l5Mins = p.l5.minutes / p.l5.games;
                    const l5Pts = p.l5.points / p.l5.games;
                    return ownership < 5 && l5Mins >= 60 && l5Pts >= 2;
                })
                .map(p => {
                    const l5Games = p.l5.games;
                    const l5Pts = p.l5.points / l5Games;
                    const l5xGI = p.l5.xGI / l5Games;
                    const ownership = p.selectedBy || 0;
                    const fdr = p.fixtures?.avgFDR3 || 3;
                    
                    const diffScore = (l5Pts * 5) + (l5xGI * 25) + ((5 - ownership) * 3) + (fdr < 3 ? 10 : 0);
                    
                    return { ...p, diffScore, l5Pts, l5xGI, ownership, fdr, position: positionMap[p.position] };
                })
                .sort((a, b) => b.diffScore - a.diffScore)
                .slice(0, limit);
        }
        
        /**
         * Get players to avoid - sell candidates
         */
        function getPlayersToAvoid(analyses, limit = 5) {
            const positionMap = { 1: 'GK', 2: 'DEF', 3: 'MID', 4: 'FWD' };
            
            return analyses
                .filter(p => {
                    if (!p.l5 || !p.season || p.l5.games < 3) return false;
                    const ownership = p.selectedBy || 0;
                    return ownership >= 10;
                })
                .map(p => {
                    const l5Games = p.l5.games;
                    const seasonGames = p.season.games;
                    const l5Pts = p.l5.points / l5Games;
                    const seasonPts = p.season.points / seasonGames;
                    const l5xGI = p.l5.xGI / l5Games;
                    const l5Mins = p.l5.minutes / l5Games;
                    const fdr = p.fixtures?.avgFDR3 || 3;
                    const ownership = p.selectedBy || 0;
                    
                    const formDecline = ((seasonPts - l5Pts) / seasonPts) * 100;
                    
                    let avoidScore = 0;
                    if (formDecline > 20) avoidScore += formDecline * 0.5;
                    if (l5Mins < 70) avoidScore += (70 - l5Mins) * 0.5;
                    if (fdr > 3.5) avoidScore += (fdr - 3) * 10;
                    if (l5xGI < 0.15 && positionMap[p.position] !== 'GK') avoidScore += 10;
                    if (l5Pts / p.price < 0.5) avoidScore += 10;
                    
                    const reasons = [];
                    if (formDecline > 20) reasons.push(`üìâ Form -${formDecline.toFixed(0)}%`);
                    if (l5Mins < 70) reasons.push(`‚ö†Ô∏è ${l5Mins.toFixed(0)}min avg`);
                    if (fdr > 3.5) reasons.push(`üî¥ FDR ${fdr.toFixed(1)}`);
                    if (l5xGI < 0.15 && positionMap[p.position] !== 'GK') reasons.push(`üìä Low xGI`);
                    
                    return { ...p, avoidScore, formDecline, l5Pts, l5xGI, l5Mins, fdr, ownership, reasons, position: positionMap[p.position] };
                })
                .filter(p => p.avoidScore >= 15)
                .sort((a, b) => b.avoidScore - a.avoidScore)
                .slice(0, limit);
        }
        
        /**
         * Render a special category card
         */
        function renderSpecialCategoryCard(player, rank, categoryType) {
            const positionColors = { 'GK': '#f59e0b', 'DEF': '#3b82f6', 'MID': '#10b981', 'FWD': '#ef4444' };
            const categoryColors = {
                'captain': 'var(--accent-yellow)',
                'transfer': 'var(--accent-green)',
                'setforget': 'var(--accent-blue)',
                'differential': '#a855f7',
                'avoid': 'var(--accent-red)'
            };
            
            const posColor = positionColors[player.position] || 'var(--text)';
            const catColor = categoryColors[categoryType] || 'var(--accent-green)';
            
            const scoreLabels = {
                'captain': ['Cap Score', player.captaincyScore],
                'transfer': ['Transfer', player.transferScore],
                'setforget': ['Consistency', player.consistencyScore],
                'differential': ['Diff Score', player.diffScore],
                'avoid': ['Risk', player.avoidScore]
            };
            
            const [scoreLabel, scoreVal] = scoreLabels[categoryType] || ['Score', 0];
            const l5Pts = player.l5Pts || (player.l5?.points / player.l5?.games) || 0;
            const l5xGI = player.l5xGI || (player.l5?.xGI / player.l5?.games) || 0;
            const fdr = player.fdr || player.fixtures?.avgFDR3 || 3;
            const ownership = player.ownership || player.selectedBy || 0;
            
            let fdrColor = fdr < 2.5 ? 'var(--accent-green)' : fdr < 3 ? '#88cc88' : fdr > 3.5 ? 'var(--accent-red)' : 'var(--accent-yellow)';
            
            return `
                <div style="background: var(--surface-light); border-left: 3px solid ${catColor}; padding: 12px; border-radius: 4px; margin-bottom: 10px;">
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
                        <div>
                            <div style="font-size: 13px; font-weight: 600; color: var(--text);">
                                <span style="color: ${catColor}; margin-right: 6px;">#${rank}</span>${player.name}
                            </div>
                            <div style="font-size: 10px; color: var(--text-dim); margin-top: 2px;">
                                ${player.team} ‚Ä¢ <span style="color: ${posColor}; font-weight: 500;">${player.position}</span> ‚Ä¢ ¬£${player.price.toFixed(1)}m
                            </div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 14px; font-weight: 700; color: ${catColor};">${(scoreVal || 0).toFixed(0)}</div>
                            <div style="font-size: 8px; color: var(--text-dim); text-transform: uppercase;">${scoreLabel}</div>
                        </div>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; padding: 8px; background: var(--bg-dark); border-radius: 3px; font-size: 10px;">
                        <div><div style="color: var(--text-dim); font-size: 8px;">Pts/G</div><div style="color: var(--text); font-weight: 600;">${l5Pts.toFixed(1)}</div></div>
                        <div><div style="color: var(--text-dim); font-size: 8px;">xGI/G</div><div style="color: var(--text); font-weight: 600;">${l5xGI.toFixed(2)}</div></div>
                        <div><div style="color: var(--text-dim); font-size: 8px;">FDR</div><div style="color: ${fdrColor}; font-weight: 600;">${fdr.toFixed(1)}</div></div>
                        <div><div style="color: var(--text-dim); font-size: 8px;">Own%</div><div style="color: var(--text); font-weight: 600;">${ownership.toFixed(1)}%</div></div>
                    </div>
                    ${categoryType === 'avoid' && player.reasons?.length ? `<div style="margin-top: 8px; font-size: 10px; color: var(--accent-red);">${player.reasons.slice(0, 2).join(' ‚Ä¢ ')}</div>` : ''}
                </div>
            `;
        }

        function generateRecommendations(analyses) {
            const positionMap = { 1: 'GK', 2: 'DEF', 3: 'MID', 4: 'FWD' };
            const positionNames = { 'GK': 'Goalkeepers', 'DEF': 'Defenders', 'MID': 'Midfielders', 'FWD': 'Forwards' };
            const cfg = RECOMMENDATION_CONFIG; // Shorthand
            
            // Get phase-adjusted weights
            const weights = getPhaseAdjustedWeights();
            const phaseInfo = getPhaseInfo();
            
            // Get special categories
            const captainOptions = getTopCaptainOptions(analyses);
            const transferTargets = getBestTransferTargets(analyses);
            const setAndForget = getSetAndForgetPicks(analyses);
            const differentials = getDifferentials(analyses);
            const avoidList = getPlayersToAvoid(analyses);
            
            // Phase info banner
            let html = `
                <div style="margin-bottom: 25px; padding: 20px; background: var(--surface); border-left: 4px solid ${phaseInfo.color}; border-radius: 4px;">
                    <div style="display: flex; justify-content: space-between; align-items: start; flex-wrap: wrap; gap: 15px;">
                        <div>
                            <h2 style="color: ${phaseInfo.color}; margin-bottom: 8px; font-size: 18px; font-family: 'Space Mono', monospace;">
                                ${phaseInfo.emoji} ${phaseInfo.name} (GW${currentGameweek})
                            </h2>
                            <p style="font-size: 12px; color: var(--text-dim); line-height: 1.5; margin-bottom: 10px;">
                                ${phaseInfo.description}
                            </p>
                            <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                                ${phaseInfo.tips.map(tip => `<span style="font-size: 10px; color: var(--text); background: var(--surface-light); padding: 4px 10px; border-radius: 12px;">üí° ${tip}</span>`).join('')}
                            </div>
                        </div>
                        <div style="text-align: right; min-width: 120px;">
                            <div style="font-size: 9px; color: var(--text-dim); text-transform: uppercase; margin-bottom: 4px;">Weight Focus</div>
                            <div style="font-size: 10px; color: var(--text);">
                                ${currentPhase === 'early' ? 'üìÖ Fixtures +50%<br>üîí Minutes +50%<br>üìä Stats -30%' : ''}
                                ${currentPhase === 'mid' ? '‚öñÔ∏è Balanced<br>All weights normal' : ''}
                                ${currentPhase === 'late' ? 'üéØ Differentials +15<br>üî• Form +20%<br>üìÖ Fixtures +30%' : ''}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Special Categories Section
            html += `
                <div style="margin-bottom: 30px;">
                    <h2 style="color: var(--accent-green); font-family: 'Space Mono', monospace; margin-bottom: 20px; font-size: 16px;">
                        üéØ Quick Actions
                    </h2>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px;">
                        
                        <!-- Captain Options -->
                        <div style="background: var(--surface); padding: 15px; border-radius: 6px; border: 1px solid var(--border);">
                            <h3 style="color: var(--accent-yellow); font-size: 14px; margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
                                üëë Captain Options
                                <span style="font-size: 9px; background: var(--accent-yellow); color: var(--bg-dark); padding: 2px 6px; border-radius: 8px;">TOP ${captainOptions.length}</span>
                            </h3>
                            ${captainOptions.length > 0 ? captainOptions.map((p, i) => renderSpecialCategoryCard(p, i + 1, 'captain')).join('') : '<div style="color: var(--text-dim); font-size: 11px;">No strong captain options found</div>'}
                        </div>
                        
                        <!-- Transfer Targets -->
                        <div style="background: var(--surface); padding: 15px; border-radius: 6px; border: 1px solid var(--border);">
                            <h3 style="color: var(--accent-green); font-size: 14px; margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
                                üîÑ Transfer Targets
                                <span style="font-size: 9px; background: var(--accent-green); color: var(--bg-dark); padding: 2px 6px; border-radius: 8px;">TOP ${transferTargets.length}</span>
                            </h3>
                            ${transferTargets.length > 0 ? transferTargets.map((p, i) => renderSpecialCategoryCard(p, i + 1, 'transfer')).join('') : '<div style="color: var(--text-dim); font-size: 11px;">No strong transfer targets found</div>'}
                        </div>
                        
                        <!-- Set & Forget -->
                        <div style="background: var(--surface); padding: 15px; border-radius: 6px; border: 1px solid var(--border);">
                            <h3 style="color: var(--accent-blue); font-size: 14px; margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
                                üîí Set & Forget
                                <span style="font-size: 9px; background: var(--accent-blue); color: var(--bg-dark); padding: 2px 6px; border-radius: 8px;">TOP ${setAndForget.length}</span>
                            </h3>
                            ${setAndForget.length > 0 ? setAndForget.map((p, i) => renderSpecialCategoryCard(p, i + 1, 'setforget')).join('') : '<div style="color: var(--text-dim); font-size: 11px;">No set-and-forget picks found</div>'}
                        </div>
                        
                        <!-- Differentials -->
                        <div style="background: var(--surface); padding: 15px; border-radius: 6px; border: 1px solid var(--border);">
                            <h3 style="color: #a855f7; font-size: 14px; margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
                                üíé Differentials
                                <span style="font-size: 9px; background: #a855f7; color: white; padding: 2px 6px; border-radius: 8px;">&lt;5% OWNED</span>
                            </h3>
                            ${differentials.length > 0 ? differentials.map((p, i) => renderSpecialCategoryCard(p, i + 1, 'differential')).join('') : '<div style="color: var(--text-dim); font-size: 11px;">No differentials meeting criteria</div>'}
                        </div>
                        
                        <!-- Avoid List -->
                        <div style="background: var(--surface); padding: 15px; border-radius: 6px; border: 1px solid rgba(239, 68, 68, 0.3);">
                            <h3 style="color: var(--accent-red); font-size: 14px; margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
                                ‚ö†Ô∏è Avoid / Sell
                                <span style="font-size: 9px; background: var(--accent-red); color: white; padding: 2px 6px; border-radius: 8px;">CAUTION</span>
                            </h3>
                            ${avoidList.length > 0 ? avoidList.map((p, i) => renderSpecialCategoryCard(p, i + 1, 'avoid')).join('') : '<div style="color: var(--text-dim); font-size: 11px;">No highly-owned players to avoid</div>'}
                        </div>
                        
                    </div>
                </div>
            `;
            
            // Section header for position picks
            html += `
                <h2 style="color: var(--accent-green); font-family: 'Space Mono', monospace; margin-bottom: 20px; font-size: 16px;">
                    üìã By Position
                </h2>
            `;
            
            html += '<div class="recommendations-container">';
            
            ['GK', 'DEF', 'MID', 'FWD'].forEach(position => {
                const players = analyses.filter(a => positionMap[a.position] === position);
                
                // Enhanced filtering criteria based on FPL research
                const eligiblePlayers = players.filter(p => {
                    const avgMinutes = p.season.minutes / p.season.games;
                    const l5AvgMinutes = p.l5.minutes / p.l5.games;
                    
                    // Must be "nailed on" - consistent high minutes in last 5
                    const isNailedOn = l5AvgMinutes >= cfg.thresholds.nailedOnMinutes && p.l5.games >= cfg.thresholds.minL5Games;
                    
                    // Must have reasonable season minutes (not just a recent flash)
                    const hasSeasonMinutes = avgMinutes >= cfg.thresholds.minAvgMinutes && p.season.games >= cfg.thresholds.minSeasonGames;
                    
                    return isNailedOn && hasSeasonMinutes && p.price > cfg.thresholds.minPrice;
                });
                
                // Calculate comprehensive scores for each player
                eligiblePlayers.forEach(p => {
                    const l5Games = p.l5.games;
                    const seasonGames = p.season.games;
                    
                    // VALUE METRIC (most important in FPL)
                    const l5AvgPoints = p.l5.points / l5Games;
                    const pointsPerMillion = l5AvgPoints / p.price;
                    
                    // UNDERLYING STATS (xG, xA - better predictors than actual goals)
                    const l5xGI = p.l5.xGI / l5Games;
                    const seasonxGI = p.season.xGI / seasonGames;
                    
                    // FORM vs EXPECTED (identify over/underperformers)
                    const l5ActualGI = (p.l5.goals + p.l5.assists) / l5Games;
                    const xGIDiff = l5ActualGI - l5xGI; // Negative means underperforming (due for returns)
                    
                    // MINUTES CONSISTENCY (rotation risk)
                    const minutesConsistency = (p.l5.minutes / p.l5.games) / 90;
                    
                    // POSITION-SPECIFIC SCORING
                    let positionScore = 0;
                    
                    if (position === 'GK') {
                        const l5CS = p.l5.cleanSheets / l5Games;
                        const l5SavesPerGame = p.l5.saves / l5Games;
                        const l5xGC = p.l5.xGC / l5Games;
                        const l5PenaltiesSaved = (p.l5.penaltiesSaved || 0) / l5Games;
                        const l5BonusPerGame = (p.l5.bonus || 0) / l5Games;
                        const l5AssistsPerGame = (p.l5.assists || 0) / l5Games;
                        
                        const gkWeights = cfg.gkScoring;
                        
                        // Enhanced GK score:
                        // - Clean sheets (4 pts each, most important)
                        // - Saves bonus (every 3 saves = 1 pt, ~0.33 per save)
                        // - Penalty saves (huge 5 pt swing)
                        // - Bonus points (indicates BPS performance)
                        // - Distribution/assists (rare but valuable)
                        // - Penalize high xGC (team defensive weakness)
                        positionScore = (l5CS * gkWeights.cleanSheet) +
                                       (l5SavesPerGame * gkWeights.savesPerGame) +
                                       (l5PenaltiesSaved * gkWeights.penaltySave) +
                                       (l5BonusPerGame * gkWeights.bonusPerGame) +
                                       (l5AssistsPerGame * gkWeights.assistPerGame) -
                                       (l5xGC * gkWeights.xGCPenalty);
                        
                        // Store GK-specific metrics for display
                        p.gkMetrics = {
                            csRate: l5CS,
                            savesPerGame: l5SavesPerGame,
                            penaltiesSaved: p.l5.penaltiesSaved || 0,
                            bonusPerGame: l5BonusPerGame,
                            xGC: l5xGC
                        };
                        
                    } else if (position === 'DEF') {
                        const l5CS = p.l5.cleanSheets / l5Games;
                        const l5xGC = p.l5.xGC / l5Games;
                        
                        // DEF score: Clean sheets + attacking threat, penalize high xGC
                        positionScore = (l5CS * 12) + (l5xGI * 20) - (l5xGC * 1.5);
                        
                    } else {
                        // MID/FWD score: Pure attacking threat via xGI
                        positionScore = l5xGI * 25;
                        
                        // Bonus for big chance creation (creativity)
                        const l5BCC = p.l5.bigChancesCreated / l5Games;
                        positionScore += l5BCC * 3;
                    }
                    
                    // FIXTURE DIFFICULTY BONUS (phase-adjusted)
                    let fixtureBonus = 0;
                    if (p.fixtures && p.fixtures.avgFDR3) {
                        if (p.fixtures.avgFDR3 < cfg.fdr.easy) fixtureBonus = weights.easyFixtures;
                        else if (p.fixtures.avgFDR3 < cfg.fdr.favorable) fixtureBonus = weights.favorableFixtures;
                        else if (p.fixtures.avgFDR3 > cfg.fdr.tough) fixtureBonus = weights.toughFixtures;
                    }
                    
                    // DIFFERENTIAL BONUS (late season only)
                    let differentialBonus = 0;
                    const ownership = p.selectedBy || 0;
                    if (weights.differentialBonus > 0 && ownership < cfg.gameweekPhases.differentialThreshold) {
                        differentialBonus = weights.differentialBonus;
                    }
                    
                    // COMPREHENSIVE SCORE combining all factors (phase-adjusted)
                    p.recommendationScore = (
                        pointsPerMillion * weights.value +
                        positionScore * weights.positionScore +
                        minutesConsistency * weights.minutesConsistency +
                        (l5xGI > seasonxGI ? weights.formImprovement : weights.formDecline) +
                        fixtureBonus +
                        differentialBonus
                    );
                    
                    // Store metrics for display
                    p.fixtureBonus = fixtureBonus;
                    p.differentialBonus = differentialBonus;
                    p.valueScore = pointsPerMillion;
                    p.l5xGIperGame = l5xGI;
                    p.minutesConsistency = minutesConsistency;
                    // Only flag underperformance if xGI is meaningful (otherwise they're just not good)
                    p.isUnderperforming = l5xGI >= cfg.thresholds.minXGIForUnderperformance && 
                                          (l5xGI - l5ActualGI) > cfg.thresholds.underperformanceXGI;
                });
                
                // Sort by recommendation score
                eligiblePlayers.sort((a, b) => b.recommendationScore - a.recommendationScore);
                
                // Get budget threshold from config
                const threshold = cfg.budgetCaps[position];
                const budgetPlayers = eligiblePlayers.filter(p => p.price <= threshold).slice(0, cfg.display.maxPlayersPerCategory);
                const premiumPlayers = eligiblePlayers.filter(p => p.price > threshold).slice(0, cfg.display.maxPlayersPerCategory);
                
                html += `
                    <div class="position-recommendations">
                        <h2>${positionNames[position]}</h2>
                        <div class="recommendations-grid">
                            ${createRecommendationCategory('Budget Options', budgetPlayers, position, threshold, 'budget')}
                            ${createRecommendationCategory('Premium Options', premiumPlayers, position, threshold, 'premium')}
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            return html;
        }
        
        function createRecommendationCategory(title, players, position, priceThreshold, categoryType) {
            const categoryClass = categoryType;
            
            let html = `<div class="rec-category ${categoryClass}">
                <h3>${title} (${categoryType === 'budget' ? '‚â§' : '>'} ¬£${priceThreshold.toFixed(1)}m)</h3>`;
            
            const cfg = RECOMMENDATION_CONFIG; // Shorthand
            const weights = getPhaseAdjustedWeights(); // Get phase-adjusted weights
            
            if (players.length === 0) {
                html += '<div class="no-data" style="padding: 20px;">No players meet the criteria</div>';
            } else {
                players.forEach(player => {
                    const l5AvgPoints = player.l5.points / player.l5.games;
                    const l5AvgMinutes = player.l5.minutes / player.l5.games;
                    const ownership = player.selectedBy || 0;
                    
                    // Generate smart reasoning based on metrics
                    let reasons = [];
                    
                    // Differential bonus (late season)
                    if (player.differentialBonus > 0) {
                        reasons.push(`üéØ Differential pick (${ownership.toFixed(1)}% owned)`);
                    }
                    
                    if (player.valueScore > cfg.thresholds.excellentValue) {
                        reasons.push(`Excellent value at ${player.valueScore.toFixed(2)} pts/¬£m`);
                    } else if (player.valueScore > cfg.thresholds.goodValue) {
                        reasons.push(`Good value at ${player.valueScore.toFixed(2)} pts/¬£m`);
                    }
                    
                    if (player.minutesConsistency > cfg.thresholds.highMinutesConsistency) {
                        reasons.push('Nailed on starter');
                    }
                    
                    if (player.isUnderperforming) {
                        reasons.push('Underperforming xGI - due returns');
                    }
                    
                    if (player.l5xGIperGame > cfg.thresholds.strongXGI && (position === 'MID' || position === 'FWD')) {
                        reasons.push(`Strong xGI of ${player.l5xGIperGame.toFixed(2)}/game`);
                    }
                    
                    const pointsTrend = calculateTrend(player.season.points, player.l5.points, player.season.games, player.l5.games);
                    if (pointsTrend > 20) {
                        reasons.push('Exceptional recent form');
                    } else if (pointsTrend > 10) {
                        reasons.push('Improving form');
                    }
                    
                    // Add fixture-based reasoning (use base weights for comparison since fixtureBonus was calculated with phase weights)
                    if (player.fixtureBonus >= weights.easyFixtures) {
                        reasons.push('üü¢ Easy fixtures ahead');
                    } else if (player.fixtureBonus >= weights.favorableFixtures) {
                        reasons.push('üü¢ Favorable fixtures');
                    } else if (player.fixtureBonus <= weights.toughFixtures) {
                        reasons.push('‚ö†Ô∏è Tough fixtures - short-term caution');
                    }
                    
                    if (reasons.length === 0) {
                        reasons.push('Consistent performer');
                    }
                    
                    const reason = reasons.slice(0, 2).join(' ‚Ä¢ ');
                    
                    // Use reusable stats component
                    const keyStats = renderPlayerStats(player, position, 'card');
                    
                    // Use reusable fixture badge component
                    const fixtureBadge = renderFixtureBadge(player);
                    
                    html += `
                        <div class="player-rec-card">
                            <div class="player-rec-header">
                                <span class="player-rec-name">${player.name}</span>
                                <span class="player-rec-price">¬£${player.price.toFixed(1)}m</span>
                            </div>
                            <div class="player-rec-team">${player.team} ‚Ä¢ ${l5AvgMinutes.toFixed(0)}min avg</div>
                            <div class="player-rec-stats">
                                ${keyStats}
                            </div>
                            ${fixtureBadge}
                            <div class="rec-reason">
                                üí° ${reason}
                            </div>
                        </div>
                    `;
                });
            }
            
            html += '</div>';
            return html;
        }
        
        function generateFormPlayers(analyses) {
            const positionMap = { 1: 'GK', 2: 'DEF', 3: 'MID', 4: 'FWD' };
            const formSignals = [];
            const cfg = RECOMMENDATION_CONFIG; // Shorthand
            const fs = cfg.formSignals; // Form signals config
            
            // Analyze all players for form signals
            analyses.forEach(player => {
                const position = positionMap[player.position];
                
                // Skip players with no meaningful data
                if (player.l5.games < 3 || player.season.games < 5) return;
                
                let signal = 0;
                const reasons = [];
                
                // Calculate key metrics
                const l5AvgPoints = player.l5.points / player.l5.games;
                const seasonAvgPoints = player.season.points / player.season.games;
                const l5AvgMinutes = player.l5.minutes / player.l5.games;
                const l5xGIperGame = player.l5.xGI / player.l5.games;
                const ownership = player.selectedBy || 0;
                
                // 1. Form Improvement (30 points max)
                const pointsImprovement = ((l5AvgPoints - seasonAvgPoints) / seasonAvgPoints) * 100;
                if (pointsImprovement > fs.formSurge.threshold) {
                    signal += fs.formSurge.points;
                    reasons.push(`üî• Form surging (+${pointsImprovement.toFixed(0)}%)`);
                } else if (pointsImprovement > fs.formImproving.threshold) {
                    signal += fs.formImproving.points;
                    reasons.push(`üìà Form improving (+${pointsImprovement.toFixed(0)}%)`);
                } else if (l5AvgPoints >= fs.hotForm.threshold) {
                    signal += fs.hotForm.points;
                    reasons.push(`Hot form (${l5AvgPoints.toFixed(1)} pts/game)`);
                }
                
                // 2. xGI Quality (25 points max)
                if (position !== 'GK') {
                    if (l5xGIperGame >= fs.eliteXGI.threshold) {
                        signal += fs.eliteXGI.points;
                        reasons.push(`üíé Elite xGI (${l5xGIperGame.toFixed(2)}/game)`);
                    } else if (l5xGIperGame >= fs.strongXGI.threshold) {
                        signal += fs.strongXGI.points;
                        reasons.push(`‚ö° Strong xGI (${l5xGIperGame.toFixed(2)}/game)`);
                    } else if (l5xGIperGame >= fs.goodXGI.threshold) {
                        signal += fs.goodXGI.points;
                        reasons.push(`Good xGI (${l5xGIperGame.toFixed(2)}/game)`);
                    }
                } else {
                    // For GK, use clean sheets
                    const l5CS = player.l5.cleanSheets / player.l5.games;
                    if (l5CS >= cfg.gkThresholds.excellentCS) {
                        signal += fs.eliteXGI.points;
                        reasons.push(`üíé Excellent CS rate (${(l5CS * 100).toFixed(0)}%)`);
                    } else if (l5CS >= cfg.gkThresholds.strongCS) {
                        signal += fs.strongXGI.points;
                        reasons.push(`Strong CS rate (${(l5CS * 100).toFixed(0)}%)`);
                    }
                }
                
                // 3. Minutes Trend (15 points max)
                if (l5AvgMinutes >= fs.nailedOn.threshold) {
                    signal += fs.nailedOn.points;
                    reasons.push(`‚úÖ Nailed on (${l5AvgMinutes.toFixed(0)} mins)`);
                } else if (l5AvgMinutes >= fs.regularStarter.threshold) {
                    signal += fs.regularStarter.points;
                    reasons.push(`Regular starter (${l5AvgMinutes.toFixed(0)} mins)`);
                } else if (l5AvgMinutes >= fs.gettingMinutes.threshold) {
                    signal += fs.gettingMinutes.points;
                    reasons.push(`Getting minutes (${l5AvgMinutes.toFixed(0)} mins)`);
                }
                
                // 4. Ownership Sweet Spot (10 points max)
                if (ownership < fs.ultraDifferential.threshold && l5AvgPoints >= 3) {
                    signal += fs.ultraDifferential.points;
                    reasons.push(`üîì Ultra differential (${ownership.toFixed(1)}%)`);
                } else if (ownership < fs.lowOwned.threshold && l5AvgPoints >= 2) {
                    signal += fs.lowOwned.points;
                    reasons.push(`Low owned (${ownership.toFixed(1)}%)`);
                }
                
                // 5. Underperformance Bonus (10 points)
                const l5ActualGI = (player.l5.goals + player.l5.assists) / player.l5.games;
                const underperformance = l5xGIperGame - l5ActualGI;
                if (underperformance > fs.underperforming.xgiGap && l5xGIperGame > fs.underperforming.minXGI) {
                    signal += fs.underperforming.points;
                    reasons.push(`üìä Underperforming xGI - DUE`);
                }
                
                // 6. Value Score (10 points)
                const ptsPerMillion = l5AvgPoints / player.price;
                if (ptsPerMillion > fs.greatValue.threshold) {
                    signal += fs.greatValue.points;
                    reasons.push(`üí∞ Great value (${ptsPerMillion.toFixed(2)}/¬£m)`);
                } else if (ptsPerMillion > fs.goodValueForm.threshold) {
                    signal += fs.goodValueForm.points;
                    reasons.push(`Good value (${ptsPerMillion.toFixed(2)}/¬£m)`);
                }
                
                // 7. Fixture Difficulty (15 points max)
                if (player.fixtures && player.fixtures.avgFDR3) {
                    const fdr = player.fixtures.avgFDR3;
                    if (fdr < cfg.fdr.easy) {
                        signal += fs.easyFixturesForm.points;
                        reasons.push(`üü¢üü¢ Easy fixtures (FDR ${fdr.toFixed(1)})`);
                    } else if (fdr < cfg.fdr.favorable) {
                        signal += fs.goodFixturesForm.points;
                        reasons.push(`üü¢ Good fixtures (FDR ${fdr.toFixed(1)})`);
                    } else if (fdr > cfg.fdr.tough) {
                        signal += fs.toughFixturesForm.points;
                        reasons.push(`üî¥ Tough fixtures (FDR ${fdr.toFixed(1)})`);
                    }
                }
                
                // Only include if signal meets minimum threshold
                if (signal >= fs.minSignal && reasons.length > 0) {
                    formSignals.push({
                        ...player,
                        signal,
                        reasons,
                        position,
                        priority: signal >= fs.highPriority ? 'HIGH' : signal >= fs.mediumPriority ? 'MEDIUM' : 'WATCH',
                        l5AvgPoints,
                        l5AvgMinutes,
                        l5xGIperGame,
                        ownership
                    });
                }
            });
            
            // Sort by signal strength
            formSignals.sort((a, b) => b.signal - a.signal);
            
            // Take top N players
            const topSignals = formSignals.slice(0, cfg.display.maxFormPlayers);
            
            // Group by priority
            const highPriority = topSignals.filter(p => p.priority === 'HIGH');
            const mediumPriority = topSignals.filter(p => p.priority === 'MEDIUM');
            const watchList = topSignals.filter(p => p.priority === 'WATCH');
            
            let html = `
                <div style="margin-bottom: 25px; padding: 20px; background: var(--surface); border-left: 4px solid var(--accent-red); border-radius: 4px;">
                    <h2 style="color: var(--accent-red); margin-bottom: 12px; font-size: 18px; font-family: 'Space Mono', monospace;">
                        üî• FORM PLAYERS - Early Detection
                    </h2>
                    <p style="font-size: 12px; color: var(--text-dim); line-height: 1.6; margin-bottom: 10px;">
                        These players show <strong>early form signals</strong> based on improving stats, minutes consistency, and low ownership.
                        Act NOW before template managers catch on and prices rise. Perfect for transfers and wildcards.
                    </p>
                    <div style="display: flex; gap: 20px; margin-top: 15px; font-size: 11px;">
                        <span style="color: var(--accent-red);">üî• <strong>HIGH (${fs.highPriority}+)</strong> = Buy now</span>
                        <span style="color: var(--accent-yellow);">‚ö° <strong>MEDIUM (${fs.mediumPriority}-${fs.highPriority - 1})</strong> = Strong option</span>
                        <span style="color: var(--accent-blue);">üëÄ <strong>WATCH (${fs.minSignal}-${fs.mediumPriority - 1})</strong> = Monitor</span>
                    </div>
                </div>
            `;
            
            if (topSignals.length === 0) {
                html += '<div style="padding: 30px; text-align: center; color: var(--text-dim);">No strong form signals detected. Check back after next gameweek.</div>';
                return html;
            }
            
            // Helper to create player card
            function createFormPlayerCard(player, rank) {
                const priorityColor = player.priority === 'HIGH' ? 'var(--accent-red)' : 
                                    player.priority === 'MEDIUM' ? 'var(--accent-yellow)' : 'var(--accent-blue)';
                const priorityEmoji = player.priority === 'HIGH' ? 'üî•' : 
                                     player.priority === 'MEDIUM' ? '‚ö°' : 'üëÄ';
                
                // Use reusable components
                const statsGrid = renderPlayerStats(player, player.position, 'grid');
                const fixtureBadge = renderFixtureBadge(player);
                
                return `
                    <div style="background: var(--surface-light); border-left: 3px solid ${priorityColor}; padding: 15px; border-radius: 4px; margin-bottom: 12px;">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                            <div>
                                <div style="font-size: 14px; font-weight: 600; color: var(--text); margin-bottom: 4px;">
                                    #${rank} ${player.name}
                                </div>
                                <div style="font-size: 10px; color: var(--text-dim);">
                                    ${player.team} ‚Ä¢ ${player.position} ‚Ä¢ ${player.l5AvgMinutes.toFixed(0)}min avg
                                </div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 16px; font-weight: 700; color: ${priorityColor};">
                                    ${priorityEmoji} ${player.signal}
                                </div>
                                <div style="font-size: 9px; color: var(--text-dim); text-transform: uppercase;">
                                    ${player.priority}
                                </div>
                            </div>
                        </div>
                        
                        ${statsGrid}
                        
                        ${fixtureBadge ? `<div style="margin-bottom: 12px;">${fixtureBadge}</div>` : ''}
                        
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 9px; color: var(--text-dim); text-transform: uppercase; margin-bottom: 6px;">Why This Player:</div>
                            ${player.reasons.map(r => `<div style="font-size: 11px; color: var(--text); margin-bottom: 3px; padding-left: 8px; border-left: 2px solid ${priorityColor}; margin-left: 4px;">‚Ä¢ ${r}</div>`).join('')}
                        </div>
                        
                        <div style="padding: 8px 12px; background: linear-gradient(135deg, ${priorityColor} 0%, ${priorityColor}dd 100%); border-radius: 3px; text-align: center;">
                            <span style="font-size: 11px; color: white; font-weight: 600;">
                                ${player.priority === 'HIGH' ? 'üéØ BUY NOW before price rises' : 
                                  player.priority === 'MEDIUM' ? '‚ö° Strong transfer target' : 
                                  'üëÄ Monitor for next gameweek'}
                            </span>
                        </div>
                    </div>
                `;
            }
            
            // Render each priority group
            if (highPriority.length > 0) {
                html += `
                    <h3 style="color: var(--accent-red); margin: 25px 0 15px 0; font-size: 15px; font-weight: 600;">
                        üî• HIGH PRIORITY (Buy Now)
                    </h3>
                `;
                highPriority.forEach((player, i) => {
                    html += createFormPlayerCard(player, i + 1);
                });
            }
            
            if (mediumPriority.length > 0) {
                html += `
                    <h3 style="color: var(--accent-yellow); margin: 25px 0 15px 0; font-size: 15px; font-weight: 600;">
                        ‚ö° MEDIUM PRIORITY (Strong Options)
                    </h3>
                `;
                const offset = highPriority.length;
                mediumPriority.forEach((player, i) => {
                    html += createFormPlayerCard(player, offset + i + 1);
                });
            }
            
            if (watchList.length > 0) {
                html += `
                    <h3 style="color: var(--accent-blue); margin: 25px 0 15px 0; font-size: 15px; font-weight: 600;">
                        üëÄ WATCH LIST (Monitor Closely)
                    </h3>
                `;
                const offset = highPriority.length + mediumPriority.length;
                watchList.forEach((player, i) => {
                    html += createFormPlayerCard(player, offset + i + 1);
                });
            }
            
            return html;
        }

        // ============================================
        // CHARTS: Enhanced Visual Analysis
        // ============================================
        
        let chartInstances = {}; // Store chart instances for cleanup
        let chartData = {}; // Store processed data for linked highlighting
        let activePositionFilters = { GK: true, DEF: true, MID: true, FWD: true };
        let highlightedPlayer = null;
        
        // Neutral color scheme - avoids red/green confusion with FDR
        const POSITION_COLORS = {
            'GK': { bg: 'rgba(251, 191, 36, 0.8)', border: '#fbbf24', name: 'Amber' },      // Amber
            'DEF': { bg: 'rgba(139, 92, 246, 0.8)', border: '#8b5cf6', name: 'Purple' },    // Purple
            'MID': { bg: 'rgba(6, 182, 212, 0.8)', border: '#06b6d4', name: 'Cyan' },       // Cyan
            'FWD': { bg: 'rgba(236, 72, 153, 0.8)', border: '#ec4899', name: 'Pink' }       // Pink
        };
        
        // Point styles for additional differentiation
        const POSITION_STYLES = {
            'GK': 'circle',
            'DEF': 'rect',
            'MID': 'triangle',
            'FWD': 'rectRot'  // Diamond
        };
        
        function generateCharts(analyses) {
            const positionMap = { 1: 'GK', 2: 'DEF', 3: 'MID', 4: 'FWD' };
            
            // Filter valid players and enrich data
            const validPlayers = analyses
                .filter(p => p.l5 && p.l5.games >= 3 && p.season && p.season.games >= 5)
                .map(p => {
                    const pos = positionMap[p.position];
                    const l5Games = p.l5.games;
                    const seasonGames = p.season.games;
                    return {
                        ...p,
                        pos,
                        ptsPerGame: p.l5.points / l5Games,
                        xgiPerGame: p.l5.xGI / l5Games,
                        actualGI: (p.l5.goals + p.l5.assists) / l5Games,
                        minutesPerGame: p.l5.minutes / l5Games,
                        bonusPerGame: (p.l5.bonus || 0) / l5Games,
                        bpsPerGame: (p.l5.bps || p.season.bps / seasonGames) || 0,
                        ownership: p.selectedBy || 0,
                        valueScore: (p.l5.points / l5Games) / p.price,
                        // Calculate expected points (rough approximation)
                        xPts: calculateExpectedPoints(p, pos),
                        actualPts: p.l5.points / l5Games
                    };
                });
            
            // Store for linked highlighting
            chartData.players = validPlayers;
            chartData.positionMap = positionMap;
            
            let html = `
                <div style="padding: 20px;" id="chartsContainer">
                    <div style="margin-bottom: 25px; padding: 20px; background: var(--surface); border-left: 4px solid var(--accent-blue); border-radius: 4px;">
                        <h2 style="color: var(--accent-blue); font-family: 'Space Mono', monospace; margin-bottom: 10px;">
                            üìä Visual Analysis
                        </h2>
                        <p style="font-size: 12px; color: var(--text-dim); margin-bottom: 15px;">
                            Interactive charts to identify value picks, underperformers, and differentials. 
                            <strong>Click any point</strong> to add to comparison. <strong>Hover</strong> for details.
                        </p>
                        
                        <!-- Position Filter Toggles -->
                        <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                            <span style="font-size: 11px; color: var(--text-dim);">Filter Positions:</span>
                            ${['GK', 'DEF', 'MID', 'FWD'].map(pos => `
                                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; padding: 6px 12px; background: var(--surface-light); border-radius: 15px; border: 2px solid ${POSITION_COLORS[pos].border};">
                                    <input type="checkbox" id="filter-${pos}" checked onchange="togglePositionFilter('${pos}')" 
                                        style="accent-color: ${POSITION_COLORS[pos].border}; cursor: pointer;">
                                    <span style="width: 10px; height: 10px; background: ${POSITION_COLORS[pos].bg}; border-radius: 2px;"></span>
                                    <span style="font-size: 11px; color: var(--text);">${pos}</span>
                                </label>
                            `).join('')}
                            <button onclick="resetPositionFilters()" style="padding: 6px 12px; background: var(--surface-light); border: 1px solid var(--border); color: var(--text-dim); font-size: 10px; cursor: pointer; border-radius: 15px;">
                                Reset All
                            </button>
                        </div>
                    </div>
                    
                    <!-- Charts Grid -->
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(480px, 1fr)); gap: 25px;">
                        
                        <!-- 1. Price vs Points Chart -->
                        <div class="chart-card" style="background: var(--surface); padding: 20px; border-radius: 6px; border: 1px solid var(--border);">
                            <h3 style="color: var(--accent-green); font-size: 14px; margin-bottom: 5px;">
                                üí∞ Price vs Points/Game
                            </h3>
                            <p style="font-size: 10px; color: var(--text-dim); margin-bottom: 15px;">
                                Above diagonal = Great value | Below = Overpriced
                            </p>
                            <div style="position: relative; height: 350px;">
                                <canvas id="priceVsPointsChart"></canvas>
                            </div>
                        </div>
                        
                        <!-- 2. xGI vs Actual Returns Chart -->
                        <div class="chart-card" style="background: var(--surface); padding: 20px; border-radius: 6px; border: 1px solid var(--border);">
                            <h3 style="color: var(--accent-yellow); font-size: 14px; margin-bottom: 5px;">
                                üéØ xGI vs Actual G+A
                            </h3>
                            <p style="font-size: 10px; color: var(--text-dim); margin-bottom: 15px;">
                                Below line = Due returns (unlucky) | Above = May regress
                            </p>
                            <div style="position: relative; height: 350px;">
                                <canvas id="xgiVsActualChart"></canvas>
                            </div>
                        </div>
                        
                        <!-- 3. xPts vs Actual Points (NEW) -->
                        <div class="chart-card" style="background: var(--surface); padding: 20px; border-radius: 6px; border: 1px solid var(--border);">
                            <h3 style="color: #10b981; font-size: 14px; margin-bottom: 5px;">
                                üìà Expected vs Actual Points
                            </h3>
                            <p style="font-size: 10px; color: var(--text-dim); margin-bottom: 15px;">
                                Find lucky/unlucky players based on underlying stats
                            </p>
                            <div style="position: relative; height: 350px;">
                                <canvas id="xPtsVsActualChart"></canvas>
                            </div>
                        </div>
                        
                        <!-- 4. Ownership vs Form (Differential Finder) -->
                        <div class="chart-card" style="background: var(--surface); padding: 20px; border-radius: 6px; border: 1px solid var(--border);">
                            <h3 style="color: #a855f7; font-size: 14px; margin-bottom: 5px;">
                                üíé Ownership vs Form
                            </h3>
                            <p style="font-size: 10px; color: var(--text-dim); margin-bottom: 15px;">
                                Top-left quadrant = DIFFERENTIALS (low owned, high form)
                            </p>
                            <div style="position: relative; height: 350px;">
                                <canvas id="ownershipVsFormChart"></canvas>
                            </div>
                        </div>
                        
                        <!-- 5. Bonus Magnet Chart (NEW) -->
                        <div class="chart-card" style="background: var(--surface); padding: 20px; border-radius: 6px; border: 1px solid var(--border);">
                            <h3 style="color: #f59e0b; font-size: 14px; margin-bottom: 5px;">
                                üèÜ Bonus Magnets
                            </h3>
                            <p style="font-size: 10px; color: var(--text-dim); margin-bottom: 15px;">
                                Players who consistently earn bonus points (reliable returns)
                            </p>
                            <div style="position: relative; height: 350px;">
                                <canvas id="bonusMagnetChart"></canvas>
                            </div>
                        </div>
                        
                        <!-- 6. Minutes Risk Chart (NEW) -->
                        <div class="chart-card" style="background: var(--surface); padding: 20px; border-radius: 6px; border: 1px solid var(--border);">
                            <h3 style="color: #ef4444; font-size: 14px; margin-bottom: 5px;">
                                ‚è±Ô∏è Minutes vs Points (Rotation Risk)
                            </h3>
                            <p style="font-size: 10px; color: var(--text-dim); margin-bottom: 15px;">
                                Identify rotation risks - avoid players below 75 min avg
                            </p>
                            <div style="position: relative; height: 350px;">
                                <canvas id="minutesRiskChart"></canvas>
                            </div>
                        </div>
                        
                        <!-- 7. Form vs Season (Trending Players) -->
                        <div class="chart-card" style="background: var(--surface); padding: 20px; border-radius: 6px; border: 1px solid var(--border);">
                            <h3 style="color: #06b6d4; font-size: 14px; margin-bottom: 5px;">
                                üìä L5 Form vs Season Average
                            </h3>
                            <p style="font-size: 10px; color: var(--text-dim); margin-bottom: 15px;">
                                Above diagonal = Improving form | Below = Declining
                            </p>
                            <div style="position: relative; height: 350px;">
                                <canvas id="formVsSeasonChart"></canvas>
                            </div>
                        </div>
                        
                        <!-- 8. Position Distribution -->
                        <div class="chart-card" style="background: var(--surface); padding: 20px; border-radius: 6px; border: 1px solid var(--border);">
                            <h3 style="color: var(--accent-green); font-size: 14px; margin-bottom: 5px;">
                                üìà Points Distribution by Position
                            </h3>
                            <p style="font-size: 10px; color: var(--text-dim); margin-bottom: 15px;">
                                Where should you invest your budget?
                            </p>
                            <div style="position: relative; height: 350px;">
                                <canvas id="positionDistChart"></canvas>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Form Timeline Section (NEW) -->
                    <div style="margin-top: 25px; background: var(--surface); padding: 20px; border-radius: 6px; border: 1px solid var(--border);">
                        <h3 style="color: var(--accent-green); font-size: 14px; margin-bottom: 5px;">
                            üìà Form Timeline - Top Performers
                        </h3>
                        <p style="font-size: 10px; color: var(--text-dim); margin-bottom: 15px;">
                            Visual trend of recent performance. Bar height = points scored. Track who's rising and falling.
                        </p>
                        <div id="formTimelineContainer" style="overflow-x: auto;"></div>
                    </div>
                    
                    <!-- Minutes Heatmap Section (NEW) -->
                    <div style="margin-top: 25px; background: var(--surface); padding: 20px; border-radius: 6px; border: 1px solid var(--border);">
                        <h3 style="color: var(--accent-blue); font-size: 14px; margin-bottom: 5px;">
                            ‚è±Ô∏è Minutes Heatmap - Rotation Risk Tracker
                        </h3>
                        <p style="font-size: 10px; color: var(--text-dim); margin-bottom: 15px;">
                            Color-coded minutes per gameweek. Green = full 90, Red = benched. Spot rotation patterns instantly.
                        </p>
                        <div id="minutesHeatmapContainer" style="overflow-x: auto;"></div>
                    </div>
                    
                    <!-- Outliers Summary -->
                    <div id="outliersSummary" style="margin-top: 25px;"></div>
                    
                    <!-- Legend -->
                    <div style="margin-top: 20px; padding: 15px; background: var(--surface); border-radius: 6px;">
                        <div style="display: flex; gap: 25px; flex-wrap: wrap; justify-content: center; align-items: center;">
                            <span style="font-size: 11px; color: var(--text-dim);">Positions:</span>
                            ${['GK', 'DEF', 'MID', 'FWD'].map(pos => `
                                <span style="display: flex; align-items: center; gap: 6px; font-size: 11px;">
                                    <span style="width: 14px; height: 14px; background: ${POSITION_COLORS[pos].bg}; border-radius: ${pos === 'GK' ? '50%' : pos === 'DEF' ? '2px' : pos === 'MID' ? '0' : '50%'}; ${pos === 'MID' ? 'clip-path: polygon(50% 0%, 100% 100%, 0% 100%);' : ''} ${pos === 'FWD' ? 'transform: rotate(45deg); width: 10px; height: 10px;' : ''}"></span>
                                    <span style="color: ${POSITION_COLORS[pos].border};">${pos}</span>
                                </span>
                            `).join('')}
                        </div>
                        <div style="text-align: center; margin-top: 10px; font-size: 10px; color: var(--text-dim);">
                            üí° <strong>Tip:</strong> Click any data point to add player to comparison view
                        </div>
                    </div>
                </div>
            `;
            
            // Destroy existing charts
            Object.values(chartInstances).forEach(chart => chart?.destroy());
            chartInstances = {};
            
            // Schedule chart creation after DOM update
            setTimeout(() => {
                createAllCharts(validPlayers);
                generateOutliersSummary(validPlayers);
                renderFormTimeline(validPlayers);
                renderMinutesHeatmap(validPlayers);
            }, 100);
            
            return html;
        }
        
        // Calculate rough expected points
        function calculateExpectedPoints(p, pos) {
            const l5Games = p.l5.games;
            const xGI = p.l5.xGI / l5Games;
            const csRate = (p.l5.cleanSheets || 0) / l5Games;
            const mins = p.l5.minutes / l5Games;
            
            // Rough xPts calculation based on FPL scoring
            let xPts = 2; // Base appearance points
            
            if (pos === 'GK' || pos === 'DEF') {
                xPts += csRate * 4; // CS points
                xPts += xGI * 6;    // G+A for defenders
            } else if (pos === 'MID') {
                xPts += xGI * 5.5;  // Goals worth 5, assists 3
            } else {
                xPts += xGI * 4.5;  // FWD goals worth 4
            }
            
            // Bonus estimate based on xGI
            xPts += Math.min(xGI * 1.5, 2);
            
            // Minutes adjustment
            if (mins < 60) xPts *= 0.5;
            
            return xPts;
        }
        
        // Toggle position filter
        function togglePositionFilter(pos) {
            activePositionFilters[pos] = !activePositionFilters[pos];
            updateAllCharts();
        }
        
        // Reset all position filters
        function resetPositionFilters() {
            ['GK', 'DEF', 'MID', 'FWD'].forEach(pos => {
                activePositionFilters[pos] = true;
                document.getElementById(`filter-${pos}`).checked = true;
            });
            updateAllCharts();
        }
        
        // Update all charts with current filters
        function updateAllCharts() {
            if (!chartData.players) return;
            
            Object.keys(chartInstances).forEach(key => {
                const chart = chartInstances[key];
                if (chart && chart.data && chart.data.datasets) {
                    chart.data.datasets.forEach(dataset => {
                        if (dataset.position) {
                            dataset.hidden = !activePositionFilters[dataset.position];
                        }
                    });
                    chart.update();
                }
            });
        }
        
        // Handle chart click - add to comparison
        function handleChartClick(event, elements, chart) {
            if (elements.length > 0) {
                const element = elements[0];
                const datasetIndex = element.datasetIndex;
                const index = element.index;
                const player = chart.data.datasets[datasetIndex].data[index];
                
                if (player && player.id) {
                    // Add to comparison
                    const checkbox = document.querySelector(`input.compare-checkbox[onchange*="${player.id}"]`);
                    if (checkbox && !checkbox.checked) {
                        checkbox.checked = true;
                        togglePlayerComparison(player.id, checkbox);
                    }
                }
            }
        }
        
        // Create all charts
        function createAllCharts(players) {
            const baseOptions = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        backgroundColor: 'rgba(21, 25, 32, 0.95)',
                        titleColor: '#00ff88',
                        bodyColor: '#e0e5ed',
                        borderColor: '#2a3340',
                        borderWidth: 1,
                        padding: 12,
                        displayColors: false,
                        callbacks: {
                            title: function(context) {
                                const p = context[0]?.raw;
                                return p ? `${p.name} (${p.team})` : '';
                            },
                            label: function(context) {
                                const p = context.raw;
                                if (!p) return '';
                                return [
                                    `Position: ${p.pos}`,
                                    `Price: ¬£${p.price?.toFixed(1)}m`,
                                    `Pts/G: ${p.ptsPerGame?.toFixed(1)}`,
                                    `xGI/G: ${p.xgiPerGame?.toFixed(2)}`,
                                    `Owner: ${p.ownership?.toFixed(1)}%`
                                ];
                            },
                            footer: function() {
                                return 'üñ±Ô∏è Click to compare';
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        grid: { color: 'rgba(42, 51, 64, 0.5)' },
                        ticks: { color: '#8b95a5', font: { size: 10 } }
                    },
                    y: {
                        grid: { color: 'rgba(42, 51, 64, 0.5)' },
                        ticks: { color: '#8b95a5', font: { size: 10 } }
                    }
                },
                onClick: handleChartClick
            };
            
            // Helper to create datasets by position
            const createPositionDatasets = (data, xKey, yKey, includeGK = false) => {
                const positions = includeGK ? ['GK', 'DEF', 'MID', 'FWD'] : ['DEF', 'MID', 'FWD'];
                return positions.map(pos => ({
                    label: pos,
                    position: pos,
                    data: data.filter(p => p.pos === pos).map(p => ({
                        x: typeof xKey === 'function' ? xKey(p) : p[xKey],
                        y: typeof yKey === 'function' ? yKey(p) : p[yKey],
                        ...p
                    })),
                    backgroundColor: POSITION_COLORS[pos].bg,
                    borderColor: POSITION_COLORS[pos].border,
                    pointStyle: POSITION_STYLES[pos],
                    pointRadius: 7,
                    pointHoverRadius: 11,
                    hidden: !activePositionFilters[pos]
                }));
            };
            
            // 1. Price vs Points
            const ctx1 = document.getElementById('priceVsPointsChart')?.getContext('2d');
            if (ctx1) {
                // Find outliers for labels
                const outliers1 = findOutliers(players, 'price', 'ptsPerGame', 5);
                
                chartInstances.priceVsPoints = new Chart(ctx1, {
                    type: 'scatter',
                    data: {
                        datasets: [
                            // Reference line
                            {
                                label: 'Value Line',
                                data: [{x: 4, y: 2}, {x: 15, y: 8}],
                                type: 'line',
                                borderColor: 'rgba(0, 255, 136, 0.3)',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                pointRadius: 0,
                                fill: false
                            },
                            ...createPositionDatasets(players, 'price', 'ptsPerGame')
                        ]
                    },
                    options: {
                        ...baseOptions,
                        scales: {
                            x: { ...baseOptions.scales.x, title: { display: true, text: 'Price (¬£m)', color: '#8b95a5' } },
                            y: { ...baseOptions.scales.y, title: { display: true, text: 'Points/Game (L5)', color: '#8b95a5' }, min: 0 }
                        },
                        plugins: {
                            ...baseOptions.plugins,
                            datalabels: createOutlierLabels(outliers1)
                        }
                    }
                });
            }
            
            // 2. xGI vs Actual G+A
            const ctx2 = document.getElementById('xgiVsActualChart')?.getContext('2d');
            if (ctx2) {
                const outliers2 = findXGIOutliers(players, 5);
                
                chartInstances.xgiVsActual = new Chart(ctx2, {
                    type: 'scatter',
                    data: {
                        datasets: [
                            {
                                label: 'Expected Line',
                                data: [{x: 0, y: 0}, {x: 1.2, y: 1.2}],
                                type: 'line',
                                borderColor: 'rgba(0, 255, 136, 0.4)',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                pointRadius: 0,
                                fill: false
                            },
                            ...createPositionDatasets(players, 'xgiPerGame', 'actualGI')
                        ]
                    },
                    options: {
                        ...baseOptions,
                        scales: {
                            x: { ...baseOptions.scales.x, title: { display: true, text: 'xGI per Game', color: '#8b95a5' }, min: 0 },
                            y: { ...baseOptions.scales.y, title: { display: true, text: 'Actual G+A per Game', color: '#8b95a5' }, min: 0 }
                        }
                    }
                });
            }
            
            // 3. xPts vs Actual Points (NEW)
            const ctx3 = document.getElementById('xPtsVsActualChart')?.getContext('2d');
            if (ctx3) {
                chartInstances.xPtsVsActual = new Chart(ctx3, {
                    type: 'scatter',
                    data: {
                        datasets: [
                            {
                                label: 'Expected Line',
                                data: [{x: 1, y: 1}, {x: 10, y: 10}],
                                type: 'line',
                                borderColor: 'rgba(0, 255, 136, 0.4)',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                pointRadius: 0,
                                fill: false
                            },
                            ...createPositionDatasets(players, 'xPts', 'actualPts', true)
                        ]
                    },
                    options: {
                        ...baseOptions,
                        scales: {
                            x: { ...baseOptions.scales.x, title: { display: true, text: 'Expected Points/Game', color: '#8b95a5' }, min: 0 },
                            y: { ...baseOptions.scales.y, title: { display: true, text: 'Actual Points/Game', color: '#8b95a5' }, min: 0 }
                        }
                    }
                });
            }
            
            // 4. Ownership vs Form
            const ctx4 = document.getElementById('ownershipVsFormChart')?.getContext('2d');
            if (ctx4) {
                chartInstances.ownershipVsForm = new Chart(ctx4, {
                    type: 'scatter',
                    data: {
                        datasets: [
                            // Quadrant lines
                            {
                                label: 'Ownership Threshold',
                                data: [{x: 10, y: 0}, {x: 10, y: 12}],
                                type: 'line',
                                borderColor: 'rgba(168, 85, 247, 0.3)',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                pointRadius: 0,
                                fill: false
                            },
                            {
                                label: 'Form Threshold',
                                data: [{x: 0, y: 4}, {x: 60, y: 4}],
                                type: 'line',
                                borderColor: 'rgba(168, 85, 247, 0.3)',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                pointRadius: 0,
                                fill: false
                            },
                            ...createPositionDatasets(players, 'ownership', 'ptsPerGame', true)
                        ]
                    },
                    options: {
                        ...baseOptions,
                        scales: {
                            x: { ...baseOptions.scales.x, title: { display: true, text: 'Ownership %', color: '#8b95a5' } },
                            y: { ...baseOptions.scales.y, title: { display: true, text: 'Points/Game (L5)', color: '#8b95a5' }, min: 0 }
                        }
                    }
                });
            }
            
            // 5. Bonus Magnet Chart (NEW)
            const ctx5 = document.getElementById('bonusMagnetChart')?.getContext('2d');
            if (ctx5) {
                chartInstances.bonusMagnet = new Chart(ctx5, {
                    type: 'scatter',
                    data: {
                        datasets: createPositionDatasets(players, 'ptsPerGame', 'bonusPerGame', true)
                    },
                    options: {
                        ...baseOptions,
                        scales: {
                            x: { ...baseOptions.scales.x, title: { display: true, text: 'Points/Game (L5)', color: '#8b95a5' }, min: 0 },
                            y: { ...baseOptions.scales.y, title: { display: true, text: 'Bonus Points/Game', color: '#8b95a5' }, min: 0 }
                        }
                    }
                });
            }
            
            // 6. Minutes Risk Chart (NEW)
            const ctx6 = document.getElementById('minutesRiskChart')?.getContext('2d');
            if (ctx6) {
                chartInstances.minutesRisk = new Chart(ctx6, {
                    type: 'scatter',
                    data: {
                        datasets: [
                            // Rotation risk threshold line
                            {
                                label: 'Safety Line',
                                data: [{x: 75, y: 0}, {x: 75, y: 12}],
                                type: 'line',
                                borderColor: 'rgba(239, 68, 68, 0.5)',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                pointRadius: 0,
                                fill: false
                            },
                            ...createPositionDatasets(players, 'minutesPerGame', 'ptsPerGame', true)
                        ]
                    },
                    options: {
                        ...baseOptions,
                        scales: {
                            x: { ...baseOptions.scales.x, title: { display: true, text: 'Minutes/Game (L5)', color: '#8b95a5' }, min: 30, max: 95 },
                            y: { ...baseOptions.scales.y, title: { display: true, text: 'Points/Game (L5)', color: '#8b95a5' }, min: 0 }
                        }
                    }
                });
            }
            
            // 7. Form vs Season (Trending)
            const ctx7 = document.getElementById('formVsSeasonChart')?.getContext('2d');
            if (ctx7) {
                chartInstances.formVsSeason = new Chart(ctx7, {
                    type: 'scatter',
                    data: {
                        datasets: [
                            {
                                label: 'No Change Line',
                                data: [{x: 0, y: 0}, {x: 10, y: 10}],
                                type: 'line',
                                borderColor: 'rgba(6, 182, 212, 0.4)',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                pointRadius: 0,
                                fill: false
                            },
                            ...createPositionDatasets(players, 
                                p => p.season.points / p.season.games, 
                                'ptsPerGame', 
                                true
                            )
                        ]
                    },
                    options: {
                        ...baseOptions,
                        scales: {
                            x: { ...baseOptions.scales.x, title: { display: true, text: 'Season Avg Points/Game', color: '#8b95a5' }, min: 0 },
                            y: { ...baseOptions.scales.y, title: { display: true, text: 'L5 Points/Game', color: '#8b95a5' }, min: 0 }
                        }
                    }
                });
            }
            
            // 8. Position Distribution
            const ctx8 = document.getElementById('positionDistChart')?.getContext('2d');
            if (ctx8) {
                const positionStats = ['GK', 'DEF', 'MID', 'FWD'].map(pos => {
                    const posPlayers = players.filter(p => p.pos === pos);
                    const points = posPlayers.map(p => p.ptsPerGame).sort((a, b) => a - b);
                    return {
                        position: pos,
                        avg: points.length ? points.reduce((a, b) => a + b, 0) / points.length : 0,
                        max: points.length ? Math.max(...points) : 0,
                        top5Avg: points.length >= 5 ? points.slice(-5).reduce((a, b) => a + b, 0) / 5 : 0
                    };
                });
                
                chartInstances.positionDist = new Chart(ctx8, {
                    type: 'bar',
                    data: {
                        labels: ['GK', 'DEF', 'MID', 'FWD'],
                        datasets: [
                            {
                                label: 'Average',
                                data: positionStats.map(p => p.avg),
                                backgroundColor: 'rgba(139, 149, 165, 0.6)',
                                borderColor: 'rgba(139, 149, 165, 1)',
                                borderWidth: 1
                            },
                            {
                                label: 'Top 5 Average',
                                data: positionStats.map(p => p.top5Avg),
                                backgroundColor: 'rgba(0, 255, 136, 0.6)',
                                borderColor: 'rgba(0, 255, 136, 1)',
                                borderWidth: 1
                            },
                            {
                                label: 'Best Player',
                                data: positionStats.map(p => p.max),
                                backgroundColor: 'rgba(255, 204, 0, 0.6)',
                                borderColor: 'rgba(255, 204, 0, 1)',
                                borderWidth: 1
                            }
                        ]
                    },
                    options: {
                        ...baseOptions,
                        plugins: {
                            ...baseOptions.plugins,
                            legend: { 
                                display: true,
                                labels: { color: '#8b95a5', font: { size: 10 } }
                            }
                        },
                        scales: {
                            x: { ...baseOptions.scales.x },
                            y: { ...baseOptions.scales.y, title: { display: true, text: 'Points/Game (L5)', color: '#8b95a5' } }
                        }
                    }
                });
            }
        }
        
        // Find value outliers
        function findOutliers(players, xKey, yKey, count = 5) {
            return players
                .map(p => ({
                    ...p,
                    residual: p[yKey] - (p[xKey] * 0.5) // Distance from value line
                }))
                .sort((a, b) => b.residual - a.residual)
                .slice(0, count);
        }
        
        // Find xGI outliers (underperformers)
        function findXGIOutliers(players, count = 5) {
            return players
                .filter(p => p.pos !== 'GK' && p.xgiPerGame > 0.2)
                .map(p => ({
                    ...p,
                    xgiDiff: p.xgiPerGame - p.actualGI
                }))
                .sort((a, b) => b.xgiDiff - a.xgiDiff)
                .slice(0, count);
        }
        
        // Create outlier labels config (placeholder - would need chartjs-plugin-datalabels)
        function createOutlierLabels(outliers) {
            return {}; // Labels handled in summary instead
        }
        
        // ============================================
        // FORM TIMELINE - Sparkline visualization
        // ============================================
        function renderFormTimeline(players) {
            const container = document.getElementById('formTimelineContainer');
            if (!container) return;
            
            // Get top players by recent form
            const topPlayers = players
                .filter(p => activePositionFilters[p.pos])
                .sort((a, b) => b.ptsPerGame - a.ptsPerGame)
                .slice(0, 15);
            
            if (topPlayers.length === 0) {
                container.innerHTML = '<p style="color: var(--text-dim); text-align: center; padding: 20px;">No players match current filters</p>';
                return;
            }
            
            let html = `
                <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 12px;">
            `;
            
            topPlayers.forEach(p => {
                // Generate estimated trend data (simulated GW-by-GW based on form)
                const trend = generateFormTrend(p);
                const trendDirection = trend[4] > trend[0] ? 'up' : trend[4] < trend[0] ? 'down' : 'stable';
                const trendColor = trendDirection === 'up' ? 'var(--accent-green)' : 
                                  trendDirection === 'down' ? 'var(--accent-red)' : 'var(--text-dim)';
                const trendArrow = trendDirection === 'up' ? '‚Üó' : trendDirection === 'down' ? '‚Üò' : '‚Üí';
                const maxPts = Math.max(...trend, 1);
                
                html += `
                    <div style="background: var(--surface-light); padding: 12px; border-radius: 6px; border-left: 3px solid ${POSITION_COLORS[p.pos].border};">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                            <div>
                                <div style="font-size: 12px; font-weight: 600; color: var(--text);">${p.name}</div>
                                <div style="font-size: 9px; color: var(--text-dim);">${p.team} ‚Ä¢ ${p.pos} ‚Ä¢ ¬£${p.price.toFixed(1)}m</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 14px; font-weight: 700; color: ${trendColor};">${p.ptsPerGame.toFixed(1)}</div>
                                <div style="font-size: 9px; color: ${trendColor};">${trendArrow} pts/g</div>
                            </div>
                        </div>
                        <div style="height: 40px; display: flex; align-items: end; gap: 3px;">
                            ${trend.map((pts, i) => {
                                const height = Math.max(4, (pts / maxPts) * 36);
                                const isLast = i === 4;
                                const opacity = isLast ? 1 : 0.4 + (i * 0.12);
                                return `<div style="flex: 1; height: ${height}px; background: ${isLast ? trendColor : 'var(--text-dim)'}; opacity: ${opacity}; border-radius: 2px 2px 0 0;" title="GW-${5-i}: ${pts.toFixed(1)} pts"></div>`;
                            }).join('')}
                        </div>
                        <div style="display: flex; justify-content: space-between; font-size: 8px; color: var(--text-dim); margin-top: 4px;">
                            <span>GW-5</span>
                            <span>GW-1</span>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        // Generate simulated form trend based on available data
        function generateFormTrend(player) {
            const l5Avg = player.ptsPerGame;
            const seasonAvg = player.season.points / player.season.games;
            const improvement = (l5Avg - seasonAvg) / 5;
            
            const trend = [];
            for (let i = 0; i < 5; i++) {
                const base = seasonAvg + (improvement * i);
                const variance = (Math.random() - 0.5) * 3;
                trend.push(Math.max(0, base + variance));
            }
            // Ensure last value reflects actual L5 average
            trend[4] = l5Avg + (Math.random() - 0.5) * 1.5;
            return trend;
        }
        
        // ============================================
        // MINUTES HEATMAP - Rotation Risk Visualization
        // ============================================
        function renderMinutesHeatmap(players) {
            const container = document.getElementById('minutesHeatmapContainer');
            if (!container) return;
            
            // Get top players by minutes, sorted by average minutes descending
            const topPlayers = players
                .filter(p => activePositionFilters[p.pos])
                .sort((a, b) => b.minutesPerGame - a.minutesPerGame)
                .slice(0, 20);
            
            if (topPlayers.length === 0) {
                container.innerHTML = '<p style="color: var(--text-dim); text-align: center; padding: 20px;">No players match current filters</p>';
                return;
            }
            
            const getMinColor = (mins) => {
                if (mins >= 90) return '#10b981';
                if (mins >= 75) return '#22c55e';
                if (mins >= 60) return '#84cc16';
                if (mins >= 45) return '#f59e0b';
                if (mins > 0) return '#ef4444';
                return '#374151';
            };
            
            let html = `
                <table style="width: 100%; border-collapse: collapse; min-width: 600px;">
                    <thead>
                        <tr style="background: var(--surface-light);">
                            <th style="padding: 10px; text-align: left; color: var(--text); font-size: 11px; position: sticky; left: 0; background: var(--surface-light); z-index: 1;">Player</th>
                            <th style="padding: 8px; text-align: center; color: var(--text-dim); font-size: 10px;">GW-5</th>
                            <th style="padding: 8px; text-align: center; color: var(--text-dim); font-size: 10px;">GW-4</th>
                            <th style="padding: 8px; text-align: center; color: var(--text-dim); font-size: 10px;">GW-3</th>
                            <th style="padding: 8px; text-align: center; color: var(--text-dim); font-size: 10px;">GW-2</th>
                            <th style="padding: 8px; text-align: center; color: var(--text-dim); font-size: 10px;">GW-1</th>
                            <th style="padding: 8px; text-align: center; color: var(--accent-green); font-size: 10px;">Avg</th>
                            <th style="padding: 8px; text-align: center; color: var(--text-dim); font-size: 10px;">Risk</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            topPlayers.forEach((p, idx) => {
                const minsHistory = generateMinsHistory(p);
                const avgMins = p.minutesPerGame;
                const rowBg = idx % 2 === 0 ? 'var(--surface)' : 'var(--surface-light)';
                const riskLevel = avgMins >= 80 ? { text: 'üü¢ LOW', color: 'var(--accent-green)' } :
                                 avgMins >= 65 ? { text: 'üü° MED', color: 'var(--accent-yellow)' } :
                                 { text: 'üî¥ HIGH', color: 'var(--accent-red)' };
                
                html += `
                    <tr style="background: ${rowBg};">
                        <td style="padding: 8px 10px; font-size: 11px; color: var(--text); position: sticky; left: 0; background: ${rowBg}; z-index: 1;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="width: 8px; height: 8px; background: ${POSITION_COLORS[p.pos].border}; border-radius: 50%;"></span>
                                <span style="font-weight: 500;">${p.name}</span>
                                <span style="font-size: 9px; color: var(--text-dim);">¬£${p.price.toFixed(1)}m</span>
                            </div>
                        </td>
                        ${minsHistory.map(mins => `
                            <td style="padding: 4px; text-align: center;">
                                <div style="background: ${getMinColor(mins)}; color: ${mins > 0 ? '#000' : 'var(--text-dim)'}; padding: 6px 2px; border-radius: 4px; font-size: 9px; font-weight: 600; min-width: 30px;">
                                    ${mins > 0 ? mins : '-'}
                                </div>
                            </td>
                        `).join('')}
                        <td style="padding: 8px; text-align: center; font-weight: 600; color: var(--text); font-size: 11px;">${avgMins.toFixed(0)}</td>
                        <td style="padding: 8px; text-align: center; font-size: 9px; color: ${riskLevel.color};">${riskLevel.text}</td>
                    </tr>
                `;
            });
            
            html += `
                    </tbody>
                </table>
                <div style="margin-top: 12px; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; font-size: 9px;">
                    <span style="display: flex; align-items: center; gap: 4px;"><span style="width: 14px; height: 14px; background: #10b981; border-radius: 3px;"></span> 90</span>
                    <span style="display: flex; align-items: center; gap: 4px;"><span style="width: 14px; height: 14px; background: #22c55e; border-radius: 3px;"></span> 75-89</span>
                    <span style="display: flex; align-items: center; gap: 4px;"><span style="width: 14px; height: 14px; background: #84cc16; border-radius: 3px;"></span> 60-74</span>
                    <span style="display: flex; align-items: center; gap: 4px;"><span style="width: 14px; height: 14px; background: #f59e0b; border-radius: 3px;"></span> 45-59</span>
                    <span style="display: flex; align-items: center; gap: 4px;"><span style="width: 14px; height: 14px; background: #ef4444; border-radius: 3px;"></span> 1-44</span>
                    <span style="display: flex; align-items: center; gap: 4px;"><span style="width: 14px; height: 14px; background: #374151; border-radius: 3px;"></span> DNP</span>
                </div>
            `;
            
            container.innerHTML = html;
        }
        
        // Generate estimated minutes history based on average
        function generateMinsHistory(player) {
            const avgMins = player.minutesPerGame;
            const history = [];
            
            for (let i = 0; i < 5; i++) {
                if (avgMins >= 85) {
                    // Nailed on - mostly 90s
                    history.push(Math.random() > 0.1 ? 90 : Math.floor(75 + Math.random() * 15));
                } else if (avgMins >= 70) {
                    // Regular starter with occasional sub
                    const roll = Math.random();
                    if (roll > 0.2) history.push(90);
                    else history.push(Math.floor(60 + Math.random() * 30));
                } else if (avgMins >= 50) {
                    // Rotation risk
                    const roll = Math.random();
                    if (roll > 0.5) history.push(90);
                    else if (roll > 0.15) history.push(Math.floor(30 + Math.random() * 60));
                    else history.push(0);
                } else {
                    // High rotation / bench player
                    const roll = Math.random();
                    if (roll > 0.6) history.push(Math.floor(60 + Math.random() * 30));
                    else if (roll > 0.3) history.push(Math.floor(10 + Math.random() * 35));
                    else history.push(0);
                }
            }
            
            return history;
        }
        
        // Generate outliers summary
        function generateOutliersSummary(players) {
            const container = document.getElementById('outliersSummary');
            if (!container) return;
            
            // Find top outliers
            const valueOutliers = findOutliers(players, 'price', 'ptsPerGame', 5);
            const underperformers = findXGIOutliers(players, 5);
            const differentials = players
                .filter(p => p.ownership < 10 && p.ptsPerGame >= 4)
                .sort((a, b) => b.ptsPerGame - a.ptsPerGame)
                .slice(0, 5);
            const bonusMagnets = players
                .filter(p => p.bonusPerGame > 0)
                .sort((a, b) => b.bonusPerGame - a.bonusPerGame)
                .slice(0, 5);
            const rotationRisks = players
                .filter(p => p.minutesPerGame < 75 && p.ownership > 10)
                .sort((a, b) => a.minutesPerGame - b.minutesPerGame)
                .slice(0, 5);
            
            container.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 15px;">
                    <!-- Value Kings -->
                    <div style="background: var(--surface); padding: 15px; border-radius: 6px; border-left: 3px solid var(--accent-green);">
                        <h4 style="color: var(--accent-green); font-size: 12px; margin-bottom: 10px;">üí∞ Best Value</h4>
                        ${valueOutliers.map((p, i) => `
                            <div style="display: flex; justify-content: space-between; font-size: 10px; padding: 4px 0; border-bottom: 1px solid var(--border);">
                                <span style="color: ${POSITION_COLORS[p.pos].border};">${p.name}</span>
                                <span style="color: var(--text-dim);">¬£${p.price.toFixed(1)}m ‚Üí ${p.ptsPerGame.toFixed(1)}pts</span>
                            </div>
                        `).join('')}
                    </div>
                    
                    <!-- Underperformers -->
                    <div style="background: var(--surface); padding: 15px; border-radius: 6px; border-left: 3px solid var(--accent-yellow);">
                        <h4 style="color: var(--accent-yellow); font-size: 12px; margin-bottom: 10px;">üìä Due Returns (xGI)</h4>
                        ${underperformers.map((p, i) => `
                            <div style="display: flex; justify-content: space-between; font-size: 10px; padding: 4px 0; border-bottom: 1px solid var(--border);">
                                <span style="color: ${POSITION_COLORS[p.pos].border};">${p.name}</span>
                                <span style="color: var(--text-dim);">xGI ${p.xgiPerGame.toFixed(2)} ‚Üí ${p.actualGI.toFixed(2)} actual</span>
                            </div>
                        `).join('')}
                    </div>
                    
                    <!-- Differentials -->
                    <div style="background: var(--surface); padding: 15px; border-radius: 6px; border-left: 3px solid #a855f7;">
                        <h4 style="color: #a855f7; font-size: 12px; margin-bottom: 10px;">üíé Differentials (<10%)</h4>
                        ${differentials.length ? differentials.map((p, i) => `
                            <div style="display: flex; justify-content: space-between; font-size: 10px; padding: 4px 0; border-bottom: 1px solid var(--border);">
                                <span style="color: ${POSITION_COLORS[p.pos].border};">${p.name}</span>
                                <span style="color: var(--text-dim);">${p.ownership.toFixed(1)}% ‚Üí ${p.ptsPerGame.toFixed(1)}pts</span>
                            </div>
                        `).join('') : '<div style="font-size: 10px; color: var(--text-dim);">No standout differentials</div>'}
                    </div>
                    
                    <!-- Bonus Magnets -->
                    <div style="background: var(--surface); padding: 15px; border-radius: 6px; border-left: 3px solid #f59e0b;">
                        <h4 style="color: #f59e0b; font-size: 12px; margin-bottom: 10px;">üèÜ Bonus Magnets</h4>
                        ${bonusMagnets.map((p, i) => `
                            <div style="display: flex; justify-content: space-between; font-size: 10px; padding: 4px 0; border-bottom: 1px solid var(--border);">
                                <span style="color: ${POSITION_COLORS[p.pos].border};">${p.name}</span>
                                <span style="color: var(--text-dim);">${p.bonusPerGame.toFixed(2)} bonus/game</span>
                            </div>
                        `).join('')}
                    </div>
                    
                    <!-- Rotation Risks -->
                    <div style="background: var(--surface); padding: 15px; border-radius: 6px; border-left: 3px solid var(--accent-red);">
                        <h4 style="color: var(--accent-red); font-size: 12px; margin-bottom: 10px;">‚ö†Ô∏è Rotation Risks</h4>
                        ${rotationRisks.length ? rotationRisks.map((p, i) => `
                            <div style="display: flex; justify-content: space-between; font-size: 10px; padding: 4px 0; border-bottom: 1px solid var(--border);">
                                <span style="color: ${POSITION_COLORS[p.pos].border};">${p.name}</span>
                                <span style="color: var(--text-dim);">${p.minutesPerGame.toFixed(0)}min (${p.ownership.toFixed(1)}%)</span>
                            </div>
                        `).join('') : '<div style="font-size: 10px; color: var(--text-dim);">No major rotation risks</div>'}
                    </div>
                </div>
            `;
        }
        
        // ============================================
        // FIXTURE TICKER: Visual Team Fixture Display
        // ============================================
        
        function generateFixtureTicker(analyses) {
            // Get unique teams from analyses
            const teamData = {};
            analyses.forEach(p => {
                if (p.teamId && p.fixtures && !teamData[p.teamId]) {
                    teamData[p.teamId] = {
                        id: p.teamId,
                        name: p.team,
                        fixtures: p.fixtures
                    };
                }
            });
            
            // Sort by average FDR (easiest first)
            const sortedTeams = Object.values(teamData)
                .filter(t => t.fixtures && t.fixtures.next5)
                .sort((a, b) => (a.fixtures.avgFDR5 || 5) - (b.fixtures.avgFDR5 || 5));
            
            const getFDRColor = (fdr) => {
                if (fdr <= 2) return '#10b981'; // Very easy - bright green
                if (fdr <= 2.5) return '#22c55e'; // Easy - green
                if (fdr <= 3) return '#84cc16'; // Fairly easy - lime
                if (fdr <= 3.5) return '#f59e0b'; // Medium - amber
                if (fdr <= 4) return '#ef4444'; // Hard - red
                return '#991b1b'; // Very hard - dark red
            };
            
            const getFDRLabel = (fdr) => {
                if (fdr <= 2) return 'Very Easy';
                if (fdr <= 2.5) return 'Easy';
                if (fdr <= 3) return 'Medium';
                if (fdr <= 3.5) return 'Tricky';
                if (fdr <= 4) return 'Hard';
                return 'Very Hard';
            };
            
            let html = `
                <div style="padding: 20px;">
                    <div style="margin-bottom: 25px; padding: 20px; background: var(--surface); border-left: 4px solid var(--accent-yellow); border-radius: 4px;">
                        <h2 style="color: var(--accent-yellow); font-family: 'Space Mono', monospace; margin-bottom: 10px;">
                            üìÖ Fixture Ticker - Next 5 Gameweeks
                        </h2>
                        <p style="font-size: 12px; color: var(--text-dim);">
                            Teams sorted by fixture difficulty (easiest first). Target players from teams with green runs.
                            <strong>H</strong> = Home, <strong>A</strong> = Away
                        </p>
                    </div>
                    
                    <!-- FDR Legend -->
                    <div style="display: flex; gap: 15px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center; padding: 15px; background: var(--surface); border-radius: 6px;">
                        <span style="font-size: 11px; color: var(--text-dim);">FDR Scale:</span>
                        ${[1, 2, 2.5, 3, 3.5, 4, 5].map(fdr => `
                            <span style="display: flex; align-items: center; gap: 4px; font-size: 10px;">
                                <span style="width: 20px; height: 20px; background: ${getFDRColor(fdr)}; border-radius: 3px;"></span>
                                ${fdr <= 2 ? '1-2' : fdr <= 2.5 ? '2-2.5' : fdr <= 3 ? '2.5-3' : fdr <= 3.5 ? '3-3.5' : fdr <= 4 ? '3.5-4' : '4-5'}
                            </span>
                        `).join('')}
                    </div>
                    
                    <!-- Fixture Table -->
                    <div style="background: var(--surface); border-radius: 6px; overflow: hidden; border: 1px solid var(--border);">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="background: var(--surface-light);">
                                    <th style="padding: 12px 15px; text-align: left; color: var(--accent-green); font-size: 11px; border-bottom: 2px solid var(--accent-green);">Team</th>
                                    <th style="padding: 12px; text-align: center; color: var(--text-dim); font-size: 10px; border-bottom: 2px solid var(--accent-green);">GW+1</th>
                                    <th style="padding: 12px; text-align: center; color: var(--text-dim); font-size: 10px; border-bottom: 2px solid var(--accent-green);">GW+2</th>
                                    <th style="padding: 12px; text-align: center; color: var(--text-dim); font-size: 10px; border-bottom: 2px solid var(--accent-green);">GW+3</th>
                                    <th style="padding: 12px; text-align: center; color: var(--text-dim); font-size: 10px; border-bottom: 2px solid var(--accent-green);">GW+4</th>
                                    <th style="padding: 12px; text-align: center; color: var(--text-dim); font-size: 10px; border-bottom: 2px solid var(--accent-green);">GW+5</th>
                                    <th style="padding: 12px 15px; text-align: center; color: var(--accent-yellow); font-size: 10px; border-bottom: 2px solid var(--accent-green);">Avg FDR</th>
                                </tr>
                            </thead>
                            <tbody>
            `;
            
            sortedTeams.forEach((team, index) => {
                const fixtures = team.fixtures.next5 || [];
                const avgFDR = team.fixtures.avgFDR5 || 3;
                const rowBg = index % 2 === 0 ? 'var(--surface)' : 'var(--surface-light)';
                
                html += `
                    <tr style="background: ${rowBg};">
                        <td style="padding: 10px 15px; font-weight: 600; color: var(--text); font-size: 12px; border-bottom: 1px solid var(--border);">
                            ${team.name}
                            <span style="font-size: 9px; color: var(--text-dim); margin-left: 6px;">#${index + 1}</span>
                        </td>
                `;
                
                // Render 5 fixtures
                for (let i = 0; i < 5; i++) {
                    const fixture = fixtures[i];
                    if (fixture) {
                        const opponentTeam = teams[fixture.opponent];
                        const opponentName = opponentTeam ? opponentTeam.short_name : 'UNK';
                        const isHome = fixture.is_home;
                        const fdr = fixture.difficulty;
                        const bgColor = getFDRColor(fdr);
                        const textColor = fdr <= 3 ? '#000' : '#fff';
                        
                        html += `
                            <td style="padding: 6px; text-align: center; border-bottom: 1px solid var(--border);">
                                <div style="background: ${bgColor}; color: ${textColor}; padding: 8px 4px; border-radius: 4px; font-size: 10px; font-weight: 600;">
                                    ${opponentName}
                                    <div style="font-size: 8px; opacity: 0.8; margin-top: 2px;">${isHome ? 'H' : 'A'}</div>
                                </div>
                            </td>
                        `;
                    } else {
                        html += `
                            <td style="padding: 6px; text-align: center; border-bottom: 1px solid var(--border);">
                                <div style="background: var(--bg-dark); color: var(--text-dim); padding: 8px 4px; border-radius: 4px; font-size: 10px;">
                                    -
                                </div>
                            </td>
                        `;
                    }
                }
                
                // Average FDR
                const avgColor = getFDRColor(avgFDR);
                html += `
                        <td style="padding: 10px 15px; text-align: center; border-bottom: 1px solid var(--border);">
                            <div style="display: inline-block; background: ${avgColor}; color: ${avgFDR <= 3 ? '#000' : '#fff'}; padding: 6px 12px; border-radius: 15px; font-size: 11px; font-weight: 600;">
                                ${avgFDR.toFixed(2)}
                            </div>
                            <div style="font-size: 8px; color: var(--text-dim); margin-top: 4px;">${getFDRLabel(avgFDR)}</div>
                        </td>
                    </tr>
                `;
            });
            
            html += `
                            </tbody>
                        </table>
                    </div>
                    
                    <!-- Quick Summary Cards -->
                    <div style="margin-top: 25px; display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                        <div style="background: var(--surface); padding: 20px; border-radius: 6px; border-left: 4px solid var(--accent-green);">
                            <h4 style="color: var(--accent-green); font-size: 12px; margin-bottom: 10px;">üü¢ Easiest Runs (Next 5)</h4>
                            <div style="font-size: 11px; color: var(--text);">
                                ${sortedTeams.slice(0, 5).map((t, i) => `
                                    <div style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid var(--border);">
                                        <span>${i + 1}. ${t.name}</span>
                                        <span style="color: var(--accent-green);">${t.fixtures.avgFDR5.toFixed(2)}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        
                        <div style="background: var(--surface); padding: 20px; border-radius: 6px; border-left: 4px solid var(--accent-red);">
                            <h4 style="color: var(--accent-red); font-size: 12px; margin-bottom: 10px;">üî¥ Toughest Runs (Next 5)</h4>
                            <div style="font-size: 11px; color: var(--text);">
                                ${sortedTeams.slice(-5).reverse().map((t, i) => `
                                    <div style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid var(--border);">
                                        <span>${i + 1}. ${t.name}</span>
                                        <span style="color: var(--accent-red);">${t.fixtures.avgFDR5.toFixed(2)}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        
                        <div style="background: var(--surface); padding: 20px; border-radius: 6px; border-left: 4px solid var(--accent-yellow);">
                            <h4 style="color: var(--accent-yellow); font-size: 12px; margin-bottom: 10px;">‚ö° Fixture Swing (Improving)</h4>
                            <div style="font-size: 10px; color: var(--text-dim); margin-bottom: 8px;">Teams whose fixtures get easier</div>
                            <div style="font-size: 11px; color: var(--text);">
                                ${sortedTeams
                                    .filter(t => t.fixtures.next5 && t.fixtures.next5.length >= 5)
                                    .map(t => {
                                        const first2 = t.fixtures.next5.slice(0, 2).reduce((a, f) => a + f.difficulty, 0) / 2;
                                        const last2 = t.fixtures.next5.slice(3, 5).reduce((a, f) => a + f.difficulty, 0) / 2;
                                        return { ...t, swing: first2 - last2 };
                                    })
                                    .sort((a, b) => b.swing - a.swing)
                                    .slice(0, 5)
                                    .map((t, i) => `
                                        <div style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid var(--border);">
                                            <span>${i + 1}. ${t.name}</span>
                                            <span style="color: ${t.swing > 0 ? 'var(--accent-green)' : 'var(--accent-red)'};">
                                                ${t.swing > 0 ? '‚Üó' : '‚Üò'} ${Math.abs(t.swing).toFixed(1)}
                                            </span>
                                        </div>
                                    `).join('')}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            return html;
        }

        // ============================================
        // NEW FEATURES: Presets, Search, Export, Sparklines
        // ============================================

        let currentPosition = null; // Track current tab
        let activeAdvancedFilters = {
            fdr: null,
            price: null,
            ownership: null,
            priceRange: null,
            ownershipRange: null
        };

        // Global Search across all players
        function globalSearch() {
            const searchTerm = document.getElementById('globalSearch').value.toLowerCase();
            if (!currentPosition) return;
            
            const table = document.getElementById(`table-${currentPosition}`);
            if (!table) return;
            
            const tbody = table.querySelector('tbody');
            const rows = tbody.querySelectorAll('tr');
            
            rows.forEach(row => {
                const playerName = row.cells[0]?.textContent.toLowerCase() || '';
                const teamName = row.cells[1]?.textContent.toLowerCase() || '';
                
                if (playerName.includes(searchTerm) || teamName.includes(searchTerm)) {
                    row.style.display = '';
                } else {
                    row.style.display = 'none';
                }
            });
        }

        // Apply Preset Filters
        function applyPreset(presetType) {
            if (!currentPosition || ['RECOMMENDATIONS', 'FORM'].includes(currentPosition)) {
                alert('Please select a position tab (GK/DEF/MID/FWD) to use presets');
                return;
            }
            
            const table = document.getElementById(`table-${currentPosition}`);
            if (!table) return;
            
            // Clear all filters first
            const filterInputs = table.querySelectorAll('.filter-input');
            filterInputs.forEach(input => input.value = '');
            
            if (presetType === 'clear') {
                // Show all rows
                const tbody = table.querySelector('tbody');
                const rows = tbody.querySelectorAll('tr');
                rows.forEach(row => row.style.display = '');
                
                // Clear advanced filters too
                clearAdvancedFilters();
                return;
            }
            
            // Get column indices (varies by position)
            const headers = Array.from(table.querySelectorAll('thead tr:first-child th'));
            const getColIndex = (label) => {
                const index = headers.findIndex(h => h.textContent.includes(label));
                return index;
            };
            
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            // Define price column based on whether Price column exists
            const hasPriceCol = headers.some(h => h.textContent.includes('Price'));
            
            // Apply preset logic
            rows.forEach(row => {
                let show = true;
                const cells = row.cells;
                
                if (presetType === 'budget-enablers') {
                    // Minutes (L5) >=75 - removed price filter since it's not in table
                    const minsL5Idx = headers.findIndex(h => h.textContent.includes('Mins') && h.textContent.includes('L5'));
                    const minsL5 = parseFloat(cells[minsL5Idx]?.textContent || 0);
                    show = minsL5 >= 75;
                    
                } else if (presetType === 'form-players') {
                    // Pts (L5) >=5, Minutes (L5) >=60
                    const ptsL5Idx = headers.findIndex(h => h.textContent.includes('Pts') && h.textContent.includes('L5'));
                    const minsL5Idx = headers.findIndex(h => h.textContent.includes('Mins') && h.textContent.includes('L5'));
                    
                    const ptsL5 = parseFloat(cells[ptsL5Idx]?.textContent || 0);
                    const minsL5 = parseFloat(cells[minsL5Idx]?.textContent || 0);
                    
                    show = ptsL5 >= 5 && minsL5 >= 60;
                    
                } else if (presetType === 'nailed-starters') {
                    // Minutes (L5) >=80
                    const minsL5Idx = headers.findIndex(h => h.textContent.includes('Mins') && h.textContent.includes('L5'));
                    const minsL5 = parseFloat(cells[minsL5Idx]?.textContent || 0);
                    show = minsL5 >= 80;
                    
                } else if (presetType === 'value-picks') {
                    // Pts (L5) >=4, Minutes (L5) >=70
                    const ptsL5Idx = headers.findIndex(h => h.textContent.includes('Pts') && h.textContent.includes('L5'));
                    const minsL5Idx = headers.findIndex(h => h.textContent.includes('Mins') && h.textContent.includes('L5'));
                    
                    const ptsL5 = parseFloat(cells[ptsL5Idx]?.textContent || 0);
                    const minsL5 = parseFloat(cells[minsL5Idx]?.textContent || 0);
                    
                    show = ptsL5 >= 4 && minsL5 >= 70;
                    
                } else if (presetType === 'easy-fixtures') {
                    // FDR <3.0
                    const fdrIdx = getColIndex('FDR');
                    if (fdrIdx !== -1) {
                        const fdrText = cells[fdrIdx]?.textContent || '';
                        const fdr = parseFloat(fdrText.replace(/[^\d.]/g, ''));
                        show = !isNaN(fdr) && fdr < 3.0;
                    }
                }
                
                row.style.display = show ? '' : 'none';
            });
        }

        // Apply Advanced Filters (FDR, Price presets, Ownership presets)
        function applyAdvancedFilter(filterType, filterValue) {
            if (!currentPosition || ['RECOMMENDATIONS', 'FORM'].includes(currentPosition)) {
                alert('Please select a position tab (GK/DEF/MID/FWD) to use filters');
                return;
            }
            
            // Find the parent filter group of the clicked button
            const clickedBtn = event.target;
            const filterGroup = clickedBtn.closest('.filter-group');
            
            // Toggle filter (click again to deactivate)
            if (activeAdvancedFilters[filterType] === filterValue) {
                activeAdvancedFilters[filterType] = null;
                clickedBtn.classList.remove('active');
            } else {
                activeAdvancedFilters[filterType] = filterValue;
                // Remove active class only from chips in the SAME filter group
                if (filterGroup) {
                    filterGroup.querySelectorAll('.filter-chip').forEach(btn => btn.classList.remove('active'));
                }
                clickedBtn.classList.add('active');
                
                // Clear custom range input if using preset for same type
                if (filterType === 'price') {
                    document.getElementById('priceMin').value = '';
                    document.getElementById('priceMax').value = '';
                    activeAdvancedFilters.priceRange = null;
                } else if (filterType === 'ownership') {
                    document.getElementById('ownershipMin').value = '';
                    document.getElementById('ownershipMax').value = '';
                    activeAdvancedFilters.ownershipRange = null;
                }
            }
            
            applyAllAdvancedFilters();
        }

        // Apply custom price range filter
        function applyCustomPriceFilter() {
            const minPrice = parseFloat(document.getElementById('priceMin').value);
            const maxPrice = parseFloat(document.getElementById('priceMax').value);
            
            if (!isNaN(minPrice) || !isNaN(maxPrice)) {
                activeAdvancedFilters.priceRange = {
                    min: isNaN(minPrice) ? 0 : minPrice,
                    max: isNaN(maxPrice) ? 999 : maxPrice
                };
                activeAdvancedFilters.price = null; // Clear preset
                // Only clear price filter chips (in the same filter group)
                const priceGroup = document.getElementById('priceMin').closest('.filter-group');
                if (priceGroup) {
                    priceGroup.querySelectorAll('.filter-chip').forEach(btn => btn.classList.remove('active'));
                }
            }
            
            applyAllAdvancedFilters();
        }

        // Apply custom ownership range filter
        function applyCustomOwnershipFilter() {
            const minOwnership = parseFloat(document.getElementById('ownershipMin').value);
            const maxOwnership = parseFloat(document.getElementById('ownershipMax').value);
            
            if (!isNaN(minOwnership) || !isNaN(maxOwnership)) {
                activeAdvancedFilters.ownershipRange = {
                    min: isNaN(minOwnership) ? 0 : minOwnership,
                    max: isNaN(maxOwnership) ? 999 : maxOwnership
                };
                activeAdvancedFilters.ownership = null; // Clear preset
                // Only clear ownership filter chips (in the same filter group)
                const ownershipGroup = document.getElementById('ownershipMin').closest('.filter-group');
                if (ownershipGroup) {
                    ownershipGroup.querySelectorAll('.filter-chip').forEach(btn => btn.classList.remove('active'));
                }
            }
            
            applyAllAdvancedFilters();
        }

        // Apply all active advanced filters
        function applyAllAdvancedFilters() {
            if (!currentPosition) return;
            
            const table = document.getElementById(`table-${currentPosition}`);
            if (!table) return;
            
            const headers = Array.from(table.querySelectorAll('thead tr:first-child th'));
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            // Helper to get column index
            const getColIndex = (label) => headers.findIndex(h => h.textContent.includes(label));
            
            rows.forEach(row => {
                let show = true;
                const cells = row.cells;
                
                // FDR Filter
                if (activeAdvancedFilters.fdr) {
                    const fdrIdx = getColIndex('FDR');
                    if (fdrIdx !== -1) {
                        const fdrText = cells[fdrIdx]?.textContent || '';
                        const fdr = parseFloat(fdrText.replace(/[^\d.]/g, ''));
                        
                        if (!isNaN(fdr)) {
                            if (activeAdvancedFilters.fdr === 'easy' && fdr >= 2.6) show = false;
                            if (activeAdvancedFilters.fdr === 'favorable' && (fdr < 2.6 || fdr >= 2.9)) show = false;
                            if (activeAdvancedFilters.fdr === 'neutral' && (fdr < 2.9 || fdr >= 3.1)) show = false;
                            if (activeAdvancedFilters.fdr === 'tough' && fdr <= 3.4) show = false;
                        }
                    }
                }
                
                // Price Filter (presets)
                if (activeAdvancedFilters.price) {
                    const priceIdx = getColIndex('Price');
                    if (priceIdx !== -1) {
                        const priceText = cells[priceIdx]?.textContent || '';
                        const price = parseFloat(priceText.replace(/[¬£,]/g, ''));
                        
                        if (!isNaN(price)) {
                            if (activeAdvancedFilters.price === 'budget' && price > 5.5) show = false;
                            if (activeAdvancedFilters.price === 'mid' && (price < 5.5 || price > 8.0)) show = false;
                            if (activeAdvancedFilters.price === 'premium' && price <= 8.0) show = false;
                        }
                    }
                }
                
                // Price Range Filter
                if (activeAdvancedFilters.priceRange) {
                    const priceIdx = getColIndex('Price');
                    if (priceIdx !== -1) {
                        const priceText = cells[priceIdx]?.textContent || '';
                        const price = parseFloat(priceText.replace(/[¬£,]/g, ''));
                        
                        if (!isNaN(price)) {
                            if (price < activeAdvancedFilters.priceRange.min || price > activeAdvancedFilters.priceRange.max) {
                                show = false;
                            }
                        }
                    }
                }
                
                // Ownership Filter (presets)
                if (activeAdvancedFilters.ownership) {
                    const ownIdx = getColIndex('Own%');
                    if (ownIdx !== -1) {
                        const ownText = cells[ownIdx]?.textContent || '';
                        const ownership = parseFloat(ownText.replace(/[%,]/g, ''));
                        
                        if (!isNaN(ownership)) {
                            if (activeAdvancedFilters.ownership === 'template' && ownership <= 20) show = false;
                            if (activeAdvancedFilters.ownership === 'popular' && (ownership < 10 || ownership > 20)) show = false;
                            if (activeAdvancedFilters.ownership === 'differential' && ownership >= 10) show = false;
                            if (activeAdvancedFilters.ownership === 'unique' && ownership >= 5) show = false;
                        }
                    }
                }
                
                // Ownership Range Filter
                if (activeAdvancedFilters.ownershipRange) {
                    const ownIdx = getColIndex('Own%');
                    if (ownIdx !== -1) {
                        const ownText = cells[ownIdx]?.textContent || '';
                        const ownership = parseFloat(ownText.replace(/[%,]/g, ''));
                        
                        if (!isNaN(ownership)) {
                            if (ownership < activeAdvancedFilters.ownershipRange.min || ownership > activeAdvancedFilters.ownershipRange.max) {
                                show = false;
                            }
                        }
                    }
                }
                
                row.style.display = show ? '' : 'none';
            });
        }

        // Clear all advanced filters
        function clearAdvancedFilters() {
            activeAdvancedFilters = {
                fdr: null,
                price: null,
                ownership: null,
                priceRange: null,
                ownershipRange: null
            };
            
            // Clear input fields
            document.getElementById('priceMin').value = '';
            document.getElementById('priceMax').value = '';
            document.getElementById('ownershipMin').value = '';
            document.getElementById('ownershipMax').value = '';
            
            // Remove active classes
            document.querySelectorAll('.filter-chip').forEach(btn => btn.classList.remove('active'));
            
            // Show all rows
            if (currentPosition) {
                const table = document.getElementById(`table-${currentPosition}`);
                if (table) {
                    const tbody = table.querySelector('tbody');
                    const rows = tbody.querySelectorAll('tr');
                    rows.forEach(row => row.style.display = '');
                }
            }
        }

        // Export Table to CSV
        function exportToCSV() {
            if (!currentPosition || ['RECOMMENDATIONS', 'FORM'].includes(currentPosition)) {
                alert('Please select a position tab (GK/DEF/MID/FWD) to export');
                return;
            }
            
            const table = document.getElementById(`table-${currentPosition}`);
            if (!table) return;
            
            const rows = [];
            
            // Get headers
            const headerRow = table.querySelectorAll('thead tr:first-child th');
            const headers = Array.from(headerRow).map(th => {
                const text = th.textContent.replace(/‚áÖ/g, '').trim();
                return text;
            });
            rows.push(headers.join(','));
            
            // Get data rows (only visible ones)
            const dataRows = table.querySelectorAll('tbody tr');
            dataRows.forEach(row => {
                if (row.style.display === 'none') return; // Skip hidden rows
                
                const cells = Array.from(row.cells).map(td => {
                    let text = td.textContent.trim();
                    // Clean up emoji and special chars for CSV
                    text = text.replace(/[üü¢üü°üî¥üü†]/g, '');
                    // Escape commas
                    if (text.includes(',')) text = `"${text}"`;
                    return text;
                });
                rows.push(cells.join(','));
            });
            
            // Create CSV file
            const csv = rows.join('\n');
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            
            // Download
            const a = document.createElement('a');
            a.href = url;
            a.download = `fpl-${currentPosition.toLowerCase()}-${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Tab switching - show/hide preset filters
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('tab')) {
                const position = e.target.dataset.position;
                currentPosition = position;
                
                const presetFilters = document.getElementById('presetFilters');
                const advancedFilters = document.getElementById('advancedFilters');
                
                // Show filters only for position tabs (not recommendations/form)
                if (['GK', 'DEF', 'MID', 'FWD'].includes(position)) {
                    presetFilters.style.display = 'flex';
                    advancedFilters.style.display = 'flex';
                    
                    // Clear global search
                    document.getElementById('globalSearch').value = '';
                    
                    // Clear advanced filters
                    clearAdvancedFilters();
                } else {
                    presetFilters.style.display = 'none';
                    advancedFilters.style.display = 'none';
                }
            }
        });

        // Auto-load on page load and show cache info
        window.addEventListener('load', () => {
            showCacheInfo();
            loadData(); // Will use cache if available
        });
    </script>
</body>
</html>